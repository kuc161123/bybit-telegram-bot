#!/usr/bin/env python3
"""
Conversation flow handlers for trade setup - ENHANCED WITH CONSERVATIVE APPROACH.
ADDED: Dual trading approaches (Fast Market vs Conservative Limits)
ENHANCED: Support for 3 limit orders and 4 take profits in conservative mode
ADVANCED: Integration with sophisticated orphan protection system
FIXED: Coroutine serialization error in execute_trade_logic
UPDATED: Display enhanced trade execution messages
"""
import asyncio
import logging
from decimal import Decimal, InvalidOperation
from telegram import Update, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler
from telegram.constants import ParseMode
from html import escape
import uuid

from config.constants import *
# Explicit import to ensure availability
from config.constants import TRADING_APPROACH
from config.settings import LLM_PROVIDER
from utils.formatters import get_emoji, format_decimal_or_na, format_price, create_risk_meter, progress_bar
from utils.helpers import initialize_chat_data, get_field_emoji_and_name, safe_decimal_conversion
from utils.cache import get_instrument_info_cached, get_usdt_wallet_balance_cached
from risk.calculations import calculate_risk_reward_ratio
from dashboard.keyboards_analytics import *
from shared import msg_manager
from clients.bybit_helpers import protect_symbol_from_cleanup, protect_trade_group_from_cleanup  # ENHANCED: Import protection functions

# Ensure TRADING_APPROACH is defined
try:
    _ = TRADING_APPROACH
except NameError:
    TRADING_APPROACH = "trading_approach"

logger = logging.getLogger(__name__)

# Define conversation states - ENHANCED with GGShot screenshot strategy and dual margin selection
SYMBOL, SIDE, SCREENSHOT_UPLOAD, PRIMARY_ENTRY, LIMIT_ENTRIES, TAKE_PROFITS, STOP_LOSS, LEVERAGE, MARGIN, CONFIRMATION, GGSHOT_EDIT_VALUES, MARGIN = range(12)

# Define additional states
APPROACH_SELECTION = 13  # State for approach selection

# Additional states for streamlined GGShot flow
GGSHOT_LIMIT_FLOW_1, GGSHOT_LIMIT_FLOW_2, GGSHOT_LIMIT_FLOW_3 = range(14, 17)
GGSHOT_TP_FLOW_1, GGSHOT_TP_FLOW_2, GGSHOT_TP_FLOW_3, GGSHOT_TP_FLOW_4 = range(17, 21)

def build_conversation_keyboard(include_back=False, back_state=None, include_cancel=True):
    """Build conversation keyboard with optional back button"""
    buttons = []

    if include_back and back_state is not None:
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{back_state}")])

    if include_cancel:
        buttons.append([InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")])

    return InlineKeyboardMarkup(buttons) if buttons else None

def calculate_trade_pnl_preview(entry_price: Decimal, tp_price: Decimal, sl_price: Decimal,
                               margin: Decimal, leverage: int, side: str) -> str:
    """Calculate simple USDT P&L preview for the trade"""
    try:
        # Calculate position size: (margin * leverage) / entry_price
        position_value = margin * leverage
        position_size = position_value / entry_price

        # Calculate profit if TP is hit
        if side == "Buy":
            tp_profit = (tp_price - entry_price) * position_size
            sl_loss = (sl_price - entry_price) * position_size
        else:  # Sell
            tp_profit = (entry_price - tp_price) * position_size
            sl_loss = (entry_price - sl_price) * position_size

        preview_text = f"\nüí° <b>TRADE P&L PREVIEW</b>\n"
        preview_text += f"{'‚îÄ' * 20}\n"
        preview_text += f"üéØ <b>If TP Hit:</b> üü¢ +{format_decimal_or_na(tp_profit, 2)} USDT\n"
        preview_text += f"üõ°Ô∏è <b>If SL Hit:</b> üî¥ {format_decimal_or_na(sl_loss, 2)} USDT\n"

        return preview_text

    except Exception as e:
        logger.error(f"Error calculating trade P&L preview: {e}")
        return ""

# =============================================
# MAIN ENTRY POINT - ENHANCED
# =============================================

async def start_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start enhanced trade setup conversation with dual approaches and protection system"""

    # Determine the source and chat info
    if update.callback_query:
        query = update.callback_query
        chat_id = query.message.chat.id
        user_id = query.from_user.id
        # Always answer the callback first
        try:
            await query.answer("üöÄ Starting enhanced trade setup with protection system...")
        except:
            pass
        is_callback = True
    else:
        chat_id = update.effective_chat.id
        user_id = update.effective_user.id
        is_callback = False

    logger.info(f"Starting enhanced trade conversation with dual approaches and protection system for chat {chat_id}")

    # Initialize chat data
    if context.chat_data is None:
        context.chat_data = {}

    # Backup any existing monitor data
    monitor_backup = context.chat_data.get(ACTIVE_MONITOR_TASK, {})
    old_ui_msg_id = context.chat_data.get(LAST_UI_MESSAGE_ID)

    # Clear and reinitialize
    context.chat_data.clear()
    initialize_chat_data(context.chat_data)
    context.chat_data[ACTIVE_MONITOR_TASK] = monitor_backup

    # Delete old UI message if exists
    if old_ui_msg_id:
        try:
            await context.bot.delete_message(chat_id, old_ui_msg_id)
        except:
            pass

    # Create enhanced welcome message with GGShot
    welcome_msg = (
        f"{get_emoji('rocket')} <b>ENHANCED TRADE SETUP</b> {get_emoji('lightning')}\n\n"
        f"Set up your trade with our advanced trading system!\n\n"
        f"üõ°Ô∏è <b>Advanced protection system prevents order cleanup</b>\n"
        f"‚ö° <b>Fast Market:</b> Instant execution with single TP/SL\n"
        f"üõ°Ô∏è <b>Conservative Limits:</b> 3 entries + 4 take profits\n"
        f"üì∏ <b>GGShot Screenshot:</b> AI extracts trade parameters\n\n"
        f"üìà <b>Step 1 of 8: Trading Symbol</b>\n\n"
        f"Enter the symbol you want to trade:\n"
        f"üí° Examples: <code>BTCUSDT</code>, <code>ETHUSDT</code>, <code>SOLUSDT</code>\n\n"
        f"Type the symbol and press send..."
    )

    # Build cancel keyboard
    cancel_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")],
        [InlineKeyboardButton("üìä Back to Dashboard", callback_data="refresh_dashboard")]
    ])

    try:
        if is_callback and update.callback_query.message:
            # Try to edit the callback message first
            try:
                await update.callback_query.edit_message_text(
                    welcome_msg,
                    parse_mode=ParseMode.HTML,
                    reply_markup=cancel_keyboard
                )
                context.chat_data[LAST_UI_MESSAGE_ID] = update.callback_query.message.message_id
                logger.info(f"Successfully edited callback message for chat {chat_id}")
            except Exception as e_edit:
                logger.warning(f"Could not edit callback message: {e_edit}, sending new message")
                # If edit fails, send new message
                sent_msg = await context.bot.send_message(
                    chat_id,
                    welcome_msg,
                    parse_mode=ParseMode.HTML,
                    reply_markup=cancel_keyboard
                )
                context.chat_data[LAST_UI_MESSAGE_ID] = sent_msg.message_id
        else:
            # Send new message for non-callback scenarios
            sent_msg = await context.bot.send_message(
                chat_id,
                welcome_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
            context.chat_data[LAST_UI_MESSAGE_ID] = sent_msg.message_id

        logger.info(f"Enhanced trade conversation started successfully for chat {chat_id}")
        return SYMBOL

    except Exception as e:
        logger.error(f"Error starting conversation for chat {chat_id}: {e}")
        # Fallback: send a simple message
        try:
            await context.bot.send_message(
                chat_id,
                f"{get_emoji('error')} Error starting trade setup. Please try again with /start",
                parse_mode=ParseMode.HTML
            )
        except:
            pass
        return ConversationHandler.END

# =============================================
# SYMBOL HANDLER - ENHANCED WITH PROTECTION
# =============================================

async def symbol_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle symbol input with enhanced protection system"""
    if not update.message or not update.message.text:
        return SYMBOL

    user_input = update.message.text.strip().upper()
    chat_id = update.effective_chat.id

    logger.info(f"Processing symbol input: {user_input}")

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    # Validate symbol
    if not user_input:
        await send_error_and_retry(
            context, chat_id,
            "Symbol cannot be empty. Please enter a valid symbol:",
            SYMBOL
        )
        return SYMBOL

    # Show validation message
    await edit_last_message(
        context, chat_id,
        f"{get_emoji('loading')} Validating symbol <code>{escape(user_input)}</code>...",
        None
    )

    # Check if symbol exists
    try:
        inst_info = await get_instrument_info_cached(user_input)
        if not inst_info:
            await send_error_and_retry(
                context, chat_id,
                f"‚ùå Invalid symbol: <code>{escape(user_input)}</code>\n\n"
                f"Please enter a valid USDT perpetual contract symbol:",
                SYMBOL
            )
            return SYMBOL
    except Exception as e:
        logger.error(f"Error validating symbol: {e}")
        await send_error_and_retry(
            context, chat_id,
            f"‚ùå Error validating symbol. Please try again:",
            SYMBOL
        )
        return SYMBOL

    # PROTECTION: Immediately protect the symbol once it's validated
    try:
        protect_symbol_from_cleanup(user_input)
        logger.info(f"üõ°Ô∏è Symbol {user_input} protected from cleanup during conversation")
    except Exception as e:
        logger.error(f"Error protecting symbol: {e}")
        # Continue anyway, this is not critical for trade setup

    # Store symbol with multiple key formats for compatibility
    context.chat_data["symbol"] = user_input
    context.chat_data[SYMBOL] = user_input
    context.chat_data["SYMBOL"] = user_input  # Backup

    # Store instrument info with proper error handling
    try:
        context.chat_data[INSTRUMENT_TICK_SIZE] = safe_decimal_conversion(inst_info["priceFilter"]["tickSize"])
        context.chat_data[INSTRUMENT_QTY_STEP] = safe_decimal_conversion(inst_info["lotSizeFilter"]["qtyStep"])
        context.chat_data[MIN_ORDER_QTY] = safe_decimal_conversion(inst_info["lotSizeFilter"].get("minOrderQty", "0"))
        context.chat_data[MIN_ORDER_NOTIONAL_VALUE] = safe_decimal_conversion(inst_info["lotSizeFilter"].get("minNotional", "0"))
        context.chat_data[MAX_LEVERAGE_FOR_SYMBOL] = safe_decimal_conversion(inst_info.get("leverageFilter", {}).get("maxLeverage", "100"))

        logger.info(f"Instrument info stored: tickSize={context.chat_data[INSTRUMENT_TICK_SIZE]}, qtyStep={context.chat_data[INSTRUMENT_QTY_STEP]}")
    except Exception as e:
        logger.error(f"Error parsing instrument info: {e}")
        # Set safe defaults
        context.chat_data[MAX_LEVERAGE_FOR_SYMBOL] = Decimal("100")
        context.chat_data[MIN_ORDER_QTY] = Decimal("0")
        context.chat_data[MIN_ORDER_NOTIONAL_VALUE] = Decimal("0")
        context.chat_data[INSTRUMENT_TICK_SIZE] = Decimal("0.01")
        context.chat_data[INSTRUMENT_QTY_STEP] = Decimal("0.01")

    # Ask for side
    side_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{user_input}</code> üõ°Ô∏è\n\n"
        f"üìà <b>Step 2 of 7: Trade Direction</b>\n\n"
        f"Choose your trading direction:"
    )

    side_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"üìà LONG (Buy)", callback_data="conv_side:Buy")],
        [InlineKeyboardButton(f"üìâ SHORT (Sell)", callback_data="conv_side:Sell")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SYMBOL}")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, side_msg, side_keyboard)
    return SIDE

# =============================================
# SIDE HANDLER
# =============================================

async def side_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle side selection via callback"""
    # This should be handled by callback, not text input
    # If we get here via text, it's an error
    if update.message:
        await update.message.delete()
        await send_error_and_retry(
            context, update.effective_chat.id,
            "Please use the buttons to select your trading direction:",
            SIDE
        )
    return SIDE

async def handle_side_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle side selection callback and move to approach selection"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    if not query.data.startswith("conv_side:"):
        return SIDE

    side = query.data.split(":")[1]

    # Store side with multiple key formats
    context.chat_data["side"] = side
    context.chat_data[SIDE] = side
    context.chat_data["SIDE"] = side  # Backup

    symbol = context.chat_data.get(SYMBOL, "Unknown")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    # ENHANCED: Ask for trading approach selection including GGShot
    approach_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n\n"
        f"üéØ <b>Step 3 of 8: Trading Approach</b>\n\n"
        f"Choose your trading strategy:\n\n"
        f"‚ö° <b>Fast Market</b>\n"
        f"‚Ä¢ Single entry at market price\n"
        f"‚Ä¢ One take profit (100% close)\n"
        f"‚Ä¢ Best for quick moves\n\n"
        f"üõ°Ô∏è <b>Conservative Limits</b>\n"
        f"‚Ä¢ 3 limit orders (equal allocation)\n"
        f"‚Ä¢ 4 take profits (70%, 10%, 10%, 10%)\n"
        f"‚Ä¢ Better risk management\n\n"
        f"üì∏ <b>GGShot Screenshot</b>\n"
        f"‚Ä¢ Upload trading screenshot\n"
        f"‚Ä¢ AI extracts trade parameters\n"
        f"‚Ä¢ Auto-populate setup\n"
        f"‚Ä¢ Smart strategy detection\n\n"
        f"Select your preferred approach:"
    )

    approach_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"‚ö° Fast Market", callback_data="conv_approach:fast")],
        [InlineKeyboardButton(f"üõ°Ô∏è Conservative Limits", callback_data="conv_approach:conservative")],
        [InlineKeyboardButton(f"üì∏ GGShot Screenshot", callback_data="conv_approach:ggshot")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    try:
        await query.edit_message_text(
            approach_msg,
            parse_mode=ParseMode.HTML,
            reply_markup=approach_keyboard
        )
    except Exception as e:
        logger.error(f"Error editing message in handle_side_callback: {e}")
        # Send new message if edit fails
        sent = await context.bot.send_message(
            query.message.chat.id,
            approach_msg,
            parse_mode=ParseMode.HTML,
            reply_markup=approach_keyboard
        )
        context.chat_data[LAST_UI_MESSAGE_ID] = sent.message_id

    context.chat_data[TRADING_APPROACH] = "conservative"
    return MARGIN

# =============================================
# ENHANCED: APPROACH SELECTION HANDLER WITH PROTECTION
# =============================================

async def approach_selection_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle approach selection via callback"""
    if update.message:
        await update.message.delete()
        await send_error_and_retry(
            context, update.effective_chat.id,
            "Please use the buttons to select your trading approach:",
            APPROACH_SELECTION
        )
    return MARGIN

async def handle_approach_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle trading approach selection callback with protection system integration"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    if not query.data.startswith("conv_approach:"):
        context.chat_data[TRADING_APPROACH] = "conservative"
        return MARGIN

    approach = query.data.split(":")[1]

    # Store approach selection
    context.chat_data[TRADING_APPROACH] = approach
    # Also store in user_data for persistence
    context.user_data["trading_approach"] = approach

    # Generate unique trade group ID for conservative approach
    if approach == "conservative":
        trade_group_id = str(uuid.uuid4())[:8]
        context.chat_data[CONSERVATIVE_TRADE_GROUP_ID] = trade_group_id
        context.chat_data[ORDER_STRATEGY] = STRATEGY_CONSERVATIVE_LIMITS

        # PROTECTION: Protect the trade group from cleanup
        try:
            protect_trade_group_from_cleanup(trade_group_id)
            logger.info(f"üõ°Ô∏è Trade group {trade_group_id} protected from cleanup during conversation")
        except Exception as e:
            logger.error(f"Error protecting trade group: {e}")
            # Continue anyway, this is not critical for trade setup
    elif approach == "ggshot":
        # GGShot approach - will determine strategy after AI analysis
        context.chat_data[ORDER_STRATEGY] = None  # Will be set after screenshot analysis
    else:
        context.chat_data[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY

    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    if approach == "fast":
        approach_emoji = "‚ö°"
        approach_text = "Fast Market"
    elif approach == "conservative":
        approach_emoji = "üõ°Ô∏è"
        approach_text = "Conservative Limits"
    elif approach == "ggshot":
        approach_emoji = "üì∏"
        approach_text = "GGShot Screenshot"

    if approach == "fast":
        # Fast approach - ask for single entry price
        entry_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n\n"
            f"üí∞ <b>Step 4 of 7: Entry Price</b>\n\n"
            f"Enter your market entry price:\n"
            f"üí° Example: <code>65000.50</code>\n\n"
            f"üõ°Ô∏è Orders will be protected from cleanup"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                entry_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message: {e}")

        return PRIMARY_ENTRY

    elif approach == "conservative":
        # Conservative approach - ask for 3 limit order prices
        trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")

        limit_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"‚úÖ <b>Trade Group:</b> {trade_group_id} üõ°Ô∏è\n\n"
            f"üìä <b>Step 4 of 8: Limit Order Prices</b>\n\n"
            f"Enter 3 limit order prices (one per message):\n"
            f"üí° Each order will use 33.33% of your capital\n"
            f"üí° Enter them in order of preference\n"
            f"üõ°Ô∏è All orders will be protected from cleanup\n\n"
            f"Enter <b>Limit Order #1</b> price:"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                limit_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for conservative approach: {e}")

        # Initialize limit order tracking
        context.chat_data["limit_orders_entered"] = 0

        return LIMIT_ENTRIES

    elif approach == "ggshot":
        # GGShot approach - ask for screenshot upload
        screenshot_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n\n"
            f"üì∏ <b>Step 4 of 8: Upload Screenshot</b>\n\n"
            f"Upload your trading screenshot:\n\n"
            f"üìã <b>What to include:</b>\n"
            f"‚Ä¢ Entry price(s)\n"
            f"‚Ä¢ Take profit level(s)\n"
            f"‚Ä¢ Stop loss level\n"
            f"‚Ä¢ Clear price labels\n\n"
            f"ü§ñ AI will analyze and extract trade parameters automatically\n"
            f"üõ°Ô∏è All extracted orders will be protected from cleanup\n\n"
            f"üì§ <b>Send your screenshot now...</b>"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                screenshot_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for GGShot approach: {e}")

        return SCREENSHOT_UPLOAD

# =============================================
# SCREENSHOT UPLOAD HANDLER (GGShot Approach)
# =============================================

async def screenshot_upload_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle screenshot upload and AI analysis for GGShot approach"""
    if not update.message:
        return SCREENSHOT_UPLOAD

    chat_id = update.effective_chat.id

    # Check if user sent a photo
    if update.message.photo:
        try:
            # Get the highest quality photo
            photo = update.message.photo[-1]

            # Validate file size (Telegram limit is 20MB, but we'll use 10MB for safety)
            if photo.file_size > 10 * 1024 * 1024:  # 10MB
                await send_error_and_retry(
                    context, chat_id,
                    "üì∑ Screenshot is too large (>10MB).\n\nPlease upload a smaller image:",
                    SCREENSHOT_UPLOAD
                )
                return SCREENSHOT_UPLOAD

            # Show processing message
            await edit_last_message(
                context, chat_id,
                f"{get_emoji('loading')} <b>Processing Screenshot...</b>\n\n"
                f"ü§ñ AI is analyzing your trading setup\n"
                f"üìä Extracting trade parameters\n"
                f"‚è≥ This may take a few seconds...",
                None
            )

            photo_file = await context.bot.get_file(photo.file_id)

            # Store screenshot info for processing
            context.chat_data["screenshot_file_id"] = photo.file_id
            context.chat_data["screenshot_file_path"] = photo_file.file_path

            # Real AI analysis using Enhanced OpenAI Vision API with multiple accuracy checks
            from utils.screenshot_analyzer_enhanced import EnhancedGGShotAnalyzer

            symbol = context.chat_data.get(SYMBOL, "BTCUSDT")
            side = context.chat_data.get(SIDE, "Buy")

            # Initialize enhanced analyzer
            analyzer = EnhancedGGShotAnalyzer()

            # Show analyzing message with parallel models info
            analyzing_msg = await context.bot.send_message(
                chat_id=chat_id,
                text="üöÄ <b>Parallel AI Analysis</b>\n\n"
                     "üîÑ Running multiple strategies simultaneously:\n"
                     "‚Ä¢ GPT-4o-mini (simple) ‚ö°\n"
                     "‚Ä¢ GPT-4o-mini (numbers) üî¢\n"
                     "‚Ä¢ GPT-4o (detailed) üéØ\n\n"
                     "‚è≥ Analyzing your screenshot...",
                parse_mode=ParseMode.HTML
            )

            # Analyze screenshot with enhanced accuracy checks
            extracted_data = await analyzer.analyze_screenshot(photo_file.file_path, symbol, side)

            # Delete analyzing message
            try:
                await analyzing_msg.delete()
            except:
                pass

            if extracted_data.get("success"):
                # Store extracted parameters
                context.chat_data.update(extracted_data["parameters"])

                # Show extracted parameters for confirmation
                return await show_extracted_parameters_confirmation(context, chat_id, extracted_data)
            else:
                # AI analysis failed - offer manual entry
                return await handle_screenshot_analysis_failure(context, chat_id, extracted_data.get("error", "Unknown error"))

        except Exception as e:
            logger.error(f"Error processing screenshot: {e}")
            await send_error_and_retry(
                context, chat_id,
                f"Error processing screenshot: {escape(str(e))}\n\nPlease try uploading again or use manual entry:",
                SCREENSHOT_UPLOAD
            )
            return SCREENSHOT_UPLOAD

    # User sent text instead of photo
    elif update.message.text:
        # Delete user's message
        try:
            await update.message.delete()
        except:
            pass

        await send_error_and_retry(
            context, chat_id,
            "Please upload a screenshot image, not text.\n\nSend a photo of your trading setup:",
            SCREENSHOT_UPLOAD
        )
        return SCREENSHOT_UPLOAD

    else:
        # Some other message type
        await send_error_and_retry(
            context, chat_id,
            "Please upload a screenshot image.\n\nSend a photo of your trading setup:",
            SCREENSHOT_UPLOAD
        )
        return SCREENSHOT_UPLOAD

async def mock_ai_screenshot_analysis(chat_data: dict) -> dict:
    """Mock AI analysis function - replace with real OpenAI Vision API call"""
    # Simulate AI processing
    await asyncio.sleep(1)

    # Mock extracted parameters based on symbol/side already selected
    symbol = chat_data.get(SYMBOL, "BTCUSDT")
    side = chat_data.get(SIDE, "Buy")

    # Return mock analysis results
    if side == "Buy":
        # Mock long trade
        return {
            "success": True,
            "confidence": 0.85,
            "strategy_type": "conservative",  # or "fast"
            "parameters": {
                PRIMARY_ENTRY_PRICE: Decimal("65000"),
                LIMIT_ENTRY_1_PRICE: Decimal("64800"),
                LIMIT_ENTRY_2_PRICE: Decimal("64600"),
                LIMIT_ENTRY_3_PRICE: Decimal("64400"),
                TP1_PRICE: Decimal("66500"),
                TP2_PRICE: Decimal("67000"),
                TP3_PRICE: Decimal("67500"),
                TP4_PRICE: Decimal("68000"),
                SL_PRICE: Decimal("63000"),
                "leverage": 10,
                "margin_amount": Decimal("100")
            }
        }
    else:
        # Mock short trade
        return {
            "success": True,
            "confidence": 0.80,
            "strategy_type": "fast",
            "parameters": {
                PRIMARY_ENTRY_PRICE: Decimal("65000"),
                TP1_PRICE: Decimal("64000"),
                SL_PRICE: Decimal("66000"),
                "leverage": 10,
                "margin_amount": Decimal("100")
            }
        }

def format_value_with_edit_indicator(value, field_name: str, edited_fields: set) -> str:
    """Format value with edit indicator if it has been edited"""
    formatted_value = f"<code>{format_decimal_or_na(value)}</code>"

    # Check if this field has been edited
    if field_name in edited_fields:
        formatted_value += " ‚úÖ <i>(edited)</i>"

    return formatted_value

async def show_extracted_parameters_confirmation(context: ContextTypes.DEFAULT_TYPE, chat_id: int, extracted_data: dict) -> int:
    """Show extracted parameters and ask for confirmation"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    confidence = extracted_data.get("confidence", 0.0)
    strategy_type = extracted_data.get("strategy_type", "fast")
    params = extracted_data.get("parameters", {})
    validation_errors = extracted_data.get("validation_errors", [])
    quality_report = extracted_data.get("quality_report", {})

    # Get edited fields
    edited_fields = context.chat_data.get("ggshot_edited_fields", set())

    # Get accuracy check results if available
    accuracy_checks = extracted_data.get("accuracy_checks", {})

    # Check if validation failed
    if validation_errors:
        # Show validation errors
        from utils.ggshot_validator import ggshot_validator
        error_report = ggshot_validator.format_validation_report(validation_errors, params, side)

        error_msg = (
            f"ü§ñ <b>AI ANALYSIS COMPLETE</b> üì∏\n"
            f"{'‚ïê' * 25}\n\n"
            f"‚úÖ <b>Extraction Successful</b>\n"
            f"‚ùå <b>Validation Failed</b>\n\n"
            f"{error_report}\n\n"
            f"üîÑ <b>Options:</b>\n"
            f"‚Ä¢ Upload a clearer screenshot\n"
            f"‚Ä¢ Override and continue anyway\n"
            f"‚Ä¢ Switch to manual entry"
        )

        validation_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ö†Ô∏è Override & Continue", callback_data="ggshot_override_validation")],
            [InlineKeyboardButton("üì∏ Upload New Screenshot", callback_data="ggshot_retry_upload")],
            [InlineKeyboardButton("‚úèÔ∏è Manual Entry", callback_data="ggshot_manual_entry")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
        ])

        await edit_last_message(context, chat_id, error_msg, validation_keyboard)
        return CONFIRMATION

    # Update approach based on AI detection
    if strategy_type == "conservative":
        context.chat_data[TRADING_APPROACH] = "conservative"
        context.chat_data[ORDER_STRATEGY] = STRATEGY_CONSERVATIVE_LIMITS
        # Generate trade group ID for conservative approach
        trade_group_id = str(uuid.uuid4())[:8]
        context.chat_data[CONSERVATIVE_TRADE_GROUP_ID] = trade_group_id
        try:
            protect_trade_group_from_cleanup(trade_group_id)
        except Exception as e:
            logger.error(f"Error protecting trade group: {e}")
    else:
        context.chat_data[TRADING_APPROACH] = "fast"
        context.chat_data[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY

    # Build quality feedback message
    quality_msg = ""
    extraction_method = extracted_data.get("extraction_method", "standard extraction")

    if quality_report:
        if quality_report.get("is_blurry"):
            quality_msg += "‚ö†Ô∏è <i>Image appears blurry - results may be less accurate</i>\n"
        if quality_report.get("is_low_res"):
            res = quality_report.get("resolution", "unknown")
            quality_msg += f"‚ö†Ô∏è <i>Low resolution detected ({res}) - consider higher quality screenshot</i>\n"
        if quality_report.get("brightness", {}).get("is_dark"):
            brightness = quality_report.get("brightness", {}).get("mean", "N/A")
            quality_msg += f"üåô <i>Dark image detected (brightness: {brightness}) - enhancement applied</i>\n"
        if quality_report.get("brightness", {}).get("has_low_contrast"):
            quality_msg += "‚úÖ <i>Low contrast detected - enhancement applied</i>\n"

        # Add extraction method if not standard
        if extraction_method != "standard extraction":
            quality_msg += f"üî¨ <i>Enhanced using: {extraction_method}</i>\n"

        if quality_msg:
            quality_msg = f"\nüì∑ <b>Image Quality:</b>\n{quality_msg}"

    # Build accuracy check results message
    accuracy_msg = ""
    if accuracy_checks:
        overall_confidence = accuracy_checks.get("overall_confidence", 0)
        verification_notes = accuracy_checks.get("verification_notes", [])
        individual_scores = accuracy_checks.get("individual_scores", {})

        # Overall confidence emoji
        if overall_confidence >= 0.9:
            conf_emoji = "üü¢"
            conf_text = "Excellent"
        elif overall_confidence >= 0.7:
            conf_emoji = "üü°"
            conf_text = "Good"
        else:
            conf_emoji = "üî¥"
            conf_text = "Low"

        accuracy_msg = f"\nüîç <b>Accuracy Verification:</b>\n"
        accuracy_msg += f"{conf_emoji} Overall Confidence: <b>{overall_confidence:.0%}</b> ({conf_text})\n"

        # Show individual check results
        if individual_scores:
            accuracy_msg += "\n<b>Accuracy Checks:</b>\n"
            for check_name, score in individual_scores.items():
                check_emoji = "‚úÖ" if score >= 0.8 else "‚úì" if score >= 0.6 else "‚ö†Ô∏è"
                display_name = check_name.replace("_", " ").title()
                accuracy_msg += f"{check_emoji} {display_name}: {score:.0%}\n"

        # Add verification notes if confidence is low
        if overall_confidence < 0.8 and verification_notes:
            accuracy_msg += "\n<b>Verification Notes:</b>\n"
            for note in verification_notes[:3]:  # Show top 3 notes
                accuracy_msg += f"‚Ä¢ {note}\n"

    # Mark values as edited if they've been changed
    edited_fields = context.chat_data.get("ggshot_edited_fields", set())

    # Build confirmation message based on detected strategy
    if strategy_type == "conservative":
        confirmation_msg = (
            f"ü§ñ <b>AI ANALYSIS COMPLETE</b> üì∏\n"
            f"{'‚ïê' * 25}\n\n"
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Detected Strategy:</b> üõ°Ô∏è Conservative Limits\n"
            f"‚úÖ <b>AI Confidence:</b> {confidence:.0%}\n"
            f"{quality_msg}"
            f"{accuracy_msg}\n"
            f"üìä <b>EXTRACTED VALUES:</b>\n\n"
            f"üîπ <b>Limit Orders:</b>\n"
            f"‚Ä¢ Entry #1: {format_value_with_edit_indicator(params.get(LIMIT_ENTRY_1_PRICE), 'limit_1', edited_fields)}\n"
            f"‚Ä¢ Entry #2: {format_value_with_edit_indicator(params.get(LIMIT_ENTRY_2_PRICE), 'limit_2', edited_fields)}\n"
            f"‚Ä¢ Entry #3: {format_value_with_edit_indicator(params.get(LIMIT_ENTRY_3_PRICE), 'limit_3', edited_fields)}\n\n"
            f"üéØ <b>Take Profits:</b>\n"
            f"‚Ä¢ TP1 (70%): {format_value_with_edit_indicator(params.get(TP1_PRICE), 'tp1', edited_fields)}\n"
            f"‚Ä¢ TP2 (10%): {format_value_with_edit_indicator(params.get(TP2_PRICE), 'tp2', edited_fields)}\n"
            f"‚Ä¢ TP3 (10%): {format_value_with_edit_indicator(params.get(TP3_PRICE), 'tp3', edited_fields)}\n"
            f"‚Ä¢ TP4 (10%): {format_value_with_edit_indicator(params.get(TP4_PRICE), 'tp4', edited_fields)}\n\n"
            f"üõ°Ô∏è <b>Stop Loss:</b> {format_value_with_edit_indicator(params.get(SL_PRICE), 'sl', edited_fields)}\n\n"
            f"üí° <i>Review values and edit if needed</i>\n"
        )
    else:
        confirmation_msg = (
            f"ü§ñ <b>AI ANALYSIS COMPLETE</b> üì∏\n"
            f"{'‚ïê' * 25}\n\n"
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Detected Strategy:</b> ‚ö° Fast Market\n"
            f"‚úÖ <b>AI Confidence:</b> {confidence:.0%}\n"
            f"{quality_msg}"
            f"{accuracy_msg}\n"
            f"üìä <b>EXTRACTED VALUES:</b>\n\n"
            f"üí∞ <b>Entry Price:</b> {format_value_with_edit_indicator(params.get(PRIMARY_ENTRY_PRICE), 'entry', edited_fields)}\n"
            f"üéØ <b>Take Profit:</b> {format_value_with_edit_indicator(params.get(TP1_PRICE), 'tp1', edited_fields)} (100%)\n"
            f"üõ°Ô∏è <b>Stop Loss:</b> {format_value_with_edit_indicator(params.get(SL_PRICE), 'sl', edited_fields)}\n\n"
            f"üí° <i>Review values and edit if needed</i>\n"
        )

    # Build edit interface keyboard
    keyboard_buttons = []

    # Add edit buttons based on strategy type
    if strategy_type == "conservative":
        # Check if any limits have been edited
        limits_edited = any(f"limit_{i}" in edited_fields for i in range(1, 4))
        limits_btn_text = "üìù Edit Limit Orders" if not limits_edited else "‚úèÔ∏è Edit Limit Orders (Modified)"

        # Check if any TPs have been edited
        tps_edited = any(f"tp{i}" in edited_fields for i in range(1, 5))
        tps_btn_text = "üéØ Edit Take Profits" if not tps_edited else "‚úèÔ∏è Edit Take Profits (Modified)"

        # Check if SL has been edited
        sl_btn_text = "üõ°Ô∏è Edit Stop Loss" if "sl" not in edited_fields else "‚úèÔ∏è Edit Stop Loss (Modified)"

        keyboard_buttons.extend([
            [InlineKeyboardButton(limits_btn_text, callback_data="ggshot_edit_limits")],
            [InlineKeyboardButton(tps_btn_text, callback_data="ggshot_edit_tps")],
            [InlineKeyboardButton(sl_btn_text, callback_data="ggshot_edit_sl")]
        ])
    else:
        # Check if values have been edited
        entry_btn_text = "üí∞ Edit Entry Price" if "entry" not in edited_fields else "‚úèÔ∏è Edit Entry Price (Modified)"
        tp_btn_text = "üéØ Edit Take Profit" if "tp1" not in edited_fields else "‚úèÔ∏è Edit Take Profit (Modified)"
        sl_btn_text = "üõ°Ô∏è Edit Stop Loss" if "sl" not in edited_fields else "‚úèÔ∏è Edit Stop Loss (Modified)"

        keyboard_buttons.extend([
            [InlineKeyboardButton(entry_btn_text, callback_data="ggshot_edit_entry")],
            [InlineKeyboardButton(tp_btn_text, callback_data="ggshot_edit_tp_fast")],
            [InlineKeyboardButton(sl_btn_text, callback_data="ggshot_edit_sl")]
        ])

    # Add main action buttons
    keyboard_buttons.extend([
        [InlineKeyboardButton("‚úÖ Confirm All Values", callback_data="ggshot_confirm_all")],
        [InlineKeyboardButton("‚úèÔ∏è Manual Override (Start Over)", callback_data="ggshot_manual_override")]
    ])

    # Add advanced enhancement option if image quality issues detected
    if quality_report and (quality_report.get("is_blurry") or quality_report.get("is_low_res")) and extraction_method != "aggressive processing":
        keyboard_buttons.append(
            [InlineKeyboardButton("üî¨ Try Advanced Enhancement", callback_data="ggshot_advanced_enhance")]
        )

    keyboard_buttons.extend([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    confirmation_keyboard = InlineKeyboardMarkup(keyboard_buttons)

    await edit_last_message(context, chat_id, confirmation_msg, confirmation_keyboard)
    return CONFIRMATION

async def handle_screenshot_analysis_failure(context: ContextTypes.DEFAULT_TYPE, chat_id: int, error_msg: str) -> int:
    """Handle AI analysis failure and offer alternatives"""
    # Escape HTML special characters in error message
    safe_error_msg = escape(error_msg) if error_msg else "Unknown error"

    failure_msg = (
        f"‚ùå <b>AI Analysis Failed</b>\n\n"
        f"Error: {safe_error_msg}\n\n"
        f"üîÑ <b>Options:</b>\n"
        f"‚Ä¢ Try uploading a clearer screenshot\n"
        f"‚Ä¢ Try advanced image enhancement\n"
        f"‚Ä¢ Switch to manual entry\n\n"
        f"What would you like to do?"
    )

    failure_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üì∏ Upload Again", callback_data="ggshot_retry_upload")],
        [InlineKeyboardButton("üî¨ Try Advanced Enhancement", callback_data="ggshot_advanced_enhance")],
        [InlineKeyboardButton("‚úèÔ∏è Manual Entry", callback_data="ggshot_manual_entry")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, failure_msg, failure_keyboard)
    return SCREENSHOT_UPLOAD

# =============================================
# GGSHOT CALLBACK HANDLERS
# =============================================

async def handle_ggshot_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle GGShot specific callback queries"""
    query = update.callback_query
    if not query:
        return CONFIRMATION

    try:
        await query.answer()
    except:
        pass

    # Handle new edit callbacks
    if query.data == "ggshot_edit_limits":
        # Start streamlined limit order flow
        return await start_ggshot_limit_flow(context, query.message.chat.id)

    elif query.data == "ggshot_edit_tps":
        # Start streamlined take profit flow
        return await start_ggshot_tp_flow(context, query.message.chat.id)

    elif query.data == "ggshot_edit_sl":
        # Show stop loss editing interface
        return await show_ggshot_edit_sl(context, query.message.chat.id)

    elif query.data == "ggshot_edit_entry":
        # Show entry price editing interface
        return await show_ggshot_edit_entry(context, query.message.chat.id)

    elif query.data == "ggshot_edit_tp_fast":
        # Show TP editing interface
        # Fast approach no longer supported - redirect to conservative
        return await show_ggshot_edit_tps(context, query.message.chat.id)

    elif query.data.startswith("ggshot_set_limit_"):
        # Handle setting a specific limit order price
        limit_num = query.data.split("_")[-1]
        return await handle_ggshot_set_limit(context, query.message.chat.id, limit_num)

    elif query.data.startswith("ggshot_set_tp_"):
        # Handle setting a specific TP price
        tp_num = query.data.split("_")[-1]
        return await handle_ggshot_set_tp(context, query.message.chat.id, tp_num)

    elif query.data == "ggshot_back_to_edit":
        # Return to the main edit screen
        return await show_extracted_parameters_confirmation(context, query.message.chat.id,
            {"success": True, "parameters": context.chat_data, "strategy_type": context.chat_data.get(ORDER_STRATEGY, "fast")})

    elif query.data == "ggshot_confirm_all":
        # User confirmed all edited values - now ask which approach to use
        return await handle_ggshot_confirm_all(context, query.message.chat.id)

    elif query.data == "ggshot_confirm_ai":
        # User confirmed AI extracted parameters - now ask which approach to use
        symbol = context.chat_data.get(SYMBOL, "Unknown")
        side = context.chat_data.get(SIDE, "Buy")
        direction_emoji = "üìà" if side == "Buy" else "üìâ"
        direction_text = "LONG" if side == "Buy" else "SHORT"

        # Show approach selection
        approach_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>AI Prices:</b> üì∏ Extracted Successfully\n\n"
            f"üéØ <b>Choose Trading Approach</b>\n\n"
            f"Select how you want to execute this trade:\n\n"
            f"‚ö° <b>Fast Only</b>\n"
            f"‚Ä¢ Market order execution\n"
            f"‚Ä¢ Single TP (100%) + SL\n"
            f"‚Ä¢ Quick in/out trades\n\n"
            f"üõ°Ô∏è <b>Conservative Only</b>\n"
            f"‚Ä¢ 3 limit order entries\n"
            f"‚Ä¢ 4 TPs (70%/10%/10%/10%)\n"
            f"‚Ä¢ Gradual scaling strategy\n\n"
            f"‚ö°+üõ°Ô∏è <b>Both Approaches</b>\n"
            f"‚Ä¢ Opens 2 separate positions\n"
            f"‚Ä¢ Split margin between both\n"
            f"‚Ä¢ Best of both strategies"
        )

        approach_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ö° Fast Only", callback_data="ggshot_approach:fast")],
            [InlineKeyboardButton("üõ°Ô∏è Conservative Only", callback_data="ggshot_approach:conservative")],
            [InlineKeyboardButton("‚ö°+üõ°Ô∏è Both Approaches", callback_data="ggshot_approach:both")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SCREENSHOT_UPLOAD}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
        ])

        await edit_last_message(context, query.message.chat.id, approach_msg, approach_keyboard)
        return CONFIRMATION

    elif query.data == "ggshot_manual_override":
        # User wants to manually override AI parameters
        approach = context.chat_data.get(TRADING_APPROACH, "fast")

        # Always use conservative approach flow
        return await ask_for_conservative_take_profits(context, query.message.chat.id)

    elif query.data == "ggshot_retry_upload":
        # User wants to upload a new screenshot
        return await retry_screenshot_upload(context, query.message.chat.id)

    elif query.data == "ggshot_manual_entry":
        # User wants to switch to manual entry - ask which approach
        return await offer_manual_approach_selection(context, query.message.chat.id)

    elif query.data == "ggshot_advanced_enhance":
        # User wants to try advanced enhancement
        return await handle_advanced_enhancement_request(context, query.message.chat.id)

    elif query.data.startswith("ggshot_approach:"):
        # Handle approach selection after GGShot extraction
        selected_approach = query.data.split(":")[1]

        if selected_approach == "both":
            # Both approaches no longer supported - use conservative
            context.chat_data[TRADING_APPROACH] = "conservative"
            context.chat_data[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY
        else:
            # Single approach selected
            context.chat_data["ggshot_both_trades"] = False
            context.chat_data[TRADING_APPROACH] = selected_approach
            if selected_approach == "conservative":
                context.chat_data[ORDER_STRATEGY] = STRATEGY_CONSERVATIVE_LIMITS
                # Generate trade group ID for conservative approach
                trade_group_id = str(uuid.uuid4())[:8]
                context.chat_data[CONSERVATIVE_TRADE_GROUP_ID] = trade_group_id
                try:
                    protect_trade_group_from_cleanup(trade_group_id)
                except Exception as e:
                    logger.error(f"Error protecting trade group: {e}")
            else:
                context.chat_data[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY

        # Now move to leverage selection
        symbol = context.chat_data.get(SYMBOL, "Unknown")
        side = context.chat_data.get(SIDE, "Buy")
        direction_emoji = "üìà" if side == "Buy" else "üìâ"
        direction_text = "LONG" if side == "Buy" else "SHORT"
        approach_emoji = "‚ö°" if selected_approach == "fast" else "üõ°Ô∏è" if selected_approach == "conservative" else "‚ö°+üõ°Ô∏è"
        approach_text = "Fast Market" if selected_approach == "fast" else "Conservative Limits" if selected_approach == "conservative" else "Both Approaches"

        # Get max leverage and show leverage selection
        max_leverage = context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100)

        leverage_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"‚úÖ <b>AI Prices:</b> üì∏ Extracted\n\n"
            f"‚ö° <b>Step 5 of 7: Select Leverage</b>\n\n"
            f"Choose your leverage for this trade:\n"
            f"üí° Higher leverage = higher risk & reward\n"
            f"üõ°Ô∏è Maximum for {symbol}: {max_leverage}x"
        )

        if selected_approach == "both":
            leverage_msg += "\n\nüìä <i>This leverage will apply to both trades</i>"

        from dashboard.keyboards_analytics import build_leverage_selection_keyboard
        leverage_keyboard = build_leverage_selection_keyboard(max_leverage)

        await edit_last_message(context, query.message.chat.id, leverage_msg, leverage_keyboard)
        return LEVERAGE

    elif query.data.startswith("ggshot_limit_back:"):
        # Handle back navigation in limit flow
        limit_num = int(query.data.split(":")[1])
        if limit_num == 1:
            # Going back to limit 1
            context.chat_data["ggshot_current_limit"] = 1
            context.chat_data["ggshot_limit_flow_expecting"] = "limit_1"
            return await start_ggshot_limit_flow(context, query.message.chat.id)
        elif limit_num == 2:
            # Going back to limit 2 from limit 3
            context.chat_data["ggshot_current_limit"] = 2
            context.chat_data["ggshot_limit_flow_expecting"] = "limit_2"

            limit_msg = (
                f"üìä <b>Edit Limit Orders - Streamlined Flow</b>\n"
                f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
                f"‚úÖ Limit 1: <code>{format_price(context.chat_data.get(LIMIT_ENTRY_1_PRICE))}</code>\n\n"
                f"üéØ <b>Limit Order 2 of 3</b>\n\n"
            )

            current_limit_2 = context.chat_data.get(LIMIT_ENTRY_2_PRICE, None)
            if current_limit_2:
                limit_msg += f"Current value: <code>{format_price(current_limit_2)}</code>\n\n"

            limit_msg += (
                f"Enter the price for <b>Limit Order 2</b>:\n"
                f"üí° This will be your second entry point"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back to Limit 1", callback_data="ggshot_limit_back:1")],
                [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
            ])

            await edit_last_message(context, query.message.chat.id, limit_msg, keyboard)
            return GGSHOT_LIMIT_FLOW_2

    elif query.data.startswith("ggshot_tp_back:"):
        # Handle back navigation in TP flow
        tp_num = int(query.data.split(":")[1])
        if tp_num == 1:
            # Going back to TP1
            context.chat_data["ggshot_current_tp"] = 1
            context.chat_data["ggshot_tp_flow_expecting"] = "tp_1"
            return await start_ggshot_tp_flow(context, query.message.chat.id)
        elif tp_num == 2:
            # Going back to TP2 from TP3
            context.chat_data["ggshot_current_tp"] = 2
            context.chat_data["ggshot_tp_flow_expecting"] = "tp_2"

            tp_msg = (
                f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
                f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
                f"‚úÖ TP1 (85%): <code>{format_price(context.chat_data.get(TP1_PRICE))}</code>\n\n"
                f"üéØ <b>Take Profit 2 of 4 (5%)</b>\n\n"
            )

            current_tp_2 = context.chat_data.get(TP2_PRICE, None)
            if current_tp_2:
                tp_msg += f"Current value: <code>{format_price(current_tp_2)}</code>\n\n"

            tp_msg += (
                f"Enter the price for <b>TP2 (5% of position)</b>:\n"
                f"üí° This is your second profit target"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP1", callback_data="ggshot_tp_back:1")],
                [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
            ])

            await edit_last_message(context, query.message.chat.id, tp_msg, keyboard)
            return GGSHOT_TP_FLOW_2
        elif tp_num == 3:
            # Going back to TP3 from TP4
            context.chat_data["ggshot_current_tp"] = 3
            context.chat_data["ggshot_tp_flow_expecting"] = "tp_3"

            tp_msg = (
                f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
                f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
                f"‚úÖ TP1 (85%): <code>{format_price(context.chat_data.get(TP1_PRICE))}</code>\n"
                f"‚úÖ TP2 (5%): <code>{format_price(context.chat_data.get(TP2_PRICE))}</code>\n\n"
                f"üéØ <b>Take Profit 3 of 4 (5%)</b>\n\n"
            )

            current_tp_3 = context.chat_data.get(TP3_PRICE, None)
            if current_tp_3:
                tp_msg += f"Current value: <code>{format_price(current_tp_3)}</code>\n\n"

            tp_msg += (
                f"Enter the price for <b>TP3 (5% of position)</b>:\n"
                f"üí° This is your third profit target"
            )

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP2", callback_data="ggshot_tp_back:2")],
                [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
            ])

            await edit_last_message(context, query.message.chat.id, tp_msg, keyboard)
            return GGSHOT_TP_FLOW_3

    elif query.data == "ggshot_override_validation":
        # User wants to override validation errors and continue
        symbol = context.chat_data.get(SYMBOL, "Unknown")
        side = context.chat_data.get(SIDE, "Buy")
        direction_emoji = "üìà" if side == "Buy" else "üìâ"
        direction_text = "LONG" if side == "Buy" else "SHORT"
        approach = context.chat_data.get(TRADING_APPROACH, "fast")
        approach_emoji = "‚ö°" if approach == "fast" else "üõ°Ô∏è"
        approach_text = "Fast Market" if approach == "fast" else "Conservative Limits"

        # Get max leverage and show leverage selection
        max_leverage = context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100)

        override_msg = (
            f"‚ö†Ô∏è <b>VALIDATION OVERRIDE</b>\n\n"
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"‚ö†Ô∏è <b>AI Prices:</b> üì∏ Extracted (Unvalidated)\n\n"
            f"‚ö° <b>Step 5 of 7: Select Leverage</b>\n\n"
            f"Choose your leverage for this trade:\n"
            f"üí° Higher leverage = higher risk & reward\n"
            f"üõ°Ô∏è Maximum for {symbol}: {max_leverage}x\n\n"
            f"üö® <b>WARNING:</b> Proceeding with unvalidated parameters!"
        )

        from dashboard.keyboards_analytics import build_leverage_selection_keyboard
        leverage_keyboard = build_leverage_selection_keyboard(max_leverage)

        await edit_last_message(context, query.message.chat.id, override_msg, leverage_keyboard)
        return LEVERAGE

    return CONFIRMATION

async def retry_screenshot_upload(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Allow user to retry screenshot upload"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    retry_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
        f"‚úÖ <b>Approach:</b> üì∏ GGShot Screenshot\n\n"
        f"üì∏ <b>Upload New Screenshot</b>\n\n"
        f"üìã <b>Tips for better analysis:</b>\n"
        f"‚Ä¢ Clear, high-resolution image\n"
        f"‚Ä¢ All price levels visible\n"
        f"‚Ä¢ Good contrast and lighting\n"
        f"‚Ä¢ Minimal clutter around trade setup\n\n"
        f"üì§ <b>Send your screenshot now...</b>"
    )

    cancel_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
        [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, retry_msg, cancel_keyboard)
    return SCREENSHOT_UPLOAD

async def offer_manual_approach_selection(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Offer manual approach selection after GGShot failure"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    manual_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n\n"
        f"‚úèÔ∏è <b>Manual Entry Mode</b>\n\n"
        f"Choose your manual trading approach:\n\n"
        f"‚ö° <b>Fast Market</b>\n"
        f"‚Ä¢ Single entry + single TP\n"
        f"‚Ä¢ Quick setup\n\n"
        f"üõ°Ô∏è <b>Conservative Limits</b>\n"
        f"‚Ä¢ 3 limit orders + 4 TPs\n"
        f"‚Ä¢ Advanced risk management\n\n"
        f"Select your preferred approach:"
    )

    manual_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"‚ö° Fast Market", callback_data="conv_approach:fast")],
        [InlineKeyboardButton(f"üõ°Ô∏è Conservative Limits", callback_data="conv_approach:conservative")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, manual_msg, manual_keyboard)
    return MARGIN

async def handle_advanced_enhancement_request(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Handle request for advanced image enhancement"""
    # Check if we have a stored screenshot
    screenshot_path = context.chat_data.get("screenshot_file_path")
    if not screenshot_path:
        await edit_last_message(
            context, chat_id,
            "‚ùå <b>No screenshot found</b>\n\nPlease upload a new screenshot:",
            None
        )
        return await retry_screenshot_upload(context, chat_id)

    # Show processing message
    await edit_last_message(
        context, chat_id,
        f"{get_emoji('loading')} <b>Advanced Image Enhancement</b>\n\n"
        f"üî¨ Applying advanced enhancement algorithms...\n"
        f"üìä Optimizing for OCR accuracy...\n"
        f"ü§ñ Re-analyzing with enhanced image...\n"
        f"‚è≥ This may take 5-10 seconds...",
        None
    )

    try:
        # Update analyzer to use advanced enhancement
        from utils.screenshot_analyzer import screenshot_analyzer
        original_level = screenshot_analyzer.enhancement_level
        screenshot_analyzer.enhancement_level = "advanced"

        symbol = context.chat_data.get(SYMBOL, "BTCUSDT")
        side = context.chat_data.get(SIDE, "Buy")

        # Re-analyze with advanced enhancement
        extracted_data = await screenshot_analyzer.analyze_trading_screenshot(
            screenshot_path, symbol, side
        )

        # Restore original enhancement level
        screenshot_analyzer.enhancement_level = original_level

        if extracted_data.get("success"):
            # Store extracted parameters
            context.chat_data.update(extracted_data["parameters"])

            # Show extracted parameters for confirmation
            return await show_extracted_parameters_confirmation(context, chat_id, extracted_data)
        else:
            # Advanced enhancement still failed
            enhanced_error_msg = (
                f"‚ùå <b>Advanced Analysis Failed</b>\n\n"
                f"Even with advanced enhancement, we couldn't extract the parameters.\n\n"
                f"<b>Possible reasons:</b>\n"
                f"‚Ä¢ Image quality is too poor\n"
                f"‚Ä¢ Price levels not clearly visible\n"
                f"‚Ä¢ Screenshot doesn't show trading setup\n\n"
                f"<b>Recommendations:</b>\n"
                f"‚Ä¢ Take a clearer screenshot\n"
                f"‚Ä¢ Ensure all price levels are visible\n"
                f"‚Ä¢ Use manual entry instead"
            )

            enhanced_failure_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üì∏ Upload New Screenshot", callback_data="ggshot_retry_upload")],
                [InlineKeyboardButton("‚úèÔ∏è Manual Entry", callback_data="ggshot_manual_entry")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
                [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
            ])

            await edit_last_message(context, chat_id, enhanced_error_msg, enhanced_failure_keyboard)
            return SCREENSHOT_UPLOAD

    except Exception as e:
        logger.error(f"Error in advanced enhancement: {e}")
        return await handle_screenshot_analysis_failure(
            context, chat_id,
            f"Advanced enhancement error: {escape(str(e))}"
        )

# =============================================
# PRIMARY ENTRY HANDLER (Fast Approach)
# =============================================

async def primary_entry_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle primary entry price input for fast approach"""
    if not update.message or not update.message.text:
        return PRIMARY_ENTRY

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        price = Decimal(update.message.text.strip())
        if price <= 0:
            await send_error_and_retry(
                context, chat_id,
                "Entry price must be greater than 0. Please enter a valid price:",
                PRIMARY_ENTRY
            )
            return PRIMARY_ENTRY

        # Store primary entry with multiple key formats
        context.chat_data["primary_entry_price"] = price
        context.chat_data[PRIMARY_ENTRY_PRICE] = price
        context.chat_data["PRIMARY_ENTRY_PRICE"] = price  # Backup

        # Ask for SINGLE take profit (100% close) for fast approach
        # Fast approach no longer supported - use conservative
        return await ask_for_conservative_take_profits(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for the entry price:",
            PRIMARY_ENTRY
        )
        return PRIMARY_ENTRY

# =============================================
# ENHANCED: LIMIT ENTRIES HANDLER (Conservative Approach)
# =============================================

async def limit_entries_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle limit order price inputs for conservative approach"""
    if not update.message or not update.message.text:
        return LIMIT_ENTRIES

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        price = Decimal(update.message.text.strip())
        if price <= 0:
            await send_error_and_retry(
                context, chat_id,
                "Limit price must be greater than 0. Please enter a valid price:",
                LIMIT_ENTRIES
            )
            return LIMIT_ENTRIES

        # Track which limit order we're entering
        orders_entered = context.chat_data.get("limit_orders_entered", 0)

        if orders_entered == 0:
            context.chat_data[LIMIT_ENTRY_1_PRICE] = price
            context.chat_data["limit_orders_entered"] = 1

            # Ask for second limit order
            symbol = context.chat_data.get(SYMBOL, "Unknown")
            side = context.chat_data.get(SIDE, "Buy")
            trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
            direction_emoji = "üìà" if side == "Buy" else "üìâ"
            direction_text = "LONG" if side == "Buy" else "SHORT"

            limit2_msg = (
                f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
                f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
                f"‚úÖ <b>Approach:</b> üõ°Ô∏è Conservative Limits\n"
                f"‚úÖ <b>Trade Group:</b> {trade_group_id} üõ°Ô∏è\n"
                f"‚úÖ <b>Limit #1:</b> <code>{format_price(price)}</code>\n\n"
                f"üìä <b>Step 4 of 7: Limit Order Prices</b>\n\n"
                f"Enter <b>Limit Order #2</b> price:"
            )

            cancel_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
                [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
            ])

            await edit_last_message(context, chat_id, limit2_msg, cancel_keyboard)
            return LIMIT_ENTRIES

        elif orders_entered == 1:
            context.chat_data[LIMIT_ENTRY_2_PRICE] = price
            context.chat_data["limit_orders_entered"] = 2

            # Ask for third limit order
            symbol = context.chat_data.get(SYMBOL, "Unknown")
            side = context.chat_data.get(SIDE, "Buy")
            trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
            direction_emoji = "üìà" if side == "Buy" else "üìâ"
            direction_text = "LONG" if side == "Buy" else "SHORT"
            limit1_price = context.chat_data.get(LIMIT_ENTRY_1_PRICE)

            limit3_msg = (
                f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
                f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
                f"‚úÖ <b>Approach:</b> üõ°Ô∏è Conservative Limits\n"
                f"‚úÖ <b>Trade Group:</b> {trade_group_id} üõ°Ô∏è\n"
                f"‚úÖ <b>Limit #1:</b> <code>{format_price(limit1_price)}</code>\n"
                f"‚úÖ <b>Limit #2:</b> <code>{format_price(price)}</code>\n\n"
                f"üìä <b>Step 4 of 7: Limit Order Prices</b>\n\n"
                f"Enter <b>Limit Order #3</b> price:"
            )

            cancel_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
                [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
            ])

            await edit_last_message(context, chat_id, limit3_msg, cancel_keyboard)
            return LIMIT_ENTRIES

        elif orders_entered == 2:
            context.chat_data[LIMIT_ENTRY_3_PRICE] = price
            context.chat_data["limit_orders_entered"] = 3

            # All 3 limit orders entered, move to take profits
            return await ask_for_conservative_take_profits(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for the limit price:",
            LIMIT_ENTRIES
        )
        return LIMIT_ENTRIES

# =============================================
# TAKE PROFITS HANDLER - ENHANCED FOR DUAL APPROACHES
# =============================================

# Fast approach function removed - only conservative approach supported

async def ask_for_conservative_take_profits(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Ask for 4 take profit prices in conservative approach"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    limit1_price = context.chat_data.get(LIMIT_ENTRY_1_PRICE)
    limit2_price = context.chat_data.get(LIMIT_ENTRY_2_PRICE)
    limit3_price = context.chat_data.get(LIMIT_ENTRY_3_PRICE)

    tp_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
        f"‚úÖ <b>Approach:</b> üõ°Ô∏è Conservative Limits\n"
        f"‚úÖ <b>Trade Group:</b> {trade_group_id} üõ°Ô∏è\n"
        f"‚úÖ <b>Limits:</b> {format_price(limit1_price)}, {format_price(limit2_price)}, {format_price(limit3_price)}\n\n"
        f"üéØ <b>Step 5 of 7: Take Profit Prices</b>\n\n"
        f"Enter 4 take profit prices (one per message):\n"
        f"üí° TP1: 70% | TP2: 10% | TP3: 10% | TP4: 10%\n"
        f"üõ°Ô∏è All orders will be protected from cleanup\n\n"
        f"Enter <b>Take Profit #1</b> price (70% close):"
    )

    cancel_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
    ])

    # Initialize TP tracking
    context.chat_data["take_profits_entered"] = 0

    await edit_last_message(context, chat_id, tp_msg, cancel_keyboard)
    return TAKE_PROFITS

async def take_profits_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle take profit input for both approaches"""
    if not update.message or not update.message.text:
        return TAKE_PROFITS

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        price = Decimal(update.message.text.strip())
        if price <= 0:
            await send_error_and_retry(
                context, chat_id,
                "Take profit price must be greater than 0. Please enter a valid price:",
                TAKE_PROFITS
            )
            return TAKE_PROFITS

        approach = context.chat_data.get(TRADING_APPROACH, "fast")

        if approach == "fast":
            # Fast approach - single TP
            context.chat_data["tp1_price"] = price
            context.chat_data[TP1_PRICE] = price
            context.chat_data["TP1_PRICE"] = price  # Backup

            # Go directly to stop loss
            return await ask_for_stop_loss(context, chat_id)

        else:  # conservative approach
            # Conservative approach - 4 TPs
            tps_entered = context.chat_data.get("take_profits_entered", 0)

            if tps_entered == 0:
                context.chat_data[TP1_PRICE] = price
                context.chat_data["take_profits_entered"] = 1

                # Ask for TP2
                tp2_msg = (
                    f"‚úÖ <b>TP1 (70%):</b> <code>{format_price(price)}</code> üõ°Ô∏è\n\n"
                    f"üéØ <b>Step 5 of 7: Take Profit Prices</b>\n\n"
                    f"Enter <b>Take Profit #2</b> price (10% close):"
                )

                cancel_keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
                ])

                await edit_last_message(context, chat_id, tp2_msg, cancel_keyboard)
                return TAKE_PROFITS

            elif tps_entered == 1:
                context.chat_data[TP2_PRICE] = price
                context.chat_data["take_profits_entered"] = 2

                # Ask for TP3
                tp1_price = context.chat_data.get(TP1_PRICE)
                tp3_msg = (
                    f"‚úÖ <b>TP1 (70%):</b> <code>{format_price(tp1_price)}</code> üõ°Ô∏è\n"
                    f"‚úÖ <b>TP2 (10%):</b> <code>{format_price(price)}</code> üõ°Ô∏è\n\n"
                    f"üéØ <b>Step 5 of 7: Take Profit Prices</b>\n\n"
                    f"Enter <b>Take Profit #3</b> price (10% close):"
                )

                cancel_keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
                ])

                await edit_last_message(context, chat_id, tp3_msg, cancel_keyboard)
                return TAKE_PROFITS

            elif tps_entered == 2:
                context.chat_data[TP3_PRICE] = price
                context.chat_data["take_profits_entered"] = 3

                # Ask for TP4
                tp1_price = context.chat_data.get(TP1_PRICE)
                tp2_price = context.chat_data.get(TP2_PRICE)
                tp4_msg = (
                    f"‚úÖ <b>TP1 (70%):</b> <code>{format_price(tp1_price)}</code> üõ°Ô∏è\n"
                    f"‚úÖ <b>TP2 (10%):</b> <code>{format_price(tp2_price)}</code> üõ°Ô∏è\n"
                    f"‚úÖ <b>TP3 (10%):</b> <code>{format_price(price)}</code> üõ°Ô∏è\n\n"
                    f"üéØ <b>Step 5 of 7: Take Profit Prices</b>\n\n"
                    f"Enter <b>Take Profit #4</b> price (10% close):"
                )

                cancel_keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
                ])

                await edit_last_message(context, chat_id, tp4_msg, cancel_keyboard)
                return TAKE_PROFITS

            elif tps_entered == 3:
                context.chat_data[TP4_PRICE] = price
                context.chat_data["take_profits_entered"] = 4

                # All 4 TPs entered, move to stop loss
                return await ask_for_stop_loss(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for the take profit price:",
            TAKE_PROFITS
        )
        return TAKE_PROFITS

# =============================================
# STOP LOSS HANDLER - ENHANCED
# =============================================

async def ask_for_stop_loss(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Ask for stop loss - enhanced for dual approaches"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    approach = context.chat_data.get(TRADING_APPROACH, "fast")

    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"
    approach_emoji = "‚ö°" if approach == "fast" else "üõ°Ô∏è"
    approach_text = "Fast Market" if approach == "fast" else "Conservative Limits"

    # Build summary based on approach
    if approach == "fast":
        entry_price = context.chat_data.get(PRIMARY_ENTRY_PRICE, Decimal("0"))
        tp_price = context.chat_data.get(TP1_PRICE, Decimal("0"))

        sl_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"‚úÖ <b>Entry Price:</b> <code>{format_price(entry_price)}</code>\n"
            f"‚úÖ <b>Take Profit:</b> <code>{format_price(tp_price)}</code> üõ°Ô∏è\n\n"
            f"üõ°Ô∏è <b>Step 6 of 7: Stop Loss</b>\n\n"
            f"Enter your stop loss price:\n"
            f"üí° This protects you from large losses\n"
            f"üõ°Ô∏è Order will be protected from cleanup"
        )
    else:
        # Conservative approach summary
        trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
        limit1_price = context.chat_data.get(LIMIT_ENTRY_1_PRICE)
        limit2_price = context.chat_data.get(LIMIT_ENTRY_2_PRICE)
        limit3_price = context.chat_data.get(LIMIT_ENTRY_3_PRICE)
        tp1_price = context.chat_data.get(TP1_PRICE)
        tp2_price = context.chat_data.get(TP2_PRICE)
        tp3_price = context.chat_data.get(TP3_PRICE)
        tp4_price = context.chat_data.get(TP4_PRICE)

        sl_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚úÖ <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"‚úÖ <b>Trade Group:</b> {trade_group_id} üõ°Ô∏è\n"
            f"‚úÖ <b>Limits:</b> {format_price(limit1_price)}, {format_price(limit2_price)}, {format_price(limit3_price)}\n"
            f"‚úÖ <b>TPs:</b> {format_price(tp1_price)}, {format_price(tp2_price)}, {format_price(tp3_price)}, {format_price(tp4_price)} üõ°Ô∏è\n\n"
            f"üõ°Ô∏è <b>Step 6 of 7: Stop Loss</b>\n\n"
            f"Enter your stop loss price:\n"
            f"üí° This will cancel all remaining orders if hit\n"
            f"üõ°Ô∏è All orders protected from cleanup"
        )

    cancel_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, sl_msg, cancel_keyboard)
    return STOP_LOSS

async def stop_loss_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle stop loss price input"""
    if not update.message or not update.message.text:
        return STOP_LOSS

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        price = Decimal(update.message.text.strip())
        if price <= 0:
            await send_error_and_retry(
                context, chat_id,
                "Stop loss price must be greater than 0. Please enter a valid price:",
                STOP_LOSS
            )
            return STOP_LOSS

        # Store SL with multiple key formats
        context.chat_data["sl_price"] = price
        context.chat_data[SL_PRICE] = price
        context.chat_data["SL_PRICE"] = price  # Backup

        # Move to leverage selection
        return await ask_for_leverage_with_buttons(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for the stop loss price:",
            STOP_LOSS
        )
        return STOP_LOSS

# =============================================
# LEVERAGE SELECTION - UNCHANGED
# =============================================

async def ask_for_leverage_with_buttons(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Ask for leverage with quick selection buttons"""
    max_lev = int(context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100))

    leverage_msg = (
        f"üõ°Ô∏è <b>Stop Loss Set!</b>\n\n"
        f"‚ö° <b>Step 7a: Select Leverage</b>\n\n"
        f"Choose your leverage (max {max_lev}x):\n"
        f"üí° Select a quick option or choose Custom for your own value"
    )

    # Build leverage selection keyboard with common options
    common_leverages = [5, 10, 20, 50]
    keyboard = []

    # Add common leverage buttons (2 per row)
    for i in range(0, len(common_leverages), 2):
        row = []
        for j in range(2):
            if i + j < len(common_leverages):
                lev = common_leverages[i + j]
                if lev <= max_lev:
                    row.append(InlineKeyboardButton(f"{lev}x", callback_data=f"conv_leverage:{lev}"))
        if row:
            keyboard.append(row)

    # Add custom and cancel buttons
    keyboard.append([
        InlineKeyboardButton(f"‚úèÔ∏è Custom", callback_data="conv_leverage:custom"),
        InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")
    ])

    leverage_keyboard = InlineKeyboardMarkup(keyboard)

    await edit_last_message(context, chat_id, leverage_msg, leverage_keyboard)
    return LEVERAGE

async def handle_leverage_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle leverage selection callback"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    if not query.data.startswith("conv_leverage:"):
        return LEVERAGE

    leverage_value = query.data.split(":")[1]

    if leverage_value == "custom":
        # Show custom leverage input
        max_lev = int(context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100))

        custom_leverage_msg = (
            f"‚ö° <b>Custom Leverage</b>\n\n"
            f"Enter your custom leverage (1-{max_lev}):\n"
            f"üí° Example: 15"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                custom_leverage_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for custom leverage: {e}")

        return LEVERAGE  # Stay in LEVERAGE state for text input
    else:
        # Handle quick selection
        try:
            leverage = int(leverage_value)
            max_lev = int(context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100))

            if leverage < 1 or leverage > max_lev:
                await query.answer(f"‚ùå Invalid leverage. Must be 1-{max_lev}", show_alert=True)
                return LEVERAGE

            # Store leverage with multiple key formats
            context.chat_data["leverage"] = leverage
            context.chat_data[LEVERAGE] = leverage
            context.chat_data["LEVERAGE"] = leverage

            logger.info(f"Quick leverage selected: {leverage}")

            # Move to margin selection with buttons
            return await ask_for_margin_with_buttons(context, query.message.chat.id, query)

        except ValueError:
            await query.answer("‚ùå Invalid leverage value", show_alert=True)
            return LEVERAGE

async def leverage_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle custom leverage text input"""
    if not update.message or not update.message.text:
        return LEVERAGE

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        leverage = int(update.message.text.strip())
        max_lev = int(context.chat_data.get(MAX_LEVERAGE_FOR_SYMBOL, 100))

        if leverage < 1 or leverage > max_lev:
            await send_error_and_retry(
                context, chat_id,
                f"Leverage must be between 1 and {max_lev}. Please enter a valid leverage:",
                LEVERAGE
            )
            return LEVERAGE

        # Store leverage with multiple key formats
        context.chat_data["leverage"] = leverage
        context.chat_data[LEVERAGE] = leverage
        context.chat_data["LEVERAGE"] = leverage

        logger.info(f"Custom leverage entered: {leverage}")

        # Move to margin selection with buttons
        return await ask_for_margin_with_buttons(context, chat_id)

    except ValueError:
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid whole number for leverage:",
            LEVERAGE
        )
        return LEVERAGE

# =============================================
# MARGIN SELECTION - UNCHANGED
# =============================================

async def ask_for_margin_with_buttons(context: ContextTypes.DEFAULT_TYPE, chat_id: int, query: CallbackQuery = None) -> int:
    """Ask for margin with quick selection buttons - NOW USING PERCENTAGE OF ACCOUNT"""
    leverage = context.chat_data.get(LEVERAGE, 10)

    # Get current account balance for percentage calculation
    from utils.cache import get_usdt_wallet_balance_cached
    try:
        total_balance, available_balance = await get_usdt_wallet_balance_cached()
        balance_display = f"Available Balance: ${format_decimal_or_na(available_balance, 2)}"
    except:
        available_balance = Decimal("0")
        balance_display = "Unable to fetch balance"

    # Check if we're doing both approaches (GGShot dual trade)
    both_trades = context.chat_data.get("ggshot_both_trades", False)

    # If both trades selected, route to MARGIN for separate margin selection
    if both_trades:
        return await ask_for_margin_fast(context, chat_id, query)

    # Standard single margin selection
    margin_msg = (
        f"‚ö° <b>Leverage Set: {leverage}x</b>\n"
        f"üí∞ <b>{balance_display}</b>\n\n"
        f"üìä <b>Step 7b: Select Margin Percentage</b>\n\n"
        f"Choose what percentage of your account to use:\n"
        f"üí° Select a quick option or choose Custom for your own percentage"
    )

    # Build margin selection keyboard with percentage options
    common_percentages = [1, 2, 5, 10]  # Percentage values
    keyboard = []

    # Add common percentage buttons (2 per row)
    for i in range(0, len(common_percentages), 2):
        row = []
        for j in range(2):
            if i + j < len(common_percentages):
                percentage = common_percentages[i + j]
                # Calculate USDT amount for display
                if available_balance > 0:
                    usdt_amount = (available_balance * Decimal(str(percentage))) / 100
                    button_text = f"{percentage}% (‚âà${format_decimal_or_na(usdt_amount, 2)})"
                else:
                    button_text = f"{percentage}%"
                row.append(InlineKeyboardButton(button_text, callback_data=f"conv_margin_pct:{percentage}"))
        if row:
            keyboard.append(row)

    # Add custom, back, and cancel buttons
    keyboard.append([
        InlineKeyboardButton(f"‚úèÔ∏è Custom %", callback_data="conv_margin_pct:custom")
    ])
    keyboard.append([
        InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{LEVERAGE}"),
        InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")
    ])

    margin_keyboard = InlineKeyboardMarkup(keyboard)

    if query:
        # Edit existing message if we have a query
        try:
            await query.edit_message_text(
                margin_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=margin_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for margin selection: {e}")
    else:
        # Send new message
        await edit_last_message(context, chat_id, margin_msg, margin_keyboard)

    return MARGIN

async def handle_margin_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle margin selection callback - NOW HANDLES PERCENTAGE"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    # Handle both old and new callback formats
    if query.data.startswith("conv_margin_pct:"):
        # New percentage-based callback
        value = query.data.split(":")[1]

        if value == "custom":
            # Show custom percentage input
            custom_margin_msg = (
                f"üìä <b>Custom Margin Percentage</b>\n\n"
                f"Enter your custom percentage (without % sign):\n"
                f"üí° Example: 3.5 (for 3.5% of account)\n"
                f"‚ö†Ô∏è Maximum: 100%"
            )

            cancel_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{LEVERAGE}")],
                [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
            ])

            try:
                await query.edit_message_text(
                    custom_margin_msg,
                    parse_mode=ParseMode.HTML,
                    reply_markup=cancel_keyboard
                )
            except Exception as e:
                logger.error(f"Error editing message for custom margin percentage: {e}")

            # Set flag to indicate we're expecting percentage input
            context.chat_data["expecting_percentage_input"] = True
            return MARGIN
        else:
            # Handle quick percentage selection
            try:
                percentage = Decimal(value)

                if percentage <= 0 or percentage > 100:
                    await query.answer("‚ùå Percentage must be between 0 and 100", show_alert=True)
                    return MARGIN

                # Get account balance to calculate USDT amount
                from utils.cache import get_usdt_wallet_balance_cached
                try:
                    total_balance, available_balance = await get_usdt_wallet_balance_cached()
                except:
                    await query.answer("‚ùå Unable to fetch account balance", show_alert=True)
                    return MARGIN

                # Calculate USDT amount from percentage
                margin_usdt = (available_balance * percentage) / 100

                # Store margin with multiple key formats
                context.chat_data["margin_amount_usdt"] = margin_usdt
                context.chat_data["margin_amount"] = margin_usdt
                context.chat_data[MARGIN_AMOUNT] = margin_usdt
                context.chat_data["MARGIN_AMOUNT"] = margin_usdt
                context.chat_data["margin_percentage"] = percentage  # Store percentage for reference

                logger.info(f"Margin selected: {percentage}% = {margin_usdt} USDT")

                # Show final confirmation
                return await show_final_confirmation(context, query.message.chat.id)

            except (ValueError, InvalidOperation):
                await query.answer("‚ùå Invalid percentage value", show_alert=True)
                return MARGIN

    elif query.data.startswith("conv_margin:"):
        # Handle old USDT-based callbacks (backwards compatibility)
        margin_value = query.data.split(":")[1]

        if margin_value == "custom":
            # Show custom margin input (OLD - USDT based)
            custom_margin_msg = (
                f"üí∞ <b>Custom Margin Amount</b>\n\n"
                f"Enter your custom margin amount in USDT:\n"
                f"üí° Example: 75"
            )


            cancel_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
            ])

            try:
                await query.edit_message_text(
                    custom_margin_msg,
                    parse_mode=ParseMode.HTML,
                    reply_markup=cancel_keyboard
                )
            except Exception as e:
                logger.error(f"Error editing message for custom margin: {e}")

            return MARGIN  # Stay in MARGIN state for text input
        else:
            # Handle quick selection (OLD - USDT based)
            try:
                margin = Decimal(margin_value)

                if margin <= 0:
                    await query.answer("‚ùå Margin must be greater than 0", show_alert=True)
                    return MARGIN

                # Store margin with multiple key formats
                context.chat_data["margin_amount_usdt"] = margin
                context.chat_data["margin_amount"] = margin
                context.chat_data[MARGIN_AMOUNT] = margin
                context.chat_data["MARGIN_AMOUNT"] = margin

                logger.info(f"Quick margin selected: {margin}")

                # Show final confirmation
                return await show_final_confirmation(context, query.message.chat.id)

            except (ValueError, InvalidOperation):
                await query.answer("‚ùå Invalid margin value", show_alert=True)
                return MARGIN

    return MARGIN

async def margin_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle custom margin amount text input - NOW HANDLES PERCENTAGE INPUT"""
    if not update.message or not update.message.text:
        return MARGIN

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    # Check if we're expecting percentage input
    expecting_percentage = context.chat_data.get("expecting_percentage_input", False)

    try:
        input_text = update.message.text.strip().replace('%', '')  # Remove % sign if included
        input_value = Decimal(input_text)

        if expecting_percentage:
            # Handle percentage input
            if input_value <= 0 or input_value > 100:
                await send_error_and_retry(
                    context, chat_id,
                    "Percentage must be between 0 and 100. Please enter a valid percentage:",
                    MARGIN
                )
                return MARGIN

            # Get account balance to calculate USDT amount
            from utils.cache import get_usdt_wallet_balance_cached
            try:
                total_balance, available_balance = await get_usdt_wallet_balance_cached()
            except:
                await send_error_and_retry(
                    context, chat_id,
                    "Unable to fetch account balance. Please try again:",
                    MARGIN
                )
                return MARGIN

            # Calculate USDT amount from percentage
            margin_usdt = (available_balance * input_value) / 100

            # Store margin with multiple key formats
            context.chat_data["margin_amount_usdt"] = margin_usdt
            context.chat_data["margin_amount"] = margin_usdt
            context.chat_data[MARGIN_AMOUNT] = margin_usdt
            context.chat_data["MARGIN_AMOUNT"] = margin_usdt
            context.chat_data["margin_percentage"] = input_value  # Store percentage for reference

            logger.info(f"Custom margin percentage entered: {input_value}% = {margin_usdt} USDT")

            # Clear the flag
            context.chat_data["expecting_percentage_input"] = False

        else:
            # Handle USDT input (backwards compatibility)
            if input_value <= 0:
                await send_error_and_retry(
                    context, chat_id,
                    "Margin amount must be greater than 0. Please enter a valid amount:",
                    MARGIN
                )
                return MARGIN

            # Store margin with multiple key formats
            context.chat_data["margin_amount_usdt"] = input_value
            context.chat_data["margin_amount"] = input_value
            context.chat_data[MARGIN_AMOUNT] = input_value
            context.chat_data["MARGIN_AMOUNT"] = input_value

            logger.info(f"Custom margin entered: {input_value} USDT")

        # Show final confirmation
        return await show_final_confirmation(context, chat_id)

    except (ValueError, InvalidOperation):
        if expecting_percentage:
            await send_error_and_retry(
                context, chat_id,
                "Please enter a valid percentage (e.g., 3.5 for 3.5%):",
                MARGIN
            )
        else:
            await send_error_and_retry(
                context, chat_id,
                "Please enter a valid number for the margin amount (e.g., 50):",
                MARGIN
            )
        return MARGIN

# =============================================
# DUAL MARGIN SELECTION FOR GGSHOT BOTH APPROACHES
# =============================================

async def ask_for_margin_fast(context: ContextTypes.DEFAULT_TYPE, chat_id: int, query: CallbackQuery = None) -> int:
    """Ask for margin for FAST approach when both approaches selected"""
    leverage = context.chat_data.get(LEVERAGE, 10)

    # Get current account balance for percentage calculation
    from utils.cache import get_usdt_wallet_balance_cached
    try:
        total_balance, available_balance = await get_usdt_wallet_balance_cached()
        balance_display = f"Available Balance: ${format_decimal_or_na(available_balance, 2)}"
    except:
        available_balance = Decimal("0")
        balance_display = "Unable to fetch balance"

    margin_msg = (
        f"‚ö° <b>FAST APPROACH - Margin Selection</b>\n"
        f"üí∞ <b>{balance_display}</b>\n\n"
        f"üìä <b>Step 7b: Select Margin for FAST approach</b>\n\n"
        f"Choose what percentage of your account to use for the FAST trade:\n"
        f"üí° This is separate from the Conservative margin\n"
        f"‚ö° Leverage: {leverage}x"
    )

    # Build margin selection keyboard with percentage options
    common_percentages = [0.5, 1, 2, 5]  # Percentage values for fast
    keyboard = []

    # Add common percentage buttons (2 per row)
    for i in range(0, len(common_percentages), 2):
        row = []
        for j in range(2):
            if i + j < len(common_percentages):
                percentage = common_percentages[i + j]
                # Calculate USDT amount for display
                if available_balance > 0:
                    usdt_amount = (available_balance * Decimal(str(percentage))) / 100
                    button_text = f"{percentage}% (‚âà${format_decimal_or_na(usdt_amount, 2)})"
                else:
                    button_text = f"{percentage}%"
                row.append(InlineKeyboardButton(button_text, callback_data=f"conv_margin_fast:{percentage}"))
        if row:
            keyboard.append(row)

    # Add custom and cancel buttons
    keyboard.append([
        InlineKeyboardButton(f"‚úèÔ∏è Custom %", callback_data="conv_margin_fast:custom")
    ])
    keyboard.append([
        InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")
    ])

    margin_keyboard = InlineKeyboardMarkup(keyboard)

    if query:
        # Edit existing message if we have a query
        try:
            await query.edit_message_text(
                margin_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=margin_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for fast margin selection: {e}")
    else:
        # Send new message
        await edit_last_message(context, chat_id, margin_msg, margin_keyboard)

    return MARGIN

async def handle_margin_fast_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle margin selection for FAST approach"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    if not query.data.startswith("conv_margin_fast:"):
        return MARGIN

    value = query.data.split(":")[1]

    if value == "custom":
        # Show custom percentage input
        custom_margin_msg = (
            f"‚ö° <b>FAST Approach - Custom Margin</b>\n\n"
            f"Enter your custom percentage for FAST approach:\n"
            f"üí° Example: 1.5 (for 1.5% of account)\n"
            f"‚ö†Ô∏è Maximum: 100%"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                custom_margin_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for custom fast margin: {e}")

        # Set flag to indicate we're expecting fast margin percentage input
        context.chat_data["expecting_fast_percentage_input"] = True
        return MARGIN
    else:
        # Handle quick percentage selection
        try:
            percentage = Decimal(value)

            if percentage <= 0 or percentage > 100:
                await query.answer("‚ùå Percentage must be between 0 and 100", show_alert=True)
                return MARGIN

            # Get account balance to calculate USDT amount
            from utils.cache import get_usdt_wallet_balance_cached
            try:
                total_balance, available_balance = await get_usdt_wallet_balance_cached()
            except:
                await query.answer("‚ùå Unable to fetch account balance", show_alert=True)
                return MARGIN

            # Calculate USDT amount from percentage
            margin_usdt = (available_balance * percentage) / 100

            # Store FAST margin separately
            context.chat_data["margin_amount_fast"] = margin_usdt
            context.chat_data["margin_percentage_fast"] = percentage

            logger.info(f"Fast margin selected: {percentage}% = {margin_usdt} USDT")

            # Now ask for Conservative margin
            return await ask_for_margin_conservative(context, query.message.chat.id, query)

        except (ValueError, InvalidOperation):
            await query.answer("‚ùå Invalid percentage value", show_alert=True)
            return MARGIN

async def margin_fast_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle custom fast margin text input"""
    if not update.message or not update.message.text:
        return MARGIN

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    # Check if we're expecting fast percentage input
    if not context.chat_data.get("expecting_fast_percentage_input", False):
        return MARGIN

    try:
        input_text = update.message.text.strip().replace('%', '')
        percentage = Decimal(input_text)

        if percentage <= 0 or percentage > 100:
            await send_error_and_retry(
                context, chat_id,
                "Fast approach percentage must be between 0 and 100. Please enter a valid percentage:",
                MARGIN
            )
            return MARGIN

        # Get account balance to calculate USDT amount
        from utils.cache import get_usdt_wallet_balance_cached
        try:
            total_balance, available_balance = await get_usdt_wallet_balance_cached()
        except:
            await send_error_and_retry(
                context, chat_id,
                "Unable to fetch account balance. Please try again:",
                MARGIN
            )
            return MARGIN

        # Calculate USDT amount from percentage
        margin_usdt = (available_balance * percentage) / 100

        # Store FAST margin separately
        context.chat_data["margin_amount_fast"] = margin_usdt
        context.chat_data["margin_percentage_fast"] = percentage

        logger.info(f"Custom fast margin entered: {percentage}% = {margin_usdt} USDT")

        # Clear the flag
        context.chat_data["expecting_fast_percentage_input"] = False

        # Now ask for Conservative margin
        return await ask_for_margin_conservative(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for fast margin percentage:",
            MARGIN
        )
        return MARGIN

async def ask_for_margin_conservative(context: ContextTypes.DEFAULT_TYPE, chat_id: int, query: CallbackQuery = None) -> int:
    """Ask for margin for CONSERVATIVE approach when both approaches selected"""
    leverage = context.chat_data.get(LEVERAGE, 10)
    fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
    fast_percentage = context.chat_data.get("margin_percentage_fast", Decimal("0"))

    # Get current account balance for percentage calculation
    from utils.cache import get_usdt_wallet_balance_cached
    try:
        total_balance, available_balance = await get_usdt_wallet_balance_cached()
        # Calculate remaining balance after fast margin
        remaining_balance = available_balance - fast_margin
        balance_display = f"Remaining Balance: ${format_decimal_or_na(remaining_balance, 2)}"
    except:
        remaining_balance = Decimal("0")
        balance_display = "Unable to fetch balance"

    margin_msg = (
        f"üõ°Ô∏è <b>CONSERVATIVE APPROACH - Margin Selection</b>\n"
        f"üí∞ <b>{balance_display}</b>\n\n"
        f"‚úÖ Fast Margin: {fast_percentage}% (${format_decimal_or_na(fast_margin, 2)})\n\n"
        f"üìä <b>Step 7c: Select Margin for CONSERVATIVE approach</b>\n\n"
        f"Choose what percentage of your account to use for the CONSERVATIVE trade:\n"
        f"üí° This is separate from the Fast margin\n"
        f"üõ°Ô∏è Leverage: {leverage}x"
    )

    # Build margin selection keyboard with percentage options
    common_percentages = [1, 2, 5, 10]  # Percentage values for conservative
    keyboard = []

    # Add common percentage buttons (2 per row)
    for i in range(0, len(common_percentages), 2):
        row = []
        for j in range(2):
            if i + j < len(common_percentages):
                percentage = common_percentages[i + j]
                # Calculate USDT amount for display (from total balance, not remaining)
                if available_balance > 0:
                    usdt_amount = (available_balance * Decimal(str(percentage))) / 100
                    button_text = f"{percentage}% (‚âà${format_decimal_or_na(usdt_amount, 2)})"
                else:
                    button_text = f"{percentage}%"
                row.append(InlineKeyboardButton(button_text, callback_data=f"conv_margin_cons:{percentage}"))
        if row:
            keyboard.append(row)

    # Add custom, back and cancel buttons
    keyboard.append([
        InlineKeyboardButton(f"‚úèÔ∏è Custom %", callback_data="conv_margin_cons:custom")
    ])
    keyboard.append([
        InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{MARGIN}"),
        InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")
    ])

    margin_keyboard = InlineKeyboardMarkup(keyboard)

    if query:
        # Edit existing message if we have a query
        try:
            await query.edit_message_text(
                margin_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=margin_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for conservative margin selection: {e}")
    else:
        # Send new message
        await edit_last_message(context, chat_id, margin_msg, margin_keyboard)

    return MARGIN

async def handle_margin_conservative_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle margin selection for CONSERVATIVE approach"""
    query = update.callback_query
    try:
        await query.answer()
    except:
        pass

    if not query.data.startswith("conv_margin_cons:"):
        return MARGIN

    value = query.data.split(":")[1]

    if value == "custom":
        # Show custom percentage input
        custom_margin_msg = (
            f"üõ°Ô∏è <b>CONSERVATIVE Approach - Custom Margin</b>\n\n"
            f"Enter your custom percentage for CONSERVATIVE approach:\n"
            f"üí° Example: 3.5 (for 3.5% of account)\n"
            f"‚ö†Ô∏è Maximum: 100%"
        )

        cancel_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{MARGIN}")],
            [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                custom_margin_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except Exception as e:
            logger.error(f"Error editing message for custom conservative margin: {e}")

        # Set flag to indicate we're expecting conservative margin percentage input
        context.chat_data["expecting_conservative_percentage_input"] = True
        return MARGIN
    else:
        # Handle quick percentage selection
        try:
            percentage = Decimal(value)

            if percentage <= 0 or percentage > 100:
                await query.answer("‚ùå Percentage must be between 0 and 100", show_alert=True)
                return MARGIN

            # Get account balance to calculate USDT amount
            from utils.cache import get_usdt_wallet_balance_cached
            try:
                total_balance, available_balance = await get_usdt_wallet_balance_cached()
            except:
                await query.answer("‚ùå Unable to fetch account balance", show_alert=True)
                return MARGIN

            # Calculate USDT amount from percentage
            margin_usdt = (available_balance * percentage) / 100

            # Check if total margin exceeds available balance
            fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
            if fast_margin + margin_usdt > available_balance:
                await query.answer(
                    f"‚ùå Total margin (${format_decimal_or_na(fast_margin + margin_usdt, 2)}) exceeds available balance",
                    show_alert=True
                )
                return MARGIN

            # Store CONSERVATIVE margin separately
            context.chat_data["margin_amount_conservative"] = margin_usdt
            context.chat_data["margin_percentage_conservative"] = percentage

            # Calculate and store total margin for both trades
            total_margin = fast_margin + margin_usdt
            context.chat_data[MARGIN_AMOUNT] = total_margin
            context.chat_data["margin_amount"] = total_margin

            logger.info(f"Conservative margin selected: {percentage}% = {margin_usdt} USDT")
            logger.info(f"Total margin for both trades: {total_margin} USDT")

            # Show final confirmation for both trades
            return await show_both_trades_confirmation(context, query.message.chat.id, query)

        except (ValueError, InvalidOperation):
            await query.answer("‚ùå Invalid percentage value", show_alert=True)
            return MARGIN

async def margin_conservative_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle custom conservative margin text input"""
    if not update.message or not update.message.text:
        return MARGIN

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    # Check if we're expecting conservative percentage input
    if not context.chat_data.get("expecting_conservative_percentage_input", False):
        return MARGIN

    try:
        input_text = update.message.text.strip().replace('%', '')
        percentage = Decimal(input_text)

        if percentage <= 0 or percentage > 100:
            await send_error_and_retry(
                context, chat_id,
                "Conservative approach percentage must be between 0 and 100. Please enter a valid percentage:",
                MARGIN
            )
            return MARGIN

        # Get account balance to calculate USDT amount
        from utils.cache import get_usdt_wallet_balance_cached
        try:
            total_balance, available_balance = await get_usdt_wallet_balance_cached()
        except:
            await send_error_and_retry(
                context, chat_id,
                "Unable to fetch account balance. Please try again:",
                MARGIN
            )
            return MARGIN

        # Calculate USDT amount from percentage
        margin_usdt = (available_balance * percentage) / 100

        # Check if total margin exceeds available balance
        fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
        if fast_margin + margin_usdt > available_balance:
            await send_error_and_retry(
                context, chat_id,
                f"Total margin (${format_decimal_or_na(fast_margin + margin_usdt, 2)}) exceeds available balance. Please enter a smaller percentage:",
                MARGIN
            )
            return MARGIN

        # Store CONSERVATIVE margin separately
        context.chat_data["margin_amount_conservative"] = margin_usdt
        context.chat_data["margin_percentage_conservative"] = percentage

        # Calculate and store total margin for both trades
        fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
        total_margin = fast_margin + margin_usdt
        context.chat_data[MARGIN_AMOUNT] = total_margin
        context.chat_data["margin_amount"] = total_margin

        logger.info(f"Custom conservative margin entered: {percentage}% = {margin_usdt} USDT")
        logger.info(f"Total margin for both trades: {total_margin} USDT")

        # Clear the flag
        context.chat_data["expecting_conservative_percentage_input"] = False

        # Show final confirmation for both trades
        return await show_both_trades_confirmation(context, chat_id)

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for conservative margin percentage:",
            MARGIN
        )
        return MARGIN

# =============================================
# FINAL CONFIRMATION - ENHANCED FOR DUAL APPROACHES WITH PROTECTION
# =============================================

async def show_final_confirmation(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Show final trade confirmation - enhanced for GGShot screenshot approach"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    approach = context.chat_data.get(TRADING_APPROACH, "fast")
    leverage = context.chat_data.get(LEVERAGE, 10)
    margin = context.chat_data.get(MARGIN_AMOUNT, Decimal("0"))
    both_trades = context.chat_data.get("ggshot_both_trades", False)

    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    if approach == "fast":
        approach_emoji = "‚ö°"
        approach_text = "Fast Market"
    elif approach == "conservative":
        approach_emoji = "üõ°Ô∏è"
        approach_text = "Conservative Limits"
    elif approach == "ggshot":
        approach_emoji = "üì∏"
        approach_text = "GGShot Screenshot"
    else:
        approach_emoji = "‚ö°"
        approach_text = "Fast Market"

    # Build confirmation based on actual strategy (for GGShot, check order strategy)
    order_strategy = context.chat_data.get(ORDER_STRATEGY)

    # Check if we're doing both approaches
    if both_trades:
        # Show confirmation for both trades
        return await show_both_trades_confirmation(context, chat_id)

    # Determine display strategy - for GGShot, use the detected strategy
    if approach == "ggshot":
        if order_strategy == STRATEGY_CONSERVATIVE_LIMITS:
            display_strategy = "conservative"
        else:
            display_strategy = "fast"
    else:
        display_strategy = approach

    if display_strategy == "fast" or order_strategy == STRATEGY_MARKET_ONLY:
        entry_price = context.chat_data.get(PRIMARY_ENTRY_PRICE, Decimal("0"))
        tp_price = context.chat_data.get(TP1_PRICE, Decimal("0"))
        sl_price = context.chat_data.get(SL_PRICE, Decimal("0"))

        # Calculate R:R ratio
        rr_info = ""
        try:
            if entry_price and tp_price and sl_price:
                rr_result = calculate_risk_reward_ratio(entry_price, tp_price, sl_price, side)
                if rr_result and 'ratio' in rr_result:
                    ratio_raw = rr_result.get('ratio', '1:0')
                    rating = rr_result.get('rating', '‚ö™ UNKNOWN')
                    rr_info = f"\n‚öñÔ∏è <b>Risk:Reward:</b> {ratio_raw} ({rating})"
        except Exception as e:
            logger.error(f"Error calculating R:R ratio: {e}")

        # Calculate simple USDT P&L preview
        pnl_preview = ""
        if all([entry_price, tp_price, sl_price, margin, leverage]):
            pnl_preview = calculate_trade_pnl_preview(
                entry_price, tp_price, sl_price, margin, leverage, side
            )

        # Add GGShot indicator if applicable
        ggshot_info = ""
        if approach == "ggshot":
            ggshot_info = f"ü§ñ <b>AI Extracted:</b> Fast Market strategy detected\n"

        confirmation_msg = (
            f"üöÄ <b>TRADE CONFIRMATION</b> üöÄ\n"
            f"{'‚ïê' * 30}\n\n"
            f"üìä <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"üìà <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"‚ö° <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"{ggshot_info}"
            f"üí∞ <b>Entry:</b> <code>{format_price(entry_price)}</code>\n"
            f"üéØ <b>Take Profit:</b> <code>{format_price(tp_price)}</code> (100%) üõ°Ô∏è\n"
            f"üõ°Ô∏è <b>Stop Loss:</b> <code>{format_price(sl_price)}</code> üõ°Ô∏è\n"
            f"‚ö° <b>Leverage:</b> {leverage}x\n"
            f"üí∞ <b>Margin:</b> {format_decimal_or_na(margin)} USDT"
        )

        # Add percentage info if available
        if "margin_percentage" in context.chat_data:
            percentage = context.chat_data["margin_percentage"]
            confirmation_msg += f" ({percentage}%)"

        confirmation_msg += (
            f"{rr_info}\n"
            f"{pnl_preview}\n"
            f"üõ°Ô∏è <b>Protection:</b> All orders will be protected from cleanup\n\n"
            f"‚ö†Ô∏è <b>Ready to execute this trade?</b>"
        )

    else:  # conservative approach
        trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
        limit1_price = context.chat_data.get(LIMIT_ENTRY_1_PRICE, Decimal("0"))
        limit2_price = context.chat_data.get(LIMIT_ENTRY_2_PRICE, Decimal("0"))
        limit3_price = context.chat_data.get(LIMIT_ENTRY_3_PRICE, Decimal("0"))
        tp1_price = context.chat_data.get(TP1_PRICE, Decimal("0"))
        tp2_price = context.chat_data.get(TP2_PRICE, Decimal("0"))
        tp3_price = context.chat_data.get(TP3_PRICE, Decimal("0"))
        tp4_price = context.chat_data.get(TP4_PRICE, Decimal("0"))
        sl_price = context.chat_data.get(SL_PRICE, Decimal("0"))

        # Check if merge will happen
        merge_info = ""
        from execution.position_merger import ConservativePositionMerger
        merger = ConservativePositionMerger()
        # Pass bot_data to check if position belongs to bot
        bot_data = context.application.bot_data if context.application else None
        should_merge, existing_data = await merger.should_merge_positions(symbol, side, "conservative", bot_data)

        if should_merge:
            existing_pos = existing_data.get('position', {})
            existing_size = existing_pos.get('size', 0)
            existing_value = existing_pos.get('positionValue', 0)
            merge_info = (
                f"\nüîÑ <b>POSITION MERGE DETECTED!</b>\n"
                f"Existing {side} position: {existing_size} {symbol}\n"
                f"Value: ${existing_value}\n"
                f"\n‚ö†Ô∏è Orders will be merged to bypass limits\n"
                f"SL: Will use the safer price\n"
                f"TPs: Will use more aggressive prices\n"
            )

        # Add GGShot indicator if applicable
        ggshot_info = ""
        if approach == "ggshot":
            ggshot_info = f"ü§ñ <b>AI Extracted:</b> Conservative Limits strategy detected\n"

        confirmation_msg = (
            f"üöÄ <b>CONSERVATIVE TRADE CONFIRMATION</b> üöÄ\n"
            f"{'‚ïê' * 35}\n\n"
            f"üìä <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"üìà <b>Direction:</b> {direction_emoji} {direction_text}\n"
            f"üõ°Ô∏è <b>Approach:</b> {approach_emoji} {approach_text}\n"
            f"{ggshot_info}"
            f"{merge_info}"
            f"üõ°Ô∏è <b>Trade Group:</b> <code>{trade_group_id}</code> üõ°Ô∏è\n\n"
            f"üìä <b>LIMIT ORDERS (33.33% each):</b>\n"
            f"‚Ä¢ <b>Limit #1:</b> <code>{format_price(limit1_price)}</code> üõ°Ô∏è\n"
            f"‚Ä¢ <b>Limit #2:</b> <code>{format_price(limit2_price)}</code> üõ°Ô∏è\n"
            f"‚Ä¢ <b>Limit #3:</b> <code>{format_price(limit3_price)}</code> üõ°Ô∏è\n\n"
            f"üéØ <b>TAKE PROFITS:</b>\n"
            f"‚Ä¢ <b>TP1 (70%):</b> <code>{format_price(tp1_price)}</code> üõ°Ô∏è\n"
            f"‚Ä¢ <b>TP2 (10%):</b> <code>{format_price(tp2_price)}</code> üõ°Ô∏è\n"
            f"‚Ä¢ <b>TP3 (10%):</b> <code>{format_price(tp3_price)}</code> üõ°Ô∏è\n"
            f"‚Ä¢ <b>TP4 (10%):</b> <code>{format_price(tp4_price)}</code> üõ°Ô∏è\n\n"
            f"üõ°Ô∏è <b>Stop Loss:</b> <code>{format_price(sl_price)}</code> üõ°Ô∏è\n"
            f"‚ö° <b>Leverage:</b> {leverage}x\n"
            f"üí∞ <b>Total Margin:</b> {format_decimal_or_na(margin)} USDT"
        )

        # Add percentage info if available
        if "margin_percentage" in context.chat_data:
            percentage = context.chat_data["margin_percentage"]
            confirmation_msg += f" ({percentage}%)"

        confirmation_msg += (
            f"\n\n"
            f"üõ°Ô∏è <b>Protection:</b> Trade group and all orders protected from cleanup\n\n"
            f"‚ö†Ô∏è <b>Special Rule:</b> If TP1 hits before limits fill,\n"
            f"all remaining orders will be cancelled.\n\n"
            f"‚ö†Ô∏è <b>Ready to execute this conservative trade?</b>"
        )

    confirmation_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üöÄ EXECUTE TRADE", callback_data="confirm_execute_trade")],
        [
            InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation"),
            InlineKeyboardButton("üîß Modify", callback_data="modify_trade")
        ]
    ])

    await edit_last_message(context, chat_id, confirmation_msg, confirmation_keyboard)
    return CONFIRMATION

async def show_both_trades_confirmation(context: ContextTypes.DEFAULT_TYPE, chat_id: int, query: CallbackQuery = None) -> int:
    """Show confirmation for both fast and conservative trades with separate margins"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    leverage = context.chat_data.get(LEVERAGE, 10)

    # Check if we have separate margins or need to split equally
    if "margin_amount_fast" in context.chat_data and "margin_amount_conservative" in context.chat_data:
        # Get separate margins for each approach
        fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
        conservative_margin = context.chat_data.get("margin_amount_conservative", Decimal("0"))
        fast_percentage = context.chat_data.get("margin_percentage_fast", Decimal("0"))
        conservative_percentage = context.chat_data.get("margin_percentage_conservative", Decimal("0"))
        has_separate_margins = True
    else:
        # Split total margin equally
        total_margin_original = context.chat_data.get(MARGIN_AMOUNT, Decimal("0"))
        fast_margin = total_margin_original / 2
        conservative_margin = total_margin_original / 2
        fast_percentage = Decimal("50")  # Default to 50% each
        conservative_percentage = Decimal("50")
        has_separate_margins = False

    total_margin = fast_margin + conservative_margin

    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    # Get all extracted prices
    entry_price = context.chat_data.get(PRIMARY_ENTRY_PRICE, Decimal("0"))
    tp1_price = context.chat_data.get(TP1_PRICE, Decimal("0"))
    tp2_price = context.chat_data.get(TP2_PRICE, Decimal("0"))
    tp3_price = context.chat_data.get(TP3_PRICE, Decimal("0"))
    tp4_price = context.chat_data.get(TP4_PRICE, Decimal("0"))
    sl_price = context.chat_data.get(SL_PRICE, Decimal("0"))

    # Conservative limit prices
    limit1_price = context.chat_data.get(LIMIT_ENTRY_1_PRICE, Decimal("0"))
    limit2_price = context.chat_data.get(LIMIT_ENTRY_2_PRICE, Decimal("0"))
    limit3_price = context.chat_data.get(LIMIT_ENTRY_3_PRICE, Decimal("0"))

    # Calculate R:R for fast trade
    rr_info = ""
    try:
        if entry_price and tp1_price and sl_price:
            rr_result = calculate_risk_reward_ratio(entry_price, tp1_price, sl_price, side)
            if rr_result and 'ratio' in rr_result:
                ratio_raw = rr_result.get('ratio', '1:0')
                rating = rr_result.get('rating', '‚ö™ UNKNOWN')
                rr_info = f"‚öñÔ∏è Risk:Reward: {ratio_raw} ({rating})"
    except Exception as e:
        logger.error(f"Error calculating R:R ratio: {e}")

    confirmation_msg = (
        f"üöÄ <b>DUAL TRADE CONFIRMATION</b> üöÄ\n"
        f"{'‚ïê' * 30}\n\n"
        f"üìä <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"üìà <b>Direction:</b> {direction_emoji} {direction_text}\n"
        f"‚ö°+üõ°Ô∏è <b>Approach:</b> BOTH (Fast + Conservative)\n"
        f"ü§ñ <b>AI Extracted:</b> Using GGShot prices\n"
        f"‚ö° <b>Leverage:</b> {leverage}x (for both)\n"
        f"üí∞ <b>Total Margin:</b> ${format_decimal_or_na(total_margin, 2)} USDT\n"
    )

    if has_separate_margins:
        confirmation_msg += f"   ‚ö° Fast: {fast_percentage}% = ${format_decimal_or_na(fast_margin, 2)}\n"
        confirmation_msg += f"   üõ°Ô∏è Conservative: {conservative_percentage}% = ${format_decimal_or_na(conservative_margin, 2)}\n"
    else:
        confirmation_msg += f"   Split equally: ${format_decimal_or_na(fast_margin, 2)} each\n"

    confirmation_msg += (
        f"\n{'‚îÄ' * 30}\n"
        f"‚ö° <b>TRADE 1: FAST MARKET</b>\n"
        f"üí∞ Margin: ${format_decimal_or_na(fast_margin, 2)} USDT"
    )

    if has_separate_margins:
        confirmation_msg += f" ({fast_percentage}%)"

    confirmation_msg += (
        f"\nüìç Entry: Market @ ~<code>{format_price(entry_price)}</code>\n"
        f"üéØ TP: <code>{format_price(tp1_price)}</code> (100%)\n"
        f"üõ°Ô∏è SL: <code>{format_price(sl_price)}</code>\n"
        f"{rr_info}\n\n"
        f"{'‚îÄ' * 30}\n"
        f"üõ°Ô∏è <b>TRADE 2: CONSERVATIVE</b>\n"
        f"üí∞ Margin: ${format_decimal_or_na(conservative_margin, 2)} USDT"
    )

    if has_separate_margins:
        confirmation_msg += f" ({conservative_percentage}%)"

    confirmation_msg += (
        f"\nüìä <b>Limit Orders:</b>\n"
        f"  ‚Ä¢ L1: <code>{format_price(limit1_price)}</code> (33.33%)\n"
        f"  ‚Ä¢ L2: <code>{format_price(limit2_price)}</code> (33.33%)\n"
        f"  ‚Ä¢ L3: <code>{format_price(limit3_price)}</code> (33.33%)\n"
        f"üéØ <b>Take Profits:</b>\n"
        f"  ‚Ä¢ TP1: <code>{format_price(tp1_price)}</code> (70%)\n"
        f"  ‚Ä¢ TP2: <code>{format_price(tp2_price)}</code> (10%)\n"
        f"  ‚Ä¢ TP3: <code>{format_price(tp3_price)}</code> (10%)\n"
        f"  ‚Ä¢ TP4: <code>{format_price(tp4_price)}</code> (10%)\n"
        f"üõ°Ô∏è SL: <code>{format_price(sl_price)}</code>\n\n"
        f"{'‚îÄ' * 30}\n"
        f"üõ°Ô∏è <b>Protection:</b> Both trades protected from cleanup\n"
        f"üìä <b>Monitoring:</b> Independent for each trade\n\n"
        f"‚ö†Ô∏è <b>Ready to execute BOTH trades?</b>"
    )

    confirmation_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üöÄ EXECUTE BOTH TRADES", callback_data="confirm_execute_trade")],
        [
            InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation"),
            InlineKeyboardButton("üîß Modify", callback_data="modify_trade")
        ]
    ])

    await edit_last_message(context, chat_id, confirmation_msg, confirmation_keyboard)
    return CONFIRMATION

async def confirmation_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle final confirmation"""
    # This should be handled by callback queries
    if update.message:
        await update.message.delete()
    return CONFIRMATION

# =============================================
# EXECUTION HANDLER - ENHANCED FOR DUAL APPROACHES WITH PROTECTION
# =============================================

async def handle_execute_trade(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle trade execution for both approaches with protection system - FIXED"""
    query = update.callback_query
    try:
        await query.answer("üöÄ Executing trade with protection system...")
    except:
        pass

    chat_id = query.message.chat.id
    approach = context.chat_data.get(TRADING_APPROACH, "fast")
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    both_trades = context.chat_data.get("ggshot_both_trades", False)

    # Check if we need to execute both trades
    if both_trades:
        # Execute both fast and conservative trades
        return await execute_both_trades(update, context)

    # Show execution message
    if approach == "fast":
        execution_msg = (
            f"{get_emoji('lightning')} <b>EXECUTING FAST TRADE...</b>\n\n"
            f"{get_emoji('rocket')} Placing market order on Bybit\n"
            f"{get_emoji('loading')} Please wait...\n\n"
            f"üìä Single take profit (100% close)\n"
            f"üìà Performance tracking will be enabled\n"
            f"üõ°Ô∏è Symbol {symbol} protected from cleanup\n"
            f"This may take a few seconds..."
        )
    else:
        trade_group_id = context.chat_data.get(CONSERVATIVE_TRADE_GROUP_ID, "Unknown")
        execution_msg = (
            f"{get_emoji('shield')} <b>EXECUTING CONSERVATIVE TRADE...</b>\n\n"
            f"{get_emoji('rocket')} Placing 3 limit orders + 4 TPs + 1 SL\n"
            f"{get_emoji('loading')} Please wait...\n\n"
            f"üìä Conservative approach with isolated orders\n"
            f"üìà Enhanced monitoring will be enabled\n"
            f"üõ°Ô∏è Trade group {trade_group_id} protected from cleanup\n"
            f"üõ°Ô∏è Symbol {symbol} protected from cleanup\n"
            f"This may take longer due to multiple orders..."
        )

    try:
        await query.edit_message_text(
            execution_msg,
            parse_mode=ParseMode.HTML
        )
    except:
        pass

    # Set order strategy based on approach
    if approach == "conservative":
        context.chat_data["order_strategy"] = STRATEGY_CONSERVATIVE_LIMITS
        if 'ORDER_STRATEGY' in globals():
            context.chat_data[ORDER_STRATEGY] = STRATEGY_CONSERVATIVE_LIMITS
    else:
        context.chat_data["order_strategy"] = STRATEGY_MARKET_ONLY
        if 'ORDER_STRATEGY' in globals():
            context.chat_data[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY

    # CRITICAL: Store chat_id for monitoring
    context.chat_data["_temp_chat_id"] = chat_id
    context.chat_data["_execution_source"] = "enhanced_conversation_with_protection"

    # Execute the trade using the enhanced trader module with protection system
    try:
        from execution.trader import execute_trade_logic

        # Create a copy of chat_data with proper mappings
        cfg = context.chat_data.copy() if context.chat_data else {}
        cfg["_temp_chat_id"] = chat_id  # Ensure chat_id is passed

        # CRITICAL FIX: Ensure all required keys are properly mapped
        if not cfg.get('LEVERAGE') and cfg.get('leverage'):
            cfg['LEVERAGE'] = cfg.get('leverage')
        if not cfg.get('MARGIN_AMOUNT') and cfg.get('margin_amount_usdt'):
            cfg['MARGIN_AMOUNT'] = cfg.get('margin_amount_usdt')
        if not cfg.get('SYMBOL') and cfg.get('symbol'):
            cfg['SYMBOL'] = cfg.get('symbol')
        if not cfg.get('SIDE') and cfg.get('side'):
            cfg['SIDE'] = cfg.get('side')

        # Map entry prices based on approach
        if approach == "fast":
            if not cfg.get('PRIMARY_ENTRY_PRICE') and cfg.get('primary_entry_price'):
                cfg['PRIMARY_ENTRY_PRICE'] = cfg.get('primary_entry_price')

        # Map TP prices
        if not cfg.get('TP1_PRICE') and cfg.get('tp1_price'):
            cfg['TP1_PRICE'] = cfg.get('tp1_price')
        if not cfg.get('SL_PRICE') and cfg.get('sl_price'):
            cfg['SL_PRICE'] = cfg.get('sl_price')

        logger.info(f"ENHANCED EXECUTION CONFIG for {approach} approach with protection:")
        logger.info(f"  SYMBOL: {cfg.get('SYMBOL')}")
        logger.info(f"  SIDE: {cfg.get('SIDE')}")
        logger.info(f"  APPROACH: {approach}")
        logger.info(f"  LEVERAGE: {cfg.get('LEVERAGE')}")
        logger.info(f"  MARGIN_AMOUNT: {cfg.get('MARGIN_AMOUNT')}")
        logger.info(f"  PROTECTION: Enabled")

        # FIXED: Call async function properly without asyncio.to_thread
        result = await execute_trade_logic(context.application, chat_id, cfg)

        # UPDATED: Display the enhanced message from trader.py
        if isinstance(result, dict) and result.get("message"):
            # Use the rich formatted message from trader.py
            await context.bot.send_message(
                chat_id,
                result["message"],
                parse_mode=ParseMode.HTML
            )
        else:
            # Fallback to basic message if no enhanced message
            if isinstance(result, dict):
                if result.get("success"):
                    result_msg = (
                        f"‚úÖ <b>Trade Executed Successfully!</b>\n\n"
                        f"üìä <b>Orders Placed:</b>\n"
                    )
                    for order in result.get("orders_placed", []):
                        result_msg += f"‚Ä¢ {order}\n"

                    if approach == "fast" and result.get("entry_price"):
                        result_msg += f"\nüìà <b>Entry Price:</b> {format_price(result.get('entry_price'))}"
                        result_msg += f"\nüìä <b>Position Size:</b> {format_decimal_or_na(result.get('position_size'))}"

                    result_msg += f"\n\nüîÑ Automatic monitoring has been started"
                    result_msg += f"\nüõ°Ô∏è All orders are protected from cleanup"
                else:
                    result_msg = f"‚ùå <b>Trade Execution Failed</b>\n\n{escape(result.get('error', 'Unknown error'))}"
            else:
                # If result is a string, use it directly
                result_msg = str(result)

            # Send result
            await context.bot.send_message(
                chat_id,
                result_msg,
                parse_mode=ParseMode.HTML
            )

        logger.info(f"‚úÖ {approach} trade execution completed with advanced protection system enabled")

    except Exception as e:
        logger.error(f"Execution error: {e}", exc_info=True)
        await context.bot.send_message(
            chat_id,
            f"{get_emoji('error')} <b>Execution Failed</b>\n\n{escape(str(e))}\n\nPlease try again.",
            parse_mode=ParseMode.HTML
        )

    # Return to dashboard
    try:
        from handlers.commands import _send_or_edit_dashboard_message
        await _send_or_edit_dashboard_message(chat_id, context, new_msg=True)
    except:
        pass

    return ConversationHandler.END

async def execute_both_trades(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Execute both fast and conservative trades"""
    query = update.callback_query
    chat_id = query.message.chat.id

    # Get shared parameters
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    leverage = context.chat_data.get(LEVERAGE, 10)
    total_margin = context.chat_data.get(MARGIN_AMOUNT)
    if total_margin is None:
        total_margin = context.chat_data.get("margin_amount", Decimal("0"))
    if total_margin is None:
        total_margin = Decimal("0")

    # Check if we have separate margins (from dual margin selection)
    if "margin_amount_fast" in context.chat_data and "margin_amount_conservative" in context.chat_data:
        # Use the separately selected margins
        fast_margin = context.chat_data.get("margin_amount_fast", Decimal("0"))
        conservative_margin = context.chat_data.get("margin_amount_conservative", Decimal("0"))
    else:
        # Split margin equally (backward compatibility)
        if total_margin > 0:
            fast_margin = total_margin / 2
            conservative_margin = total_margin / 2
        else:
            # If no total margin, try to get from percentage calculations
            fast_margin = context.chat_data.get("margin_amount_fast", Decimal("50"))
            conservative_margin = context.chat_data.get("margin_amount_conservative", Decimal("50"))

    # Show execution message
    if "margin_amount_fast" in context.chat_data and "margin_amount_conservative" in context.chat_data:
        execution_msg = (
            f"‚ö°+üõ°Ô∏è <b>EXECUTING BOTH TRADES...</b>\n\n"
            f"{get_emoji('loading')} Preparing dual trade execution\n"
            f"üìä This will open 2 separate positions\n"
            f"üí∞ <b>Fast Margin:</b> ${format_decimal_or_na(fast_margin, 2)} ({context.chat_data.get('margin_percentage_fast', 0)}%)\n"
            f"üí∞ <b>Conservative Margin:</b> ${format_decimal_or_na(conservative_margin, 2)} ({context.chat_data.get('margin_percentage_conservative', 0)}%)\n\n"
            f"Please wait while we execute both strategies..."
        )
    else:
        execution_msg = (
            f"‚ö°+üõ°Ô∏è <b>EXECUTING BOTH TRADES...</b>\n\n"
            f"{get_emoji('loading')} Preparing dual trade execution\n"
            f"üìä This will open 2 separate positions\n"
            f"üí∞ Margin will be split equally (${format_decimal_or_na(fast_margin, 2)} each)\n\n"
            f"Please wait while we execute both strategies..."
        )

    try:
        await query.edit_message_text(
            execution_msg,
            parse_mode=ParseMode.HTML
        )
    except:
        pass

    # Store original margin for restoration
    original_margin = total_margin
    original_approach = context.chat_data.get(TRADING_APPROACH)
    original_strategy = context.chat_data.get(ORDER_STRATEGY)

    try:
        from execution.trader import execute_trade_logic

        # Results storage
        fast_result = None
        conservative_result = None

        # === EXECUTE FAST TRADE FIRST ===
        await context.bot.send_message(
            chat_id,
            f"‚ö° <b>Executing Trade 1: FAST MARKET</b>\n"
            f"üí∞ Margin: {format_decimal_or_na(fast_margin)} USDT",
            parse_mode=ParseMode.HTML
        )

        # Create ISOLATED config for fast trade (don't modify shared chat_data)
        fast_cfg = context.chat_data.copy()
        fast_cfg[TRADING_APPROACH] = "fast"
        fast_cfg[ORDER_STRATEGY] = STRATEGY_MARKET_ONLY
        fast_cfg[MARGIN_AMOUNT] = fast_margin
        fast_cfg["margin_amount"] = fast_margin
        fast_cfg["margin_amount_usdt"] = fast_margin
        # Pass the margin percentage for mirror account to calculate proportionally
        fast_cfg["margin_percentage"] = context.chat_data.get("margin_percentage_fast")
        fast_cfg["_temp_chat_id"] = chat_id
        fast_cfg["_execution_source"] = "ggshot_both_trades_fast"

        # Execute fast trade
        try:
            fast_result = await execute_trade_logic(context.application, chat_id, fast_cfg)

            # Show fast trade result
            if isinstance(fast_result, dict) and fast_result.get("message"):
                await context.bot.send_message(
                    chat_id,
                    fast_result["message"],
                    parse_mode=ParseMode.HTML
                )
            else:
                # Fallback message
                if isinstance(fast_result, dict) and fast_result.get("success"):
                    await context.bot.send_message(
                        chat_id,
                        "‚úÖ Fast trade executed successfully!",
                        parse_mode=ParseMode.HTML
                    )
        except Exception as e:
            logger.error(f"Error executing fast trade: {e}")
            await context.bot.send_message(
                chat_id,
                f"‚ùå Fast trade failed: {escape(str(e))}",
                parse_mode=ParseMode.HTML
            )

        # === EXECUTE CONSERVATIVE TRADE SECOND ===
        await context.bot.send_message(
            chat_id,
            f"\nüõ°Ô∏è <b>Executing Trade 2: CONSERVATIVE LIMITS</b>\n"
            f"üí∞ Margin: {format_decimal_or_na(conservative_margin)} USDT",
            parse_mode=ParseMode.HTML
        )

        # Generate new trade group ID for conservative
        trade_group_id = str(uuid.uuid4())[:8]
        try:
            protect_trade_group_from_cleanup(trade_group_id)
        except Exception as e:
            logger.error(f"Error protecting trade group: {e}")

        # Create ISOLATED config for conservative trade (don't modify shared chat_data)
        conservative_cfg = context.chat_data.copy()
        conservative_cfg[TRADING_APPROACH] = "conservative"
        conservative_cfg[ORDER_STRATEGY] = STRATEGY_CONSERVATIVE_LIMITS
        conservative_cfg[MARGIN_AMOUNT] = conservative_margin
        conservative_cfg["margin_amount"] = conservative_margin
        conservative_cfg["margin_amount_usdt"] = conservative_margin
        # Pass the margin percentage for mirror account to calculate proportionally
        conservative_cfg["margin_percentage"] = context.chat_data.get("margin_percentage_conservative")
        conservative_cfg[CONSERVATIVE_TRADE_GROUP_ID] = trade_group_id
        conservative_cfg["_temp_chat_id"] = chat_id
        conservative_cfg["_execution_source"] = "ggshot_both_trades_conservative"

        # Execute conservative trade
        try:
            conservative_result = await execute_trade_logic(context.application, chat_id, conservative_cfg)

            # Show conservative trade result
            if isinstance(conservative_result, dict) and conservative_result.get("message"):
                await context.bot.send_message(
                    chat_id,
                    conservative_result["message"],
                    parse_mode=ParseMode.HTML
                )
            else:
                # Fallback message
                if isinstance(conservative_result, dict) and conservative_result.get("success"):
                    await context.bot.send_message(
                        chat_id,
                        "‚úÖ Conservative trade executed successfully!",
                        parse_mode=ParseMode.HTML
                    )
        except Exception as e:
            logger.error(f"Error executing conservative trade: {e}")
            await context.bot.send_message(
                chat_id,
                f"‚ùå Conservative trade failed: {escape(str(e))}",
                parse_mode=ParseMode.HTML
            )

        # === FINAL SUMMARY ===
        summary_msg = (
            f"\n{'‚ïê' * 30}\n"
            f"‚ö°+üõ°Ô∏è <b>DUAL TRADE EXECUTION COMPLETE</b>\n"
            f"{'‚ïê' * 30}\n\n"
        )

        # Fast trade summary
        if fast_result and isinstance(fast_result, dict) and fast_result.get("success"):
            summary_msg += f"‚ö° <b>Fast Trade:</b> ‚úÖ Success\n"
        else:
            summary_msg += f"‚ö° <b>Fast Trade:</b> ‚ùå Failed\n"

        # Conservative trade summary
        if conservative_result and isinstance(conservative_result, dict) and conservative_result.get("success"):
            summary_msg += f"üõ°Ô∏è <b>Conservative Trade:</b> ‚úÖ Success\n"
        else:
            summary_msg += f"üõ°Ô∏è <b>Conservative Trade:</b> ‚ùå Failed\n"

        # Calculate total margin used
        total_margin_used = fast_margin + conservative_margin

        summary_msg += (
            f"\nüìä <b>Total Margin Used:</b> ${format_decimal_or_na(total_margin_used, 2)} USDT\n"
        )

        # Show breakdown if using separate margins
        if "margin_amount_fast" in context.chat_data and "margin_amount_conservative" in context.chat_data:
            summary_msg += (
                f"   ‚ö° Fast: ${format_decimal_or_na(fast_margin, 2)} ({context.chat_data.get('margin_percentage_fast', 0)}%)\n"
                f"   üõ°Ô∏è Conservative: ${format_decimal_or_na(conservative_margin, 2)} ({context.chat_data.get('margin_percentage_conservative', 0)}%)\n"
            )

        summary_msg += (
            f"üîÑ <b>Monitoring:</b> Active for both positions\n"
            f"üõ°Ô∏è <b>Protection:</b> All orders protected from cleanup\n\n"
            f"üì± Returning to dashboard..."
        )

        await context.bot.send_message(
            chat_id,
            summary_msg,
            parse_mode=ParseMode.HTML
        )

        # Restore original chat_data state to prevent contamination
        context.chat_data[MARGIN_AMOUNT] = original_margin
        context.chat_data["margin_amount"] = original_margin
        context.chat_data["margin_amount_usdt"] = original_margin

        # Restore original approach and strategy if they existed
        if original_approach is not None:
            context.chat_data[TRADING_APPROACH] = original_approach
        elif TRADING_APPROACH in context.chat_data:
            del context.chat_data[TRADING_APPROACH]

        if original_strategy is not None:
            context.chat_data[ORDER_STRATEGY] = original_strategy
        elif ORDER_STRATEGY in context.chat_data:
            del context.chat_data[ORDER_STRATEGY]

    except Exception as e:
        logger.error(f"Error in dual trade execution: {e}", exc_info=True)

        # Restore original chat_data state even on error
        try:
            context.chat_data[MARGIN_AMOUNT] = original_margin
            context.chat_data["margin_amount"] = original_margin
            context.chat_data["margin_amount_usdt"] = original_margin

            if original_approach is not None:
                context.chat_data[TRADING_APPROACH] = original_approach
            elif TRADING_APPROACH in context.chat_data:
                del context.chat_data[TRADING_APPROACH]

            if original_strategy is not None:
                context.chat_data[ORDER_STRATEGY] = original_strategy
            elif ORDER_STRATEGY in context.chat_data:
                del context.chat_data[ORDER_STRATEGY]
        except:
            pass  # Don't let cleanup errors mask the original error

        await context.bot.send_message(
            chat_id,
            f"‚ùå <b>Dual Trade Execution Error</b>\n\n{escape(str(e))}",
            parse_mode=ParseMode.HTML
        )

    # Return to dashboard
    try:
        from handlers.commands import _send_or_edit_dashboard_message
        await _send_or_edit_dashboard_message(chat_id, context, new_msg=True)
    except:
        pass

    return ConversationHandler.END

# =============================================
# BACK HANDLER - NEW
# =============================================

async def handle_back_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle back button in conversation flow"""
    query = update.callback_query
    if not query or not query.data.startswith("conv_back:"):
        return

    try:
        await query.answer()
    except:
        pass

    # Get the target state
    target_state = int(query.data.split(":")[1])
    chat_id = query.message.chat.id

    # Determine what to do based on target state
    if target_state == SYMBOL:
        # Go back to symbol input
        symbol_msg = (
            f"{get_emoji('rocket')} <b>ENHANCED TRADE SETUP WITH GGSHOT</b>\n"
            f"{'‚ïê' * 50}\n\n"
            f"üí± <b>Step 1 of 8: Symbol Selection</b>\n\n"
            f"Enter the trading symbol (e.g., <code>BTCUSDT</code>):\n\n"
            f"üí° <b>Features:</b>\n"
            f"‚Ä¢ Fast Market or Conservative Limits\n"
            f"‚Ä¢ GGShot Screenshot AI Analysis\n"
            f"‚Ä¢ Advanced protection system\n"
            f"‚Ä¢ Mobile-optimized interface"
        )

        cancel_keyboard = build_conversation_keyboard(include_back=False, include_cancel=True)

        try:
            await query.edit_message_text(
                symbol_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=cancel_keyboard
            )
        except:
            await edit_last_message(context, chat_id, symbol_msg, cancel_keyboard)

        return SYMBOL

    elif target_state == SIDE:
        # Go back to side selection
        symbol = context.chat_data.get(SYMBOL, "Unknown")

        side_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n\n"
            f"üìà <b>Step 2 of 8: Trade Direction</b>\n\n"
            f"Choose your trading direction:"
        )

        side_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"üìà LONG (Buy)", callback_data="conv_side:Buy")],
            [InlineKeyboardButton(f"üìâ SHORT (Sell)", callback_data="conv_side:Sell")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SYMBOL}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                side_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=side_keyboard
            )
        except:
            await edit_last_message(context, chat_id, side_msg, side_keyboard)

        return SIDE

    elif target_state == APPROACH_SELECTION:
        # Go back to approach selection
        symbol = context.chat_data.get(SYMBOL, "Unknown")
        side = context.chat_data.get(SIDE, "Buy")
        direction_emoji = "üìà" if side == "Buy" else "üìâ"
        direction_text = "LONG" if side == "Buy" else "SHORT"

        approach_msg = (
            f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
            f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n\n"
            f"üéØ <b>Step 3 of 8: Trading Approach</b>\n\n"
            f"Choose your trading strategy:\n\n"
            f"‚ö° <b>Fast Market</b>\n"
            f"‚Ä¢ Single entry at market price\n"
            f"‚Ä¢ One take profit (100% close)\n"
            f"‚Ä¢ Best for quick moves\n\n"
            f"üõ°Ô∏è <b>Conservative Limits</b>\n"
            f"‚Ä¢ 3 limit orders (equal allocation)\n"
            f"‚Ä¢ 4 take profits (70%, 10%, 10%, 10%)\n"
            f"‚Ä¢ Better risk management\n\n"
            f"üì∏ <b>GGShot Screenshot</b>\n"
            f"‚Ä¢ Upload trading screenshot\n"
            f"‚Ä¢ AI extracts trade parameters\n"
            f"‚Ä¢ Auto-populate setup\n"
            f"‚Ä¢ Smart strategy detection\n\n"
            f"Select your preferred approach:"
        )

        approach_keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚ö° Fast Market", callback_data="conv_approach:fast")],
            [InlineKeyboardButton(f"üõ°Ô∏è Conservative Limits", callback_data="conv_approach:conservative")],
            [InlineKeyboardButton(f"üì∏ GGShot Screenshot", callback_data="conv_approach:ggshot")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"conv_back:{SIDE}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
        ])

        try:
            await query.edit_message_text(
                approach_msg,
                parse_mode=ParseMode.HTML,
                reply_markup=approach_keyboard
            )
        except:
            await edit_last_message(context, chat_id, approach_msg, approach_keyboard)

        context.chat_data[TRADING_APPROACH] = "conservative"
    return MARGIN

    # Add more states as needed...

    return ConversationHandler.END

# =============================================
# CANCEL HANDLER - UNCHANGED
# =============================================

async def cancel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle conversation cancellation"""
    if update.callback_query:
        query = update.callback_query
        try:
            await query.answer("‚ùå Trade setup cancelled")
        except:
            pass
        chat_id = query.message.chat.id
    else:
        chat_id = update.effective_chat.id

    logger.info(f"Conversation cancelled for chat {chat_id}")

    # Clear chat data
    if context.chat_data:
        # Keep monitor data but clear trade setup
        monitor_backup = context.chat_data.get(ACTIVE_MONITOR_TASK, {})
        context.chat_data.clear()
        initialize_chat_data(context.chat_data)
        context.chat_data[ACTIVE_MONITOR_TASK] = monitor_backup

    # Send cancellation message and return to dashboard
    try:
        await context.bot.send_message(
            chat_id,
            f"{get_emoji('cross_mark')} Trade setup cancelled.\n\nReturning to dashboard...",
            parse_mode=ParseMode.HTML
        )

        # Return to dashboard
        from handlers.commands import _send_or_edit_dashboard_message
        await _send_or_edit_dashboard_message(chat_id, context, new_msg=True)

    except Exception as e:
        logger.error(f"Error in cancel handler: {e}")

    return ConversationHandler.END

# =============================================
# GGSHOT EDIT HANDLERS
# =============================================

async def show_ggshot_edit_limits(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Show interface for editing limit orders with edit status indicators"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Get current limit prices
    limit1 = context.chat_data.get(LIMIT_ENTRY_1_PRICE, "Not Set")
    limit2 = context.chat_data.get(LIMIT_ENTRY_2_PRICE, "Not Set")
    limit3 = context.chat_data.get(LIMIT_ENTRY_3_PRICE, "Not Set")

    # Get edited fields
    edited_fields = context.chat_data.get("ggshot_edited_fields", set())

    # Build price display with edit indicators
    limit1_display = f"<code>{format_decimal_or_na(limit1)}</code>"
    if "limit_1" in edited_fields:
        limit1_display += " ‚úÖ <i>(edited)</i>"

    limit2_display = f"<code>{format_decimal_or_na(limit2)}</code>"
    if "limit_2" in edited_fields:
        limit2_display += " ‚úÖ <i>(edited)</i>"

    limit3_display = f"<code>{format_decimal_or_na(limit3)}</code>"
    if "limit_3" in edited_fields:
        limit3_display += " ‚úÖ <i>(edited)</i>"

    edit_msg = (
        f"üìù <b>Edit Limit Orders</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Current limit order prices:\n\n"
        f"‚Ä¢ Entry #1: {limit1_display}\n"
        f"‚Ä¢ Entry #2: {limit2_display}\n"
        f"‚Ä¢ Entry #3: {limit3_display}\n\n"
    )

    # Add instruction based on edit status
    if edited_fields:
        edit_msg += "üí° <i>Continue editing or click Done when finished</i>\n\n"
    else:
        edit_msg += "Select which limit order to edit:\n\n"

    # Build keyboard with edit status
    buttons = []

    # Add edit buttons with indicators
    btn1_text = "üìù Edit Entry #1" if "limit_1" not in edited_fields else "‚úèÔ∏è Edit Entry #1 (Modified)"
    btn2_text = "üìù Edit Entry #2" if "limit_2" not in edited_fields else "‚úèÔ∏è Edit Entry #2 (Modified)"
    btn3_text = "üìù Edit Entry #3" if "limit_3" not in edited_fields else "‚úèÔ∏è Edit Entry #3 (Modified)"

    buttons.extend([
        [InlineKeyboardButton(btn1_text, callback_data="ggshot_set_limit_1")],
        [InlineKeyboardButton(btn2_text, callback_data="ggshot_set_limit_2")],
        [InlineKeyboardButton(btn3_text, callback_data="ggshot_set_limit_3")]
    ])

    # Add Done button if any edits were made
    if any(f"limit_{i}" in edited_fields for i in range(1, 4)):
        buttons.append([InlineKeyboardButton("‚úÖ Done Editing", callback_data="ggshot_back_to_edit")])
    else:
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_back_to_edit")])

    keyboard = InlineKeyboardMarkup(buttons)

    await edit_last_message(context, chat_id, edit_msg, keyboard)
    return GGSHOT_EDIT_VALUES

async def show_ggshot_edit_tps(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Show interface for editing take profits with edit status indicators"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Get current TP prices
    tp1 = context.chat_data.get(TP1_PRICE, "Not Set")
    tp2 = context.chat_data.get(TP2_PRICE, "Not Set")
    tp3 = context.chat_data.get(TP3_PRICE, "Not Set")
    tp4 = context.chat_data.get(TP4_PRICE, "Not Set")

    # Get edited fields
    edited_fields = context.chat_data.get("ggshot_edited_fields", set())

    # Build price display with edit indicators
    tp1_display = f"<code>{format_decimal_or_na(tp1)}</code>"
    if "tp1" in edited_fields:
        tp1_display += " ‚úÖ <i>(edited)</i>"

    tp2_display = f"<code>{format_decimal_or_na(tp2)}</code>"
    if "tp2" in edited_fields:
        tp2_display += " ‚úÖ <i>(edited)</i>"

    tp3_display = f"<code>{format_decimal_or_na(tp3)}</code>"
    if "tp3" in edited_fields:
        tp3_display += " ‚úÖ <i>(edited)</i>"

    tp4_display = f"<code>{format_decimal_or_na(tp4)}</code>"
    if "tp4" in edited_fields:
        tp4_display += " ‚úÖ <i>(edited)</i>"

    edit_msg = (
        f"üéØ <b>Edit Take Profits</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Current take profit prices:\n\n"
        f"‚Ä¢ TP1 (70%): {tp1_display}\n"
        f"‚Ä¢ TP2 (10%): {tp2_display}\n"
        f"‚Ä¢ TP3 (10%): {tp3_display}\n"
        f"‚Ä¢ TP4 (10%): {tp4_display}\n\n"
    )

    # Add instruction based on edit status
    if edited_fields:
        edit_msg += "üí° <i>Continue editing or click Done when finished</i>\n\n"
    else:
        edit_msg += "Select which TP to edit:\n\n"

    # Build keyboard with edit status
    buttons = []

    # Add edit buttons with indicators
    btn1_text = "üéØ Edit TP1" if "tp1" not in edited_fields else "‚úèÔ∏è Edit TP1 (Modified)"
    btn2_text = "üéØ Edit TP2" if "tp2" not in edited_fields else "‚úèÔ∏è Edit TP2 (Modified)"
    btn3_text = "üéØ Edit TP3" if "tp3" not in edited_fields else "‚úèÔ∏è Edit TP3 (Modified)"
    btn4_text = "üéØ Edit TP4" if "tp4" not in edited_fields else "‚úèÔ∏è Edit TP4 (Modified)"

    buttons.extend([
        [InlineKeyboardButton(btn1_text, callback_data="ggshot_set_tp_1")],
        [InlineKeyboardButton(btn2_text, callback_data="ggshot_set_tp_2")],
        [InlineKeyboardButton(btn3_text, callback_data="ggshot_set_tp_3")],
        [InlineKeyboardButton(btn4_text, callback_data="ggshot_set_tp_4")]
    ])

    # Add Done button if any edits were made
    if any(f"tp{i}" in edited_fields for i in range(1, 5)):
        buttons.append([InlineKeyboardButton("‚úÖ Done Editing", callback_data="ggshot_back_to_edit")])
    else:
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_back_to_edit")])

    keyboard = InlineKeyboardMarkup(buttons)

    await edit_last_message(context, chat_id, edit_msg, keyboard)
    return GGSHOT_EDIT_VALUES

async def show_ggshot_edit_sl(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Show interface for editing stop loss"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Get current SL price
    sl = context.chat_data.get(SL_PRICE, "Not Set")

    edit_msg = (
        f"üõ°Ô∏è <b>Edit Stop Loss</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Current stop loss: <code>{format_decimal_or_na(sl)}</code>\n\n"
        f"Enter new stop loss price:"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_back_to_edit")]
    ])

    await edit_last_message(context, chat_id, edit_msg, keyboard)

    # Set state to expect SL input
    context.chat_data["ggshot_editing"] = "sl"
    return GGSHOT_EDIT_VALUES

async def show_ggshot_edit_entry(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Show interface for editing entry price (fast approach)"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Get current entry price
    entry = context.chat_data.get(PRIMARY_ENTRY_PRICE, "Not Set")

    edit_msg = (
        f"üí∞ <b>Edit Entry Price</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Current entry price: <code>{format_decimal_or_na(entry)}</code>\n\n"
        f"Enter new entry price:"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_back_to_edit")]
    ])

    await edit_last_message(context, chat_id, edit_msg, keyboard)

    # Set state to expect entry input
    context.chat_data["ggshot_editing"] = "entry"
    return GGSHOT_EDIT_VALUES

# Fast approach TP edit function removed - only conservative approach supported

async def handle_ggshot_set_limit(context: ContextTypes.DEFAULT_TYPE, chat_id: int, limit_num: str) -> int:
    """Handle setting a specific limit order price"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    edit_msg = (
        f"üìù <b>Edit Limit Entry #{limit_num}</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Enter new price for Limit Entry #{limit_num}:"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_edit_limits")]
    ])

    await edit_last_message(context, chat_id, edit_msg, keyboard)

    # Set state to expect limit input
    context.chat_data["ggshot_editing"] = f"limit_{limit_num}"
    return GGSHOT_EDIT_VALUES

async def handle_ggshot_set_tp(context: ContextTypes.DEFAULT_TYPE, chat_id: int, tp_num: str) -> int:
    """Handle setting a specific TP price"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    edit_msg = (
        f"üéØ <b>Edit Take Profit #{tp_num}</b>\n"
        f"{'‚ïê' * 25}\n\n"
        f"Symbol: <code>{symbol}</code> {'üìà' if side == 'Buy' else 'üìâ'} {side.upper()}\n\n"
        f"Enter new price for TP#{tp_num}:"
    )

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_edit_tps")]
    ])

    await edit_last_message(context, chat_id, edit_msg, keyboard)

    # Set state to expect TP input
    context.chat_data["ggshot_editing"] = f"tp_{tp_num}"
    return GGSHOT_EDIT_VALUES

async def handle_ggshot_confirm_all(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Handle confirmation of all edited values"""
    # Check if this is from the old flow (ggshot_confirm_ai renamed to ggshot_confirm_all)
    strategy_type = context.chat_data.get(ORDER_STRATEGY)

    # Determine strategy type if not set
    if strategy_type == STRATEGY_CONSERVATIVE_LIMITS or context.chat_data.get(LIMIT_ENTRY_1_PRICE):
        strategy_type = "conservative"
    else:
        strategy_type = "fast"

    # Now ask which approach to use
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")
    direction_emoji = "üìà" if side == "Buy" else "üìâ"
    direction_text = "LONG" if side == "Buy" else "SHORT"

    # Show approach selection
    approach_msg = (
        f"‚úÖ <b>Symbol:</b> <code>{symbol}</code> üõ°Ô∏è\n"
        f"‚úÖ <b>Direction:</b> {direction_emoji} {direction_text}\n"
        f"‚úÖ <b>AI Prices:</b> üì∏ Confirmed\n\n"
        f"üéØ <b>Choose Trading Approach</b>\n\n"
        f"Select how you want to execute this trade:\n\n"
        f"‚ö° <b>Fast Only</b>\n"
        f"‚Ä¢ Market order execution\n"
        f"‚Ä¢ Single TP (100%) + SL\n"
        f"‚Ä¢ Quick in/out trades\n\n"
        f"üõ°Ô∏è <b>Conservative Only</b>\n"
        f"‚Ä¢ 3 limit order entries\n"
        f"‚Ä¢ 4 TPs (70%/10%/10%/10%)\n"
        f"‚Ä¢ Gradual scaling strategy\n\n"
        f"‚ö°+üõ°Ô∏è <b>Both Approaches</b>\n"
        f"‚Ä¢ Opens 2 separate positions\n"
        f"‚Ä¢ Split margin between both\n"
        f"‚Ä¢ Best of both strategies"
    )

    approach_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ö° Fast Only", callback_data="ggshot_approach:fast")],
        [InlineKeyboardButton("üõ°Ô∏è Conservative Only", callback_data="ggshot_approach:conservative")],
        [InlineKeyboardButton("‚ö°+üõ°Ô∏è Both Approaches", callback_data="ggshot_approach:both")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ggshot_back_to_edit")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="cancel_conversation")]
    ])

    await edit_last_message(context, chat_id, approach_msg, approach_keyboard)
    return CONFIRMATION

async def ggshot_edit_value_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle text input when editing GGShot values"""
    if not update.message or not update.message.text:
        return GGSHOT_EDIT_VALUES

    chat_id = update.effective_chat.id
    editing_field = context.chat_data.get("ggshot_editing")

    if not editing_field:
        # Not in edit mode, ignore
        return GGSHOT_EDIT_VALUES

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse the new value
        new_value = Decimal(update.message.text.strip())
        if new_value <= 0:
            await send_error_and_retry(
                context, chat_id,
                "Price must be greater than 0. Please enter a valid price:",
                GGSHOT_EDIT_VALUES
            )
            return GGSHOT_EDIT_VALUES

        # Initialize edited fields set if not exists
        if "ggshot_edited_fields" not in context.chat_data:
            context.chat_data["ggshot_edited_fields"] = set()

        # Update the appropriate field based on what we're editing
        if editing_field == "sl":
            context.chat_data[SL_PRICE] = new_value
            context.chat_data["ggshot_edited_fields"].add("sl")
        elif editing_field == "entry":
            context.chat_data[PRIMARY_ENTRY_PRICE] = new_value
            context.chat_data["ggshot_edited_fields"].add("entry")
        elif editing_field == "tp_fast":
            context.chat_data[TP1_PRICE] = new_value
            context.chat_data["ggshot_edited_fields"].add("tp1")
        elif editing_field.startswith("limit_"):
            limit_num = editing_field.split("_")[1]
            if limit_num == "1":
                context.chat_data[LIMIT_ENTRY_1_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("limit_1")
            elif limit_num == "2":
                context.chat_data[LIMIT_ENTRY_2_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("limit_2")
            elif limit_num == "3":
                context.chat_data[LIMIT_ENTRY_3_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("limit_3")
        elif editing_field.startswith("tp_"):
            tp_num = editing_field.split("_")[1]
            if tp_num == "1":
                context.chat_data[TP1_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("tp1")
            elif tp_num == "2":
                context.chat_data[TP2_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("tp2")
            elif tp_num == "3":
                context.chat_data[TP3_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("tp3")
            elif tp_num == "4":
                context.chat_data[TP4_PRICE] = new_value
                context.chat_data["ggshot_edited_fields"].add("tp4")

        # Clear editing state
        context.chat_data.pop("ggshot_editing", None)

        # Determine where to return based on what was edited
        if editing_field.startswith("limit_"):
            # Return to limit orders edit screen
            return await show_ggshot_edit_limits(context, chat_id)
        elif editing_field.startswith("tp_") and editing_field != "tp_fast":
            # Return to take profits edit screen
            return await show_ggshot_edit_tps(context, chat_id)
        else:
            # For SL, entry price, or fast TP, return to main confirmation
            strategy_type = "conservative" if context.chat_data.get(LIMIT_ENTRY_1_PRICE) else "fast"
            return await show_extracted_parameters_confirmation(context, chat_id,
                {"success": True, "parameters": context.chat_data, "strategy_type": strategy_type})

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid number for the price:",
            GGSHOT_EDIT_VALUES
        )
        return GGSHOT_EDIT_VALUES

# =============================================
# STREAMLINED GGSHOT FLOW FUNCTIONS
# =============================================

async def start_ggshot_limit_flow(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Start streamlined limit order flow for GGShot"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Initialize limit flow tracking
    context.chat_data["ggshot_limit_flow_active"] = True
    context.chat_data["ggshot_current_limit"] = 1

    # Get current limit 1 price
    current_limit_1 = context.chat_data.get(LIMIT_ENTRY_1_PRICE, None)

    limit_msg = (
        f"üìä <b>Edit Limit Orders - Streamlined Flow</b>\n"
        f"Symbol: {symbol} | Side: {side}\n\n"
        f"üéØ <b>Limit Order 1 of 3</b>\n\n"
    )

    if current_limit_1:
        limit_msg += f"Current value: <code>{format_price(current_limit_1)}</code>\n\n"

    limit_msg += (
        f"Enter the price for <b>Limit Order 1</b>:\n"
        f"üí° This will be your first entry point"
    )

    # Create keyboard with cancel option
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
    ])

    await edit_last_message(context, chat_id, limit_msg, keyboard)

    # Set state to expect limit 1 input
    context.chat_data["ggshot_limit_flow_expecting"] = "limit_1"

    return GGSHOT_LIMIT_FLOW_1

async def handle_ggshot_limit_1_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle limit 1 input and move to limit 2"""
    if not update.message or not update.message.text:
        return GGSHOT_LIMIT_FLOW_1

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store limit 1 price
        context.chat_data[LIMIT_ENTRY_1_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("limit_1")

        # Move to limit 2
        context.chat_data["ggshot_current_limit"] = 2
        current_limit_2 = context.chat_data.get(LIMIT_ENTRY_2_PRICE, None)

        limit_msg = (
            f"üìä <b>Edit Limit Orders - Streamlined Flow</b>\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"‚úÖ Limit 1: <code>{format_price(new_price)}</code>\n\n"
            f"üéØ <b>Limit Order 2 of 3</b>\n\n"
        )

        if current_limit_2:
            limit_msg += f"Current value: <code>{format_price(current_limit_2)}</code>\n\n"

        limit_msg += (
            f"Enter the price for <b>Limit Order 2</b>:\n"
            f"üí° This will be your second entry point"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back to Limit 1", callback_data="ggshot_limit_back:1")],
            [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, limit_msg, keyboard)

        # Set state to expect limit 2 input
        context.chat_data["ggshot_limit_flow_expecting"] = "limit_2"

        return GGSHOT_LIMIT_FLOW_2

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for Limit Order 1:",
            GGSHOT_LIMIT_FLOW_1
        )
        return GGSHOT_LIMIT_FLOW_1

async def handle_ggshot_limit_2_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle limit 2 input and move to limit 3"""
    if not update.message or not update.message.text:
        return GGSHOT_LIMIT_FLOW_2

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store limit 2 price
        context.chat_data[LIMIT_ENTRY_2_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("limit_2")

        # Move to limit 3
        context.chat_data["ggshot_current_limit"] = 3
        current_limit_3 = context.chat_data.get(LIMIT_ENTRY_3_PRICE, None)

        limit_msg = (
            f"üìä <b>Edit Limit Orders - Streamlined Flow</b>\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"‚úÖ Limit 1: <code>{format_price(context.chat_data.get(LIMIT_ENTRY_1_PRICE))}</code>\n"
            f"‚úÖ Limit 2: <code>{format_price(new_price)}</code>\n\n"
            f"üéØ <b>Limit Order 3 of 3</b>\n\n"
        )

        if current_limit_3:
            limit_msg += f"Current value: <code>{format_price(current_limit_3)}</code>\n\n"

        limit_msg += (
            f"Enter the price for <b>Limit Order 3</b>:\n"
            f"üí° This will be your third entry point"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back to Limit 2", callback_data="ggshot_limit_back:2")],
            [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, limit_msg, keyboard)

        # Set state to expect limit 3 input
        context.chat_data["ggshot_limit_flow_expecting"] = "limit_3"

        return GGSHOT_LIMIT_FLOW_3

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for Limit Order 2:",
            GGSHOT_LIMIT_FLOW_2
        )
        return GGSHOT_LIMIT_FLOW_2

async def handle_ggshot_limit_3_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle limit 3 input and show confirmation"""
    if not update.message or not update.message.text:
        return GGSHOT_LIMIT_FLOW_3

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store limit 3 price
        context.chat_data[LIMIT_ENTRY_3_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("limit_3")

        # Clear flow tracking
        context.chat_data["ggshot_limit_flow_active"] = False
        context.chat_data.pop("ggshot_limit_flow_expecting", None)

        # Show confirmation of all limit orders
        limit_msg = (
            f"‚úÖ <b>Limit Orders Updated Successfully!</b>\n\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"üìä <b>Your Limit Orders:</b>\n"
            f"‚Ä¢ Limit 1: <code>{format_price(context.chat_data.get(LIMIT_ENTRY_1_PRICE))}</code>\n"
            f"‚Ä¢ Limit 2: <code>{format_price(context.chat_data.get(LIMIT_ENTRY_2_PRICE))}</code>\n"
            f"‚Ä¢ Limit 3: <code>{format_price(new_price)}</code>\n\n"
            f"What would you like to do next?"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üìä Edit Take Profits", callback_data="ggshot_edit_tps")],
            [InlineKeyboardButton("üõ°Ô∏è Edit Stop Loss", callback_data="ggshot_edit_sl")],
            [InlineKeyboardButton("‚úÖ Confirm All Changes", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, limit_msg, keyboard)

        return CONFIRMATION

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for Limit Order 3:",
            GGSHOT_LIMIT_FLOW_3
        )
        return GGSHOT_LIMIT_FLOW_3

async def start_ggshot_tp_flow(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> int:
    """Start streamlined take profit flow for GGShot"""
    symbol = context.chat_data.get(SYMBOL, "Unknown")
    side = context.chat_data.get(SIDE, "Buy")

    # Initialize TP flow tracking
    context.chat_data["ggshot_tp_flow_active"] = True
    context.chat_data["ggshot_current_tp"] = 1

    # Get current TP 1 price
    current_tp_1 = context.chat_data.get(TP1_PRICE, None)

    tp_msg = (
        f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
        f"Symbol: {symbol} | Side: {side}\n\n"
        f"üéØ <b>Take Profit 1 of 4 (85%)</b>\n\n"
    )

    if current_tp_1:
        tp_msg += f"Current value: <code>{format_price(current_tp_1)}</code>\n\n"

    tp_msg += (
        f"Enter the price for <b>TP1 (85% of position)</b>:\n"
        f"üí° This is your main profit target"
    )

    # Create keyboard with cancel option
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
    ])

    await edit_last_message(context, chat_id, tp_msg, keyboard)

    # Set state to expect TP 1 input
    context.chat_data["ggshot_tp_flow_expecting"] = "tp_1"

    return GGSHOT_TP_FLOW_1

async def handle_ggshot_tp_1_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle TP1 input and move to TP2"""
    if not update.message or not update.message.text:
        return GGSHOT_TP_FLOW_1

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store TP1 price
        context.chat_data[TP1_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("tp1")

        # Move to TP2
        context.chat_data["ggshot_current_tp"] = 2
        current_tp_2 = context.chat_data.get(TP2_PRICE, None)

        tp_msg = (
            f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"‚úÖ TP1 (85%): <code>{format_price(new_price)}</code>\n\n"
            f"üéØ <b>Take Profit 2 of 4 (5%)</b>\n\n"
        )

        if current_tp_2:
            tp_msg += f"Current value: <code>{format_price(current_tp_2)}</code>\n\n"

        tp_msg += (
            f"Enter the price for <b>TP2 (5% of position)</b>:\n"
            f"üí° This is your second profit target"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP1", callback_data="ggshot_tp_back:1")],
            [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, tp_msg, keyboard)

        # Set state to expect TP2 input
        context.chat_data["ggshot_tp_flow_expecting"] = "tp_2"

        return GGSHOT_TP_FLOW_2

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for TP1:",
            GGSHOT_TP_FLOW_1
        )
        return GGSHOT_TP_FLOW_1

async def handle_ggshot_tp_2_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle TP2 input and move to TP3"""
    if not update.message or not update.message.text:
        return GGSHOT_TP_FLOW_2

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store TP2 price
        context.chat_data[TP2_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("tp2")

        # Move to TP3
        context.chat_data["ggshot_current_tp"] = 3
        current_tp_3 = context.chat_data.get(TP3_PRICE, None)

        tp_msg = (
            f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"‚úÖ TP1 (85%): <code>{format_price(context.chat_data.get(TP1_PRICE))}</code>\n"
            f"‚úÖ TP2 (5%): <code>{format_price(new_price)}</code>\n\n"
            f"üéØ <b>Take Profit 3 of 4 (5%)</b>\n\n"
        )

        if current_tp_3:
            tp_msg += f"Current value: <code>{format_price(current_tp_3)}</code>\n\n"

        tp_msg += (
            f"Enter the price for <b>TP3 (5% of position)</b>:\n"
            f"üí° This is your third profit target"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP2", callback_data="ggshot_tp_back:2")],
            [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, tp_msg, keyboard)

        # Set state to expect TP3 input
        context.chat_data["ggshot_tp_flow_expecting"] = "tp_3"

        return GGSHOT_TP_FLOW_3

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for TP2:",
            GGSHOT_TP_FLOW_2
        )
        return GGSHOT_TP_FLOW_2

async def handle_ggshot_tp_3_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle TP3 input and move to TP4"""
    if not update.message or not update.message.text:
        return GGSHOT_TP_FLOW_3

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store TP3 price
        context.chat_data[TP3_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("tp3")

        # Move to TP4
        context.chat_data["ggshot_current_tp"] = 4
        current_tp_4 = context.chat_data.get(TP4_PRICE, None)

        tp_msg = (
            f"üìä <b>Edit Take Profits - Streamlined Flow</b>\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"‚úÖ TP1 (85%): <code>{format_price(context.chat_data.get(TP1_PRICE))}</code>\n"
            f"‚úÖ TP2 (5%): <code>{format_price(context.chat_data.get(TP2_PRICE))}</code>\n"
            f"‚úÖ TP3 (5%): <code>{format_price(new_price)}</code>\n\n"
            f"üéØ <b>Take Profit 4 of 4 (5%)</b>\n\n"
        )

        if current_tp_4:
            tp_msg += f"Current value: <code>{format_price(current_tp_4)}</code>\n\n"

        tp_msg += (
            f"Enter the price for <b>TP4 (5% of position)</b>:\n"
            f"üí° This is your final profit target"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP3", callback_data="ggshot_tp_back:3")],
            [InlineKeyboardButton("‚ùå Cancel Edit", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, tp_msg, keyboard)

        # Set state to expect TP4 input
        context.chat_data["ggshot_tp_flow_expecting"] = "tp_4"

        return GGSHOT_TP_FLOW_4

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for TP3:",
            GGSHOT_TP_FLOW_3
        )
        return GGSHOT_TP_FLOW_3

async def handle_ggshot_tp_4_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle TP4 input and show confirmation"""
    if not update.message or not update.message.text:
        return GGSHOT_TP_FLOW_4

    chat_id = update.effective_chat.id

    # Delete user's message
    try:
        await update.message.delete()
    except:
        pass

    try:
        # Parse and validate the price
        new_price = Decimal(update.message.text.strip())
        if new_price <= 0:
            raise ValueError("Price must be positive")

        # Store TP4 price
        context.chat_data[TP4_PRICE] = new_price
        context.chat_data.setdefault("ggshot_edited_fields", set()).add("tp4")

        # Clear flow tracking
        context.chat_data["ggshot_tp_flow_active"] = False
        context.chat_data.pop("ggshot_tp_flow_expecting", None)

        # Show confirmation of all TPs
        tp_msg = (
            f"‚úÖ <b>Take Profits Updated Successfully!</b>\n\n"
            f"Symbol: {context.chat_data.get(SYMBOL, 'Unknown')} | Side: {context.chat_data.get(SIDE, 'Buy')}\n\n"
            f"üìä <b>Your Take Profits:</b>\n"
            f"‚Ä¢ TP1 (85%): <code>{format_price(context.chat_data.get(TP1_PRICE))}</code>\n"
            f"‚Ä¢ TP2 (5%): <code>{format_price(context.chat_data.get(TP2_PRICE))}</code>\n"
            f"‚Ä¢ TP3 (5%): <code>{format_price(context.chat_data.get(TP3_PRICE))}</code>\n"
            f"‚Ä¢ TP4 (5%): <code>{format_price(new_price)}</code>\n\n"
            f"What would you like to do next?"
        )

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üìä Edit Limit Orders", callback_data="ggshot_edit_limits")],
            [InlineKeyboardButton("üõ°Ô∏è Edit Stop Loss", callback_data="ggshot_edit_sl")],
            [InlineKeyboardButton("‚úÖ Confirm All Changes", callback_data="ggshot_back_to_edit")]
        ])

        await edit_last_message(context, chat_id, tp_msg, keyboard)

        return CONFIRMATION

    except (ValueError, InvalidOperation):
        await send_error_and_retry(
            context, chat_id,
            "Please enter a valid price for TP4:",
            GGSHOT_TP_FLOW_4
        )
        return GGSHOT_TP_FLOW_4

# =============================================
# UTILITY FUNCTIONS - UNCHANGED
# =============================================

async def edit_last_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int, text: str, keyboard):
    """Edit the last UI message"""
    msg_id = context.chat_data.get(LAST_UI_MESSAGE_ID)
    if msg_id:
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=msg_id,
                text=text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )
            return
        except Exception as e:
            logger.warning(f"Error editing message {msg_id}: {e}")

    # If edit fails or no message ID, send new message
    try:
        sent = await context.bot.send_message(
            chat_id, text, parse_mode=ParseMode.HTML, reply_markup=keyboard
        )
        context.chat_data[LAST_UI_MESSAGE_ID] = sent.message_id
    except Exception as e:
        logger.error(f"Error sending new message: {e}")

async def send_error_and_retry(context: ContextTypes.DEFAULT_TYPE, chat_id: int, error_msg: str, return_state: int):
    """Send error message and allow retry"""
    error_keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå Cancel Setup", callback_data="cancel_conversation")]
    ])

    # Escape HTML special characters in error message
    safe_error_msg = escape(error_msg) if error_msg else "Unknown error"
    await edit_last_message(context, chat_id, f"‚ùå {safe_error_msg}", error_keyboard)