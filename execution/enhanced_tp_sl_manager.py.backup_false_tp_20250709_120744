#!/usr/bin/env python3
"""
Enhanced TP/SL Manager - Implements Cornix-style monitoring with dynamic order management
Replaces conditional orders with active monitoring and smart order placement
"""
import asyncio
import logging
from decimal import Decimal
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
import time

from config.constants import *
from config.settings import (
    CANCEL_LIMITS_ON_TP1, DYNAMIC_FEE_CALCULATION, BREAKEVEN_SAFETY_MARGIN,
    ENHANCED_FILL_DETECTION, ADAPTIVE_MONITORING_INTERVALS,
    BREAKEVEN_FAILSAFE_ENABLED, BREAKEVEN_MAX_RETRIES, BREAKEVEN_EMERGENCY_SL_OFFSET,
    BREAKEVEN_VERIFICATION_INTERVAL, BREAKEVEN_PREFER_AMEND, BREAKEVEN_ENABLE_PROGRESSIVE_RETRY,
    BREAKEVEN_ENABLE_EMERGENCY_MODE, BREAKEVEN_ALERT_FAILURES
)
from clients.bybit_helpers import (
    place_order_with_retry, cancel_order_with_retry,
    get_position_info, get_position_info_for_account, get_open_orders, amend_order_with_retry,
    get_correct_position_idx, get_current_price, get_instrument_info
)
from utils.helpers import value_adjusted_to_step
from utils.order_identifier import generate_order_link_id, generate_adjusted_order_link_id, ORDER_TYPE_TP, ORDER_TYPE_SL
from utils.alert_helpers import send_simple_alert as send_trade_alert, send_position_closed_summary

logger = logging.getLogger(__name__)

# Import failsafe system if enabled
if BREAKEVEN_FAILSAFE_ENABLED:
    try:
        from execution.breakeven_failsafe import breakeven_failsafe
        logger.info("‚úÖ Breakeven failsafe system enabled")
    except ImportError as e:
        logger.warning(f"‚ö†Ô∏è Could not import breakeven failsafe system: {e}")
        BREAKEVEN_FAILSAFE_ENABLED = False
else:
    logger.info("‚ÑπÔ∏è Breakeven failsafe system disabled")

class EnhancedTPSLManager:
    """
    Manages TP/SL orders using active monitoring instead of conditional orders
    Features:
    - Multiple partial TP orders (no conditionals)
    - Dynamic SL adjustment based on filled TPs
    - OCO logic implemented programmatically
    - Price monitoring for optimal execution
    """

    def __init__(self):
        self.position_monitors = {}  # symbol -> monitor data
        self.order_state = {}  # symbol -> order state tracking
        self.price_cache = {}  # symbol -> (price, timestamp)
        self.price_cache_ttl = 5  # seconds

        # Enhanced order lifecycle tracking
        self.order_lifecycle = {}  # order_id -> comprehensive lifecycle data
        self.order_relationships = {}  # symbol_side -> order relationship map
        self.execution_metrics = {}  # symbol_side -> execution performance metrics

        # Enhanced fill tracking for accurate percentage calculations
        self.fill_tracker = {}  # symbol_side -> cumulative fill data
        self.actual_entry_prices = {}  # symbol_side -> weighted average entry price
        self.fee_rates_cache = {}  # account tier fee cache

        # Atomic operation locks for race condition prevention
        self.breakeven_locks = {}  # symbol_side -> asyncio.Lock
        self.monitor_locks = {}  # symbol_side -> asyncio.Lock
        self.phase_transition_locks = {}  # symbol_side -> asyncio.Lock

        # Enhanced monitoring intervals
        self.standard_monitor_interval = 12  # Standard monitoring
        self.active_position_interval = 5   # Active positions with pending TPs
        self.critical_position_interval = 2  # Positions near breakeven triggers

        # Cleanup scheduler
        self.cleanup_task = None
        self.cleanup_interval = 3600  # 1 hour
        self.last_cleanup = 0

        # Error recovery and resilience
        self.error_recovery_enabled = True
        self.max_recovery_attempts = 3
        self.recovery_backoff_multiplier = 2.0
        self.failed_operations = {}  # operation_id -> failure data
        self.circuit_breaker_state = {}  # symbol_side -> circuit breaker state

        # Mirror account support
        self._mirror_client = None
        self._init_mirror_support()

    def _ensure_tp_orders_dict(self, monitor_data: Dict):
        """Ensure tp_orders is in dict format for backward compatibility"""
        tp_orders = monitor_data.get("tp_orders", {})
        if isinstance(tp_orders, list):
            # Convert list to dict using order_id as key
            tp_dict = {}
            for order in tp_orders:
                if isinstance(order, dict) and "order_id" in order:
                    tp_dict[order["order_id"]] = order
            monitor_data["tp_orders"] = tp_dict
            return tp_dict
        return tp_orders

        # Mirror sync state tracking
        self.mirror_sync_locks = {}  # symbol_side -> asyncio.Lock


    def save_monitors_to_persistence(self):
        """Save all monitors to persistence file"""
        try:
            import copy
            from utils.pickle_lock import main_pickle_lock

            # Create a deep copy of monitors and remove non-serializable objects
            clean_monitors = {}
            for key, monitor in self.position_monitors.items():
                # Deep copy to avoid modifying original
                clean_monitor = copy.deepcopy(monitor)

                # Remove any asyncio tasks or other non-serializable objects
                if 'monitor_task' in clean_monitor:
                    del clean_monitor['monitor_task']
                if 'cleanup_task' in clean_monitor:
                    del clean_monitor['cleanup_task']
                if '_lock' in clean_monitor:
                    del clean_monitor['_lock']

                # Remove any other Task objects that might be nested
                for field_key in list(clean_monitor.keys()):
                    if 'task' in field_key.lower() or '_lock' in field_key:
                        del clean_monitor[field_key]

                clean_monitors[key] = clean_monitor

            # Use safe update with file locking
            def update_monitors(data):
                if 'bot_data' not in data:
                    data['bot_data'] = {}
                data['bot_data']['enhanced_tp_sl_monitors'] = clean_monitors

            success = main_pickle_lock.update_data(update_monitors)

            if success:
                logger.debug(f"Saved {len(clean_monitors)} monitors to persistence")
            else:
                logger.error("Failed to save monitors to persistence")

        except Exception as e:
            logger.error(f"Error saving monitors to persistence: {e}")

    def _init_mirror_support(self):
        """Initialize mirror trading support if available"""
        try:
            from execution.mirror_trader import bybit_client_2, is_mirror_trading_enabled
            if is_mirror_trading_enabled() and bybit_client_2:
                self._mirror_client = bybit_client_2
                logger.info("‚úÖ Mirror account support enabled for Enhanced TP/SL")
            else:
                logger.info("‚ÑπÔ∏è Mirror trading disabled or not configured")
        except ImportError:
            logger.info("‚ÑπÔ∏è Mirror trading module not available")

    def _sanitize_monitor_data(self, monitor_data: Dict) -> Dict:
        """
        Ensure all numeric fields in monitor data are Decimal types
        This prevents type mismatch errors when loading from persistence
        """
        # List of fields that should be Decimal
        decimal_fields = [
            "entry_price", "position_size", "current_size", "remaining_size",
            "sl_moved_to_be_price", "original_sl_price", "avg_partial_fill_price",
            "last_limit_fill_size", "cumulative_fill_size"
        ]

        # Convert each field to Decimal if it exists
        for field in decimal_fields:
            if field in monitor_data and monitor_data[field] is not None:
                try:
                    monitor_data[field] = Decimal(str(monitor_data[field]))
                except (InvalidOperation, ValueError) as e:
                    logger.warning(f"Could not convert {field}={monitor_data[field]} to Decimal: {e}")
                    # Set to 0 as a safe default
                    monitor_data[field] = Decimal("0")

        # Also sanitize nested structures
        if "fill_tracker" in monitor_data and isinstance(monitor_data["fill_tracker"], dict):
            for key, value in monitor_data["fill_tracker"].items():
                if isinstance(value, (int, float, str)) and key in ["total_filled", "target_size"]:
                    try:
                        monitor_data["fill_tracker"][key] = Decimal(str(value))
                    except (InvalidOperation, ValueError):
                        monitor_data["fill_tracker"][key] = Decimal("0")

        # Sanitize limit_orders - convert string list to dict list
        if "limit_orders" in monitor_data:
            sanitized_limit_orders = []
            for order in monitor_data.get("limit_orders", []):
                if isinstance(order, str):
                    # Convert string order ID to dict format
                    sanitized_limit_orders.append({
                        "order_id": order,
                        "status": "ACTIVE",
                        "registered_at": time.time()
                    })
                elif isinstance(order, dict):
                    # Already in correct format
                    sanitized_limit_orders.append(order)
            monitor_data["limit_orders"] = sanitized_limit_orders

        return monitor_data

    def _is_mirror_position(self, monitor_data: Dict) -> bool:
        """
        Determine if a position belongs to the mirror account
        Uses multiple detection methods for robust identification
        """
        # Method 1: Check explicit account_type field (preferred)
        account_type = monitor_data.get("account_type")
        if account_type:
            return account_type == "mirror"

        # Method 2: Check if this is the mirror enhanced TP/SL manager instance
        if hasattr(self, '__class__') and 'Mirror' in self.__class__.__name__:
            return True

        # Method 3: Check monitor key pattern for mirror suffix
        symbol = monitor_data.get("symbol", "")
        side = monitor_data.get("side", "")
        # Support account-aware keys
        if account_type:
            monitor_key = f"{symbol}_{side}_{account_type}"
        else:
            # Try to find the right key
            main_key = f"{symbol}_{side}_main"
            mirror_key = f"{symbol}_{side}_mirror"
            legacy_key = f"{symbol}_{side}"

            if main_key in self.position_monitors:
                monitor_key = main_key
            elif mirror_key in self.position_monitors:
                monitor_key = mirror_key
            else:
                monitor_key = legacy_key

        # Check if this key is tracked in mirror monitors
        if hasattr(self, '_mirror_monitors') and monitor_key in getattr(self, '_mirror_monitors', {}):
            return True

        # Method 4: Use order IDs to detect mirror account orders
        # Mirror orders may have different patterns or be tracked separately
        limit_orders = monitor_data.get("limit_orders", [])
        if limit_orders and self._mirror_client:
            # If we can't determine from metadata, default to main account
            # This is a conservative approach to avoid cross-account cancellation errors
            pass

        # Method 5: Fallback - check global bot_data for account context
        # This would require access to bot_data, which we don't have here

        # Default: assume main account unless explicitly marked as mirror
        # This prevents accidental cross-account operations
        return False

    def _get_cancel_function(self, is_mirror_account: bool):
        """Get the appropriate cancel function based on account type"""
        if is_mirror_account and self._mirror_client:
            return self._cancel_order_mirror
        else:
            return self._cancel_order_main

    def _get_place_order_function(self, is_mirror_account: bool):
        """Get the appropriate place order function based on account type"""
        if is_mirror_account and self._mirror_client:
            return self._place_order_mirror
        else:
            return self._place_order_main

    async def _cancel_order_main(self, symbol: str, order_id: str) -> bool:
        """Cancel order on main account"""
        return await cancel_order_with_retry(symbol, order_id)

    async def _cancel_order_mirror(self, symbol: str, order_id: str) -> bool:
        """Cancel order on mirror account"""
        try:
            # Use mirror client for cancellation
            if not self._mirror_client:
                logger.error("‚ùå Mirror client not available for order cancellation")
                return False

            # Import the mirror cancellation function
            from clients.bybit_helpers import api_call_with_retry

            logger.info(f"üîÑ Attempting to cancel mirror order {order_id[:8]}... for {symbol}")

            response = await api_call_with_retry(
                lambda: self._mirror_client.cancel_order(
                    category="linear",
                    symbol=symbol,
                    orderId=order_id
                )
            )

            if response and response.get("retCode") == 0:
                logger.info(f"‚úÖ Mirror order {order_id[:8]}... cancelled successfully")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Failed to cancel mirror order {order_id[:8]}...: {response}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Error cancelling mirror order {order_id[:8]}...: {e}")
            return False

    async def _place_order_main(self, **order_params) -> Dict:
        """Place order on main account"""
        return await place_order_with_retry(**order_params)

    async def _place_order_mirror(self, **order_params) -> Dict:
        """Place order on mirror account"""
        try:
            # Use mirror client for order placement
            if not self._mirror_client:
                logger.error("‚ùå Mirror client not available for order placement")
                return {}

            from clients.bybit_helpers import api_call_with_retry

            # Remove any client parameter if present and use mirror client
            order_params.pop('client', None)

            logger.info(f"üîÑ Placing mirror order: {order_params.get('symbol')} {order_params.get('side')} {order_params.get('orderType')}")

            response = await api_call_with_retry(
                lambda: self._mirror_client.place_order(**order_params)
            )

            if response and response.get("retCode") == 0:
                result = response.get("result", {})
                logger.info(f"‚úÖ Mirror order placed successfully: {result.get('orderId', '')[:8]}...")
                return result
            else:
                logger.warning(f"‚ö†Ô∏è Failed to place mirror order: {response}")
                return {}

        except Exception as e:
            logger.error(f"‚ùå Error placing mirror order: {e}")
            return {}

    async def _cancel_live_limit_orders(self, symbol: str, side: str, is_mirror_account: bool) -> int:
        """
        Scan live orders and cancel bot limit orders for the specified position
        This is a fallback when monitor data doesn't track orders properly
        """
        try:
            # Get live orders from the appropriate account
            if is_mirror_account and self._mirror_client:
                from clients.bybit_helpers import api_call_with_retry
                response = await api_call_with_retry(
                    lambda: self._mirror_client.get_open_orders(
                        category="linear",
                        symbol=symbol
                    )
                )
            else:
                from clients.bybit_helpers import get_all_open_orders
                all_orders = await get_all_open_orders()
                response = {"result": {"list": [o for o in all_orders if o.get('symbol') == symbol]}}

            if not response or response.get("retCode") != 0:
                logger.warning(f"Failed to get live orders for {symbol}")
                return 0

            orders = response.get("result", {}).get("list", [])
            cancelled_count = 0

            # Filter for bot limit orders that match the position
            for order in orders:
                order_id = order.get("orderId", "")
                order_link_id = order.get("orderLinkId", "")
                order_side = order.get("side", "")
                order_type = order.get("orderType", "")

                # Check if this is a bot limit order for the matching side
                if (order_type == "Limit" and
                    order_side == side and
                    order_link_id.startswith("BOT_") and
                    "LIMIT" in order_link_id.upper()):

                    logger.info(f"üéØ Found bot limit order to cancel: {order_id[:8]}... ({order_link_id})")

                    try:
                        if is_mirror_account:
                            success = await self._cancel_order_mirror(symbol, order_id)
                        else:
                            success = await self._cancel_order_main(symbol, order_id)

                        if success:
                            cancelled_count += 1
                            logger.info(f"‚úÖ Cancelled live limit order {order_id[:8]}...")
                        else:
                            logger.warning(f"‚ö†Ô∏è Failed to cancel live limit order {order_id[:8]}...")

                    except Exception as e:
                        logger.error(f"‚ùå Error cancelling live limit order {order_id[:8]}...: {e}")

            if cancelled_count > 0:
                logger.info(f"üì° Live order scan: {cancelled_count} bot limit orders cancelled")
            else:
                logger.info(f"üì° Live order scan: No bot limit orders found to cancel")

            return cancelled_count

        except Exception as e:
            logger.error(f"‚ùå Error scanning live orders for {symbol} {side}: {e}")
            return 0

    async def setup_tp_sl_orders(
        self,
        symbol: str,
        side: str,
        position_size: Decimal,
        entry_price: Decimal,
        tp_prices: List[Decimal],
        tp_percentages: List[Decimal],
        sl_price: Decimal,
        chat_id: int,
        approach: str = "CONSERVATIVE",
        qty_step: Decimal = Decimal("0.001"),
        initial_position_size: Decimal = None,  # Actual filled position size
        account_type: str = "main",  # ENHANCED: Support both "main" and "mirror" accounts
        mirror_position_size: Decimal = None,  # ENHANCED: Mirror position size (can be different)
        mirror_target_size: Decimal = None     # ENHANCED: Mirror target size for proportional trading
    ) -> Dict[str, Any]:
        """
        ENHANCED: Set up TP/SL orders using the enhanced system for BOTH main and mirror accounts

        Args:
            symbol: Trading symbol
            side: Buy or Sell
            position_size: Total position size (main account)
            entry_price: Entry price of position
            tp_prices: List of TP target prices
            tp_percentages: List of percentages for each TP (must sum to 100)
            sl_price: Stop loss price
            chat_id: Telegram chat ID
            approach: Trading approach (CONSERVATIVE/FAST)
            qty_step: Quantity step for the symbol
            initial_position_size: Actual filled position size (main account)
            account_type: "main", "mirror", or "both" for unified setup
            mirror_position_size: Position size for mirror account (can be different for proportional trading)
            mirror_target_size: Target size for mirror account

        Returns:
            Dict with setup results and order IDs for both accounts
        """
        try:
            logger.info(f"üéØ ENHANCED UNIFIED TP/SL setup for {symbol} {side} ({account_type})")
            logger.info(f"   Main position size: {position_size}")
            logger.info(f"   Mirror position size: {mirror_position_size}")
            logger.info(f"   TP targets: {tp_prices} with percentages: {tp_percentages}")
            logger.info(f"   SL price: {sl_price}")

            # Determine which accounts to set up
            setup_main = account_type in ["main", "both"]
            setup_mirror = account_type in ["mirror", "both"] and self._is_mirror_trading_enabled()

            logger.info(f"   Setup main: {setup_main}, Setup mirror: {setup_mirror}")

            # If initial_position_size is provided, use it for TP/SL calculations
            # This handles cases where orders are placed before full position is built
            if initial_position_size is not None:
                logger.info(f"   üîÑ Using initial position size: {initial_position_size} (target: {position_size})")
                tp_sl_position_size = initial_position_size
            else:
                tp_sl_position_size = position_size

            # Mirror account sizing
            if setup_mirror:
                mirror_tp_sl_size = mirror_position_size if mirror_position_size is not None else tp_sl_position_size
                mirror_target = mirror_target_size if mirror_target_size is not None else position_size
                logger.info(f"   ü™û Mirror TP/SL size: {mirror_tp_sl_size} (target: {mirror_target})")

            results = {
                "main_account": {
                    "tp_orders": {},
                    "sl_order": None,
                    "errors": [],
                    "success": False
                },
                "mirror_account": {
                    "tp_orders": {},
                    "sl_order": None,
                    "errors": [],
                    "success": False
                },
                "monitoring_active": False,
                "success": False
            }

            # Validate inputs
            if sum(tp_percentages) != 100:
                logger.warning(f"TP percentages sum to {sum(tp_percentages)}, not 100%")

            # Get current price for minimum value calculation
            current_price = await get_current_price(symbol)
            if not current_price:
                current_price = entry_price

            # Minimum order value in USDT (Bybit requires $5 minimum)
            MIN_ORDER_VALUE = Decimal("5.0")

            # Calculate order quantities and check minimum values
            tp_quantities = []
            tp_valid = []
            remaining_percentage = Decimal("0")

            for i, percentage in enumerate(tp_percentages):
                qty = tp_sl_position_size * Decimal(str(percentage)) / Decimal("100")
                # Adjust quantity to step size
                adjusted_qty = value_adjusted_to_step(qty, qty_step)

                # Check minimum order value
                order_value = adjusted_qty * Decimal(str(current_price))
                if order_value < MIN_ORDER_VALUE:
                    logger.warning(f"TP{i+1} value ${order_value:.2f} < minimum ${MIN_ORDER_VALUE}")
                    tp_quantities.append(Decimal("0"))
                    tp_valid.append(False)
                    remaining_percentage += Decimal(str(percentage))
                else:
                    tp_quantities.append(adjusted_qty)
                    tp_valid.append(True)

            # Redistribute remaining percentage to TP1 if needed
            if remaining_percentage > 0 and tp_valid[0]:
                logger.info(f"Redistributing {remaining_percentage}% to TP1")
                tp_quantities[0] = value_adjusted_to_step(
                    tp_sl_position_size * (Decimal(str(tp_percentages[0])) + remaining_percentage) / Decimal("100"),
                    qty_step
                )

            # Get correct position index for hedge mode
            position_idx = await get_correct_position_idx(symbol, side)
            logger.info(f"üîß Using position index {position_idx} for {symbol} {side} (hedge mode)")

            # ENHANCED: Place TP orders on both main and mirror accounts
            await self._place_tp_orders_unified(
                symbol=symbol,
                side=side,
                tp_prices=tp_prices,
                tp_quantities=tp_quantities,
                tp_percentages=tp_percentages,
                approach=approach,
                position_idx=position_idx,
                setup_main=setup_main,
                setup_mirror=setup_mirror,
                mirror_tp_sl_size=mirror_tp_sl_size if setup_mirror else None,
                qty_step=qty_step,
                results=results
            )

            # ENHANCED: Place SL orders on both main and mirror accounts
            await self._place_sl_orders_unified(
                symbol=symbol,
                side=side,
                sl_price=sl_price,
                approach=approach,
                position_idx=position_idx,
                setup_main=setup_main,
                setup_mirror=setup_mirror,
                main_current_size=tp_sl_position_size,
                main_target_size=position_size,
                mirror_current_size=mirror_tp_sl_size if setup_mirror else None,
                mirror_target_size=mirror_target if setup_mirror else None,
                results=results
            )

            # FIXED: Flatten nested results structure for monitor compatibility
            # Combine main and mirror account orders into flat structure
            all_tp_orders = {**results["main_account"]["tp_orders"], **results["mirror_account"]["tp_orders"]}
            combined_sl_order = results["main_account"]["sl_order"] or results["mirror_account"]["sl_order"]
            all_errors = results["main_account"]["errors"] + results["mirror_account"]["errors"]

            # Add flat structure for backward compatibility
            results["tp_orders"] = all_tp_orders
            results["sl_order"] = combined_sl_order
            results["errors"] = all_errors

            # Initialize monitoring for this position
            monitor_data = {
                "symbol": symbol,
                "side": side,
                "entry_price": entry_price,
                "position_size": position_size,  # Target position size
                "current_size": tp_sl_position_size,  # Actual current size
                "remaining_size": tp_sl_position_size,  # Start with actual size
                "tp_orders": results["tp_orders"],
                "sl_order": results["sl_order"],
                "filled_tps": [],
                "approach": "conservative",
                "chat_id": chat_id,
                "created_at": time.time(),
                "last_check": time.time(),
                "sl_moved_to_be": False,
                "monitoring_task": None,  # Will store the asyncio task
                # Enhanced tracking for limit orders and phases
                "limit_orders": [],  # Track entry limit orders for Conservative approach
                "limit_orders_filled": approach == "FAST",  # For FAST approach, no limit orders; for CONSERVATIVE, track if filled
                "phase": "PROFIT_TAKING" if approach == "FAST" else "BUILDING",  # Position phase
                "tp1_hit": False,  # Track if TP1 (85%) has been hit
                "phase_transition_time": None,  # When phase changed
                "total_tp_filled": Decimal("0"),  # Total TP amount filled
                "cleanup_completed": False,  # Track if cleanup was performed
                "bot_instance": None,  # Will store bot reference for alerts
                "account_type": account_type  # Track which account this monitor is for
            }

            # Use account-aware key format
            monitor_key = f"{symbol}_{side}_{account_type}"
            self.position_monitors[monitor_key] = monitor_data
            results["monitoring_active"] = True

            # Start monitoring task
            monitor_task = asyncio.create_task(self._run_monitor_loop(symbol, side))
            monitor_data["monitoring_task"] = monitor_task

            # Create monitor_tasks entry for dashboard compatibility
            # FIXED: Call the monitor creation method directly
            await self.create_dashboard_monitor_entry(symbol, side, chat_id, approach, "main")

            # Also create mirror monitor entry if mirror account is active
            if setup_mirror:
                await self.create_dashboard_monitor_entry(symbol, side, chat_id, approach, "mirror")

            # Start cleanup scheduler if not already running
            if self.cleanup_task is None:
                self.start_cleanup_scheduler()

            # Set success to True if we have TP orders placed (SL failure shouldn't prevent success)
            results["success"] = len(results["main_account"]["tp_orders"]) > 0

            logger.info(f"‚úÖ Enhanced TP/SL setup complete for {symbol} {side}")
            return results

        except Exception as e:
            logger.error(f"‚ùå Error in enhanced TP/SL setup: {e}")
            return {
                "tp_orders": {},
                "sl_order": None,
                "errors": [str(e)],
                "monitoring_active": False,
                "success": False
            }

    def _calculate_full_position_sl_quantity(
        self,
        approach: str,
        current_size: Decimal,
        target_size: Decimal,
        tp1_hit: bool = False
    ) -> Decimal:
        """
        ENHANCED: Calculate SL quantity for 100% position coverage

        Logic:
        - Always provide 100% coverage of the FULL INTENDED position
        - ALL approaches: Cover full target (including unfilled limit orders)
        - This ensures protection in fast-moving markets where limits may suddenly fill
        - Maintains 100% coverage even after TP hits

        Args:
            approach: Trading approach (CONSERVATIVE/FAST)
            current_size: Currently filled position size
            target_size: Full intended position size (including limit orders)
            tp1_hit: Whether TP1 (85%) has been reached (kept for compatibility)

        Returns:
            Decimal: SL quantity to place (always 100% of target position)
        """
        # ALWAYS provide 100% coverage of target position (including unfilled limits)
        # This applies to ALL approaches - user requested this for safety
        sl_quantity = target_size

        if target_size > current_size:
            logger.info(f"üìä SL Quantity: {sl_quantity} (100% coverage including {target_size - current_size} unfilled)")
        else:
            logger.info(f"üìä SL Quantity: {sl_quantity} (100% of position)")

        return sl_quantity

    def _is_mirror_trading_enabled(self) -> bool:
        """Check if mirror trading is enabled and available"""
        try:
            from execution.mirror_trader import is_mirror_trading_enabled
            return is_mirror_trading_enabled()
        except ImportError:
            return False

    async def _place_tp_orders_unified(
        self,
        symbol: str,
        side: str,
        tp_prices: List[Decimal],
        tp_quantities: List[Decimal],
        tp_percentages: List[Decimal],
        approach: str,
        position_idx: int,
        setup_main: bool,
        setup_mirror: bool,
        mirror_tp_sl_size: Optional[Decimal],
        qty_step: Decimal,
        results: Dict
    ):
        """ENHANCED: Place TP orders on both main and mirror accounts"""

        # Determine order side (opposite of position side)
        order_side = "Sell" if side == "Buy" else "Buy"

        for i, (tp_price, tp_qty, tp_pct) in enumerate(zip(tp_prices, tp_quantities, tp_percentages)):
            try:
                # Skip if quantity is zero (failed minimum check)
                if tp_qty == 0:
                    logger.warning(f"Skipping TP{i+1} - below minimum order value")
                    continue

                # Calculate mirror TP quantity proportionally
                mirror_tp_qty = None
                if setup_mirror and mirror_tp_sl_size is not None:
                    mirror_tp_qty = mirror_tp_sl_size * Decimal(str(tp_pct)) / Decimal("100")
                    mirror_tp_qty = value_adjusted_to_step(mirror_tp_qty, qty_step)

                # Place main account TP order
                if setup_main:
                    order_link_id = generate_order_link_id(approach, symbol, ORDER_TYPE_TP, index=i+1)

                    logger.info(f"üìç MAIN: Placing TP{i+1} order: {tp_qty} @ {tp_price}")

                    order_result = await place_order_with_retry(
                        symbol=symbol,
                        side=order_side,
                        order_type="Limit",
                        qty=str(tp_qty),
                        price=str(tp_price),
                        reduce_only=True,
                        order_link_id=order_link_id,
                        time_in_force="GTC",
                        position_idx=position_idx
                    )

                    if order_result and order_result.get("orderId"):
                        order_id = order_result["orderId"]
                        results["main_account"]["tp_orders"][order_id] = {
                            "order_id": order_id,
                            "order_link_id": order_link_id,
                            "price": tp_price,
                            "quantity": tp_qty,
                            "original_quantity": tp_qty,
                            "percentage": tp_pct,
                            "tp_number": i + 1,
                            "account": "main"
                        }

                        # Track order lifecycle
                        self._track_order_lifecycle(
                            order_id=order_id,
                            order_type="TP",
                            symbol=symbol,
                            side=order_side,
                            price=tp_price,
                            quantity=tp_qty,
                            order_link_id=order_link_id
                        )

                        logger.info(f"‚úÖ MAIN: TP{i+1} order placed successfully")
                    else:
                        error_msg = f"MAIN: Failed to place TP{i+1} order"
                        results["main_account"]["errors"].append(error_msg)
                        logger.error(error_msg)

                # Place mirror account TP order
                if setup_mirror and mirror_tp_qty and mirror_tp_qty > 0:
                    from execution.mirror_trader import mirror_limit_order

                    mirror_order_link_id = generate_order_link_id("MIR", symbol, ORDER_TYPE_TP, index=i+1)

                    logger.info(f"üìç MIRROR: Placing TP{i+1} order: {mirror_tp_qty} @ {tp_price}")

                    mirror_result = await mirror_limit_order(
                        symbol=symbol,
                        side=order_side,
                        qty=str(mirror_tp_qty),
                        price=str(tp_price),
                        position_idx=0,  # Mirror account uses One-Way mode
                        order_link_id=mirror_order_link_id,
                        reduce_only=True,
                        time_in_force="GTC"
                    )

                    if mirror_result and mirror_result.get("orderId"):
                        order_id = mirror_result["orderId"]
                        results["mirror_account"]["tp_orders"][order_id] = {
                            "order_id": order_id,
                            "order_link_id": mirror_order_link_id,
                            "price": tp_price,
                            "quantity": mirror_tp_qty,
                            "original_quantity": mirror_tp_qty,
                            "percentage": tp_pct,
                            "tp_number": i + 1,
                            "account": "mirror"
                        }

                        logger.info(f"‚úÖ MIRROR: TP{i+1} order placed successfully")
                    else:
                        error_msg = f"MIRROR: Failed to place TP{i+1} order"
                        results["mirror_account"]["errors"].append(error_msg)
                        logger.error(error_msg)

            except Exception as e:
                error_msg = f"Error placing TP{i+1}: {e}"
                if setup_main:
                    results["main_account"]["errors"].append(error_msg)
                if setup_mirror:
                    results["mirror_account"]["errors"].append(error_msg)
                logger.error(error_msg)

    async def _place_sl_orders_unified(
        self,
        symbol: str,
        side: str,
        sl_price: Decimal,
        approach: str,
        position_idx: int,
        setup_main: bool,
        setup_mirror: bool,
        main_current_size: Decimal,
        main_target_size: Decimal,
        mirror_current_size: Optional[Decimal],
        mirror_target_size: Optional[Decimal],
        results: Dict
    ):
        """ENHANCED: Place SL orders on both main and mirror accounts with full position coverage"""

        sl_side = "Sell" if side == "Buy" else "Buy"

        try:
            # Place main account SL order
            if setup_main:
                main_sl_quantity = self._calculate_full_position_sl_quantity(
                    approach=approach,
                    current_size=main_current_size,
                    target_size=main_target_size,
                    tp1_hit=False
                )

                sl_order_link_id = generate_order_link_id(approach, symbol, ORDER_TYPE_SL)

                logger.info(f"üõ°Ô∏è MAIN ENHANCED SL: Placing SL order: {main_sl_quantity} @ {sl_price}")
                logger.info(f"   Current filled: {main_current_size}, Target: {main_target_size}")

                sl_result = await place_order_with_retry(
                    symbol=symbol,
                    side=sl_side,
                    order_type="Market",
                    qty=str(main_sl_quantity),
                    trigger_price=str(sl_price),
                    reduce_only=True,
                    order_link_id=sl_order_link_id,
                    position_idx=position_idx,
                    stop_order_type="StopLoss"
                )

                if sl_result and sl_result.get("orderId"):
                    order_id = sl_result["orderId"]
                    results["main_account"]["sl_order"] = {
                        "order_id": order_id,
                        "order_link_id": sl_order_link_id,
                        "price": sl_price,
                        "quantity": main_sl_quantity,
                        "original_quantity": main_sl_quantity,
                        "covers_full_position": True,
                        "target_position_size": main_target_size,
                        "account": "main"
                    }

                    # Track order lifecycle
                    self._track_order_lifecycle(
                        order_id=order_id,
                        order_type="SL",
                        symbol=symbol,
                        side=sl_side,
                        price=sl_price,
                        quantity=main_sl_quantity,
                        order_link_id=sl_order_link_id
                    )

                    logger.info("‚úÖ MAIN: SL order placed successfully")
                    results["main_account"]["success"] = True
                else:
                    error_msg = "MAIN: Failed to place SL order"
                    results["main_account"]["errors"].append(error_msg)
                    logger.error(error_msg)

            # Place mirror account SL order
            if setup_mirror and mirror_current_size is not None:
                from execution.mirror_trader import mirror_tp_sl_order

                mirror_sl_quantity = self._calculate_full_position_sl_quantity(
                    approach=approach,
                    current_size=mirror_current_size,
                    target_size=mirror_target_size,
                    tp1_hit=False
                )

                mirror_sl_order_link_id = generate_order_link_id("MIR", symbol, ORDER_TYPE_SL)

                logger.info(f"üõ°Ô∏è MIRROR ENHANCED SL: Placing SL order: {mirror_sl_quantity} @ {sl_price}")
                logger.info(f"   Current filled: {mirror_current_size}, Target: {mirror_target_size}")

                mirror_sl_result = await mirror_tp_sl_order(
                    symbol=symbol,
                    side=sl_side,
                    qty=str(mirror_sl_quantity),
                    trigger_price=str(sl_price),
                    position_idx=0,  # Mirror account uses One-Way mode
                    order_link_id=mirror_sl_order_link_id,
                    stop_order_type="StopLoss"
                )

                if mirror_sl_result and mirror_sl_result.get("orderId"):
                    order_id = mirror_sl_result["orderId"]
                    results["mirror_account"]["sl_order"] = {
                        "order_id": order_id,
                        "order_link_id": mirror_sl_order_link_id,
                        "price": sl_price,
                        "quantity": mirror_sl_quantity,
                        "original_quantity": mirror_sl_quantity,
                        "covers_full_position": True,
                        "target_position_size": mirror_target_size,
                        "account": "mirror"
                    }

                    logger.info("‚úÖ MIRROR: SL order placed successfully")
                    results["mirror_account"]["success"] = True
                else:
                    error_msg = "MIRROR: Failed to place SL order"
                    results["mirror_account"]["errors"].append(error_msg)
                    logger.error(error_msg)

        except Exception as e:
            error_msg = f"Error placing SL orders: {e}"
            if setup_main:
                results["main_account"]["errors"].append(error_msg)
            if setup_mirror:
                results["mirror_account"]["errors"].append(error_msg)
            logger.error(error_msg)

    async def monitor_and_adjust_orders(self, symbol: str, side: str, account_type: str = None):
        """
        Enhanced monitoring with real-time fill detection and reduced latency
        This replaces the conditional order logic with active management
        Now supports account-aware monitoring to prevent key collisions
        """
        # Determine monitor key based on available monitors
        main_key = f"{symbol}_{side}_main"
        mirror_key = f"{symbol}_{side}_mirror"
        legacy_key = f"{symbol}_{side}"  # For backward compatibility

        monitor_key = None
        monitor_data = None

        # Try to find the monitor
        if account_type == "mirror" and mirror_key in self.position_monitors:
            monitor_key = mirror_key
        elif account_type == "main" and main_key in self.position_monitors:
            monitor_key = main_key
        elif main_key in self.position_monitors:
            monitor_key = main_key
        elif mirror_key in self.position_monitors:
            monitor_key = mirror_key
        elif legacy_key in self.position_monitors:
            # Handle legacy monitors
            monitor_key = legacy_key

        if not monitor_key:
            return

        monitor_data = self.position_monitors[monitor_key]

        # Determine account type from monitor data or key
        if not account_type:
            account_type = monitor_data.get('account_type', 'main')
            if '_mirror' in monitor_key:
                account_type = 'mirror'
            elif '_main' in monitor_key:
                account_type = 'main'

        # Sanitize monitor data to ensure all numeric fields are Decimal
        monitor_data = self._sanitize_monitor_data(monitor_data)
        self.position_monitors[monitor_key] = monitor_data

        # Use adaptive monitoring intervals based on position state
        current_time = time.time()
        last_check = monitor_data.get("last_check", 0)

        # Determine monitoring interval based on position phase and activity
        if ADAPTIVE_MONITORING_INTERVALS:
            if monitor_data.get("phase") == "PROFIT_TAKING":
                target_interval = self.critical_position_interval  # 2 seconds
            elif monitor_data.get("tp1_hit", False):
                target_interval = self.active_position_interval    # 5 seconds
            else:
                target_interval = self.standard_monitor_interval   # 12 seconds
        else:
            target_interval = self.standard_monitor_interval   # Default 12 seconds

        # Skip if called too frequently (respect interval)
        if current_time - last_check < target_interval:
            return

        try:
            # IMPORTANT: Ensure we only check positions from the correct account
            # This prevents cross-account false positives
            if account_type == 'mirror':
                from clients.bybit_helpers import get_position_info_for_account
                positions = await get_position_info_for_account(symbol, 'mirror')
                logger.debug(f"üîç Fetching MIRROR position for {symbol} {side} (monitor: {monitor_key})")
            else:
                positions = await get_position_info(symbol)
                logger.debug(f"üîç Fetching MAIN position for {symbol} {side} (monitor: {monitor_key})")

            # Additional safety check - ensure we're monitoring the correct account
            if monitor_key.endswith('_mirror') and account_type != 'mirror':
                logger.error(f"‚ùå Monitor key mismatch: {monitor_key} but account_type is {account_type}")
                return
            elif monitor_key.endswith('_main') and account_type != 'main':
                logger.error(f"‚ùå Monitor key mismatch: {monitor_key} but account_type is {account_type}")
                return

            # Extra validation: ensure we fetched from the correct account
            if not positions:
                logger.debug(f"No positions found for {symbol} on {account_type} account")
                return
            position = None
            if positions:
                # Find the position for our side
                for pos in positions:
                    if pos.get("side") == side:
                        position = pos
                        logger.debug(f"üìä Found {account_type} position: size={pos.get('size')}")
                        break

            if not position or Decimal(str(position.get("size", "0"))) == 0:
                logger.info(f"Position {symbol} {side} closed - stopping monitor")

                # CRITICAL FIX: Clean up all orders when position is closed (SL hit or manual close)
                await self.cleanup_position_orders(symbol, side)

                # Send position closed alert
                await self._send_position_closed_alert(monitor_data)

                # Handle position closure analysis
                await self._handle_position_closure(monitor_data, position)

                # Clean up monitor (may already be done by cleanup_position_orders)
                if monitor_key in self.position_monitors:
                    del self.position_monitors[monitor_key]
                return

            current_size = Decimal(str(position["size"]))

            # Check if position size changed (indicating order fill)
            if current_size != monitor_data["remaining_size"]:
                logger.debug(f"üîÑ Size change detected for {monitor_key}: current={current_size}, stored={monitor_data['remaining_size']}")
                # Position size changed
                if current_size == 0:
                    # Position closed completely - check if it was SL or TP
                    await self._handle_position_closure(monitor_data, position)
                elif current_size < monitor_data["remaining_size"]:
                    # Position reduced - TP or partial fill
                    size_diff = monitor_data["remaining_size"] - current_size

                    # Simple sanity check: If the size difference is larger than the position, ignore it
                    if size_diff > monitor_data["position_size"]:
                        logger.debug(f"‚ö†Ô∏è Ignoring impossible size change for {monitor_key}: size_diff={size_diff} > position_size={monitor_data['position_size']}")
                        return  # Exit without modifying monitor data

                    # Log the position change
                    logger.debug(f"üìä Position size changed for {monitor_key} ({account_type} account): {monitor_data['remaining_size']} -> {current_size}")

                    # Calculate fill percentage based on the size of position when TP hit
                    # This represents what percentage of the position was closed in this TP
                    fill_percentage = (size_diff / monitor_data["position_size"]) * 100

                    # Track cumulative fills for logging purposes
                    fill_tracker = self.fill_tracker.get(monitor_key, {"total_filled": Decimal("0"), "target_size": monitor_data["position_size"]})
                    fill_tracker["total_filled"] += size_diff
                    self.fill_tracker[monitor_key] = fill_tracker
                    cumulative_percentage = (fill_tracker["total_filled"] / fill_tracker["target_size"]) * 100

                    # Reset cumulative tracking if it exceeds 100% (shouldn't happen after false positive fixes)
                    if cumulative_percentage > 100:
                        logger.warning(f"‚ö†Ô∏è Cumulative fill exceeded 100% ({cumulative_percentage:.2f}%) - this shouldn't happen after false positive fix")
                        fill_tracker["total_filled"] = size_diff
                        self.fill_tracker[monitor_key] = fill_tracker
                        cumulative_percentage = (size_diff / fill_tracker["target_size"]) * 100

                    logger.info(f"üéØ Position size reduced by {size_diff} ({fill_percentage:.2f}% of position, {cumulative_percentage:.2f}% cumulative) - TP order filled")

                    # NOW update remaining size after all checks passed
                    monitor_data["remaining_size"] = current_size

                    # Save to persistence after update
                    self.save_monitors_to_persistence()

                    # Determine what type of order was filled
                    if monitor_data["approach"] == "CONSERVATIVE":
                        # For conservative approach, could be limit order or TP fill
                        await self._handle_conservative_position_change(monitor_data, current_size, fill_percentage)
                    else:
                        # For fast approach, likely TP fill
                        await self._handle_fast_position_change(monitor_data, current_size)
                elif current_size > monitor_data["remaining_size"]:
                    # Position increased - additional limit orders filled (conservative approach)
                    size_diff = current_size - monitor_data["remaining_size"]
                    logger.info(f"üìà Position size increased by {size_diff} - additional limit orders filled")

                    # Use atomic lock to prevent race conditions during order adjustment
                    # Keep the same monitor_key format with account suffix
                    lock_key = f"{symbol}_{side}"
                    if lock_key not in self.monitor_locks:
                        self.monitor_locks[lock_key] = asyncio.Lock()

                    async with self.monitor_locks[lock_key]:
                        # Calculate fill percentage based on the increase
                        fill_percentage = (size_diff / current_size) * 100

                        # Track entry price for the filled limit orders
                        try:
                            # Get current position to find average price - USE CORRECT ACCOUNT
                            if account_type == 'mirror':
                                positions = await get_position_info_for_account(symbol, 'mirror')
                            else:
                                positions = await get_position_info(symbol)

                            if positions:
                                for pos in positions:
                                    if pos.get("side") == side:
                                        avg_price = Decimal(str(pos.get("avgPrice", "0")))
                                        if avg_price > 0:
                                            # Track the weighted entry price based on the fill
                                            await self._track_actual_entry_price(symbol, side, avg_price, size_diff)
                                            logger.info(f"üìä Tracked limit order fill: {size_diff} @ {avg_price}")
                                        break
                        except Exception as e:
                            logger.warning(f"Could not track limit order entry price: {e}")

                        # Send limit fill alert
                        await self._send_limit_fill_alert(monitor_data, fill_percentage)

                        # Update position size and remaining size atomically
                        monitor_data["position_size"] = current_size
                        monitor_data["remaining_size"] = current_size

                    # Save to persistence after update
                    self.save_monitors_to_persistence()

                    # Adjust all TP/SL orders proportionally to new position size
                    await self._adjust_all_orders_for_partial_fill(monitor_data, current_size)

                    # ENHANCED: Trigger real-time mirror sync for position increases
                    await self._trigger_mirror_sync_for_position_increase(symbol, side, current_size, size_diff)

                    logger.info(f"üîí Atomic order adjustment completed for {monitor_key}")

                # Mirror sync removed - each account operates independently
                # Mirror monitors handle their own position changes without syncing

            # Enhanced fill detection with order history verification
            if ENHANCED_FILL_DETECTION:
                await self._enhanced_fill_detection(symbol, side, monitor_data)

            # Update order statuses based on current open orders
            await self._update_order_statuses(symbol, side)

            # Update last check time
            monitor_data["last_check"] = time.time()

        except Exception as e:
            # Use error recovery system for monitoring errors
            await self._handle_monitor_error(symbol, side, e)

    async def _handle_conservative_position_change(self, monitor_data: Dict, current_size: Decimal, fill_percentage: float):
        """
        Handle position changes for conservative approach
        Could be limit order fills or TP fills
        """
        # Check if limit orders have already been filled
        limit_orders_filled = monitor_data.get("limit_orders_filled", False)

        # For conservative approach, we need to distinguish between:
        # 1. Initial limit order fills (when position is being built)
        # 2. TP order fills (when position is being reduced)

        # If limit orders haven't been filled yet and fill is < 50%, it's likely limit fills
        if not limit_orders_filled and fill_percentage < 50:
            logger.info(f"üìä Conservative approach: Limit orders filling ({fill_percentage:.2f}% filled)")

            # Mark that limit orders have been filled
            monitor_data["limit_orders_filled"] = True

            # Send limit fill alert
            await self._send_limit_fill_alert(monitor_data, fill_percentage)

            # For limit order fills, we need to adjust TP/SL quantities proportionally
            await self._adjust_all_orders_for_partial_fill(monitor_data, current_size)
        else:
            # This is a TP fill (position reduction after limit orders were filled)
            logger.info(f"üéØ Conservative approach: TP order filled ({fill_percentage:.2f}% of position)")

            # Send TP fill alert
            await self._send_tp_fill_alert(monitor_data, fill_percentage)

            # Adjust SL quantity to match remaining position
            await self._adjust_sl_quantity(monitor_data, current_size)

            # ENHANCED: Progressive SL Management with Breakeven Automation
            monitor_key = f"{monitor_data['symbol']}_{monitor_data['side']}"

            # Check for TP1 breakeven trigger (85% filled)
            if fill_percentage >= 85 and not monitor_data["sl_moved_to_be"]:
                # Use atomic lock to prevent race conditions
                if monitor_key not in self.breakeven_locks:
                    self.breakeven_locks[monitor_key] = asyncio.Lock()

                async with self.breakeven_locks[monitor_key]:
                    # Double-check flag after acquiring lock
                    if not monitor_data["sl_moved_to_be"]:
                        logger.info(f"üîí ENHANCED TP1 BREAKEVEN: {monitor_key} - {fill_percentage:.2f}% filled")

                        # Mark TP1 as hit for enhanced tracking
                        monitor_data["tp1_hit"] = True

                        # First, transition to profit-taking phase and cleanup limit orders
                        await self._transition_to_profit_taking(monitor_data)

                        # Get fresh position data for breakeven calculation
                        positions = await get_position_info(monitor_data["symbol"])
                        position = None
                        if positions:
                            for pos in positions:
                                if pos.get("side") == monitor_data["side"]:
                                    position = pos
                                    break

                        if position:
                            # ENHANCED: Use enhanced breakeven with full position management
                            success = await self._move_sl_to_breakeven_enhanced_v2(
                                monitor_data=monitor_data,
                                position=position,
                                is_tp1_trigger=True
                            )

                            if success:
                                monitor_data["sl_moved_to_be"] = True
                                logger.info(f"‚úÖ ENHANCED TP1 breakeven completed for {monitor_key}")

                                # Send enhanced breakeven alert
                                await self._send_enhanced_breakeven_alert(monitor_data, "TP1")

                                # Synchronize with mirror account
                                await self._sync_breakeven_with_mirror(monitor_data)
                            else:
                                logger.error(f"‚ùå ENHANCED TP1 breakeven failed for {monitor_key}")

            # ENHANCED: Progressive breakeven for subsequent TP fills (TP2, TP3, TP4)
            elif monitor_data.get("sl_moved_to_be", False) and fill_percentage > 85:
                # TP2/3/4 fills - adjust SL progressively
                await self._handle_progressive_tp_fills(monitor_data, fill_percentage, current_size)

    async def _handle_fast_position_change(self, monitor_data: Dict, current_size: Decimal):
        """
        Handle position changes for fast approach
        Usually just TP fills since fast approach uses market orders
        """
        # Fast approach has single TP at 100%, so any reduction means TP hit
        approach = monitor_data.get("approach", "unknown")
        if approach == "conservative":
            logger.info(f"üéØ Conservative approach: TP order filled")
        else:
            logger.info(f"üéØ TP order filled")

        # Send TP fill alert for fast approach
        fill_percentage = ((monitor_data["position_size"] - current_size) / monitor_data["position_size"]) * 100
        await self._send_tp_fill_alert(monitor_data, fill_percentage)

        # Position should be closed, but update SL just in case
        await self._adjust_sl_quantity(monitor_data, current_size)

    async def _adjust_all_orders_for_partial_fill(self, monitor_data: Dict, current_size: Decimal):
        """
        Adjust all TP and SL orders when position is partially filled
        This happens when limit orders in conservative approach are partially filled
        FIXED: Enhanced error handling and validation
        ENHANCED: Added atomic operation protection
        """
        try:
            # Validate inputs
            if not monitor_data or current_size <= 0:
                logger.warning(f"Invalid parameters for order adjustment: monitor_data={bool(monitor_data)}, current_size={current_size}")
                return

            symbol = monitor_data.get("symbol", "UNKNOWN")
            side = monitor_data.get("side", "UNKNOWN")
            monitor_key = f"{symbol}_{side}"

            logger.info(f"üîß Adjusting orders for {symbol} {side} - new size: {current_size}")

            # Note: This method is already called within an atomic lock from the caller
            # Additional locking here would cause deadlock, so we rely on the caller's lock
            # ENHANCED: Use absolute position size calculation instead of ratios
            approach = monitor_data.get("approach", "CONSERVATIVE")

            # Define TP percentages based on approach
            if approach == "CONSERVATIVE":
                tp_percentages = [Decimal("85"), Decimal("5"), Decimal("5"), Decimal("5")]  # TP1: 85%, TP2-4: 5% each
            else:  # FAST
                tp_percentages = [Decimal("100")]  # Single TP at 100%

            logger.info(f"üîß Position size changed to {current_size} - recalculating all TP orders")
            logger.info(f"üîÑ Using {approach} approach with absolute position sizing")

            # Update the position size in monitor data
            monitor_data["position_size"] = current_size
            monitor_data["current_size"] = current_size
            monitor_data["remaining_size"] = current_size

            # Save to persistence after update
            self.save_monitors_to_persistence()

            # Adjust each TP order using absolute calculation
            # Ensure tp_orders is in dict format for backward compatibility
            tp_orders = self._ensure_tp_orders_dict(monitor_data)

            # Convert dict to list for iteration
            tp_orders_list = list(tp_orders.values()) if isinstance(tp_orders, dict) else []

            for i, tp_order in enumerate(tp_orders_list):
                if not isinstance(tp_order, dict):
                    logger.warning(f"Skipping invalid TP order at index {i}: not a dict")
                    continue

                if i >= len(tp_percentages):
                    # Cancel excess TP orders
                    await cancel_order_with_retry(monitor_data["symbol"], tp_order["order_id"])
                    logger.info(f"‚ùå Cancelled excess TP{tp_order.get('tp_number', i+1)} order")
                    continue

                # Calculate new quantity based on absolute position size and TP percentage
                tp_percentage = tp_percentages[i]
                raw_new_qty = (current_size * tp_percentage) / Decimal("100")

                # Get instrument info to validate quantity step
                try:
                    instrument_info = await get_instrument_info(monitor_data["symbol"])
                    if instrument_info:
                        lot_size_filter = instrument_info.get("lotSizeFilter", {})
                        qty_step = Decimal(lot_size_filter.get("qtyStep", "1"))
                        min_order_qty = Decimal(lot_size_filter.get("minOrderQty", "0.001"))

                        # Adjust quantity to step size
                        new_qty = value_adjusted_to_step(raw_new_qty, qty_step)

                        # Skip if quantity too small or below minimum
                        if new_qty < min_order_qty:
                            await cancel_order_with_retry(monitor_data["symbol"], tp_order["order_id"])
                            logger.info(f"‚ùå Cancelled TP{tp_order.get('tp_number', i+1)} - quantity {new_qty} below minimum {min_order_qty}")
                            continue
                    else:
                        # Fallback: use raw quantity but round to reasonable precision
                        new_qty = raw_new_qty.quantize(Decimal("0.1"))
                        if new_qty < Decimal("0.1"):
                            await cancel_order_with_retry(monitor_data["symbol"], tp_order["order_id"])
                            logger.info(f"‚ùå Cancelled TP{tp_order.get('tp_number', i+1)} - quantity too small")
                            continue
                except Exception as e:
                    logger.error(f"Error getting instrument info for {monitor_data['symbol']}: {e}")
                    # Fallback: use raw quantity but round to reasonable precision
                    new_qty = raw_new_qty.quantize(Decimal("0.1"))
                    if new_qty < Decimal("0.1"):
                        await cancel_order_with_retry(monitor_data["symbol"], tp_order["order_id"])
                        logger.info(f"‚ùå Cancelled TP{tp_order['tp_number']} - quantity too small")
                        continue

                # Cancel and replace the order with new quantity
                if await cancel_order_with_retry(monitor_data["symbol"], tp_order["order_id"]):
                    # Place new order with adjusted quantity
                    order_side = "Sell" if monitor_data["side"] == "Buy" else "Buy"

                    # Get position index for hedge mode
                    position_idx = await get_correct_position_idx(monitor_data["symbol"], monitor_data["side"])

                    # Track adjustment count for this order
                    adjustment_count = tp_order.get("adjustment_count", 0) + 1
                    adjusted_order_link_id = generate_adjusted_order_link_id(
                        tp_order.get("order_link_id", f"TP_{i+1}"),
                        adjustment_count
                    )

                    new_result = await place_order_with_retry(
                        symbol=monitor_data["symbol"],
                        side=order_side,
                        order_type="Limit",
                        qty=str(new_qty),
                        price=str(tp_order.get("price", "0")),
                        reduce_only=True,
                        order_link_id=adjusted_order_link_id,
                        time_in_force="GTC",
                        position_idx=position_idx  # Add position index for hedge mode
                    )

                    if new_result and new_result.get("orderId"):
                        tp_order["order_id"] = new_result["orderId"]
                        tp_order["original_quantity"] = tp_order.get("original_quantity", tp_order.get("quantity", new_qty))  # Keep track of original
                        tp_order["quantity"] = new_qty
                        tp_order["order_link_id"] = adjusted_order_link_id
                        tp_order["adjustment_count"] = adjustment_count
                        tp_order["tp_percentage"] = tp_percentage  # Track the percentage for this TP
                        logger.info(f"‚úÖ TP{tp_order.get('tp_number', i+1)} adjusted to {new_qty} ({tp_percentage}% of {current_size})")

            # ENHANCED: Adjust SL order using enhanced calculation
            await self._adjust_sl_quantity_enhanced(monitor_data, current_size)

        except Exception as e:
            logger.error(f"Error adjusting orders for partial fill: {e}")

    async def _adjust_sl_quantity(self, monitor_data: Dict, new_quantity: Decimal):
        """Adjust SL order quantity to match remaining position size"""
        if not monitor_data.get("sl_order"):
            return

        try:
            sl_order = monitor_data["sl_order"]

            # Cancel existing SL
            if await cancel_order_with_retry(
                monitor_data["symbol"],
                sl_order["order_id"]
            ):
                # Validate and adjust quantity to step size
                try:
                    instrument_info = await get_instrument_info(monitor_data["symbol"])
                    if instrument_info:
                        lot_size_filter = instrument_info.get("lotSizeFilter", {})
                        qty_step = Decimal(lot_size_filter.get("qtyStep", "1"))
                        min_order_qty = Decimal(lot_size_filter.get("minOrderQty", "0.001"))

                        # Adjust quantity to step size
                        adjusted_quantity = value_adjusted_to_step(new_quantity, qty_step)

                        # Ensure minimum quantity
                        if adjusted_quantity < min_order_qty:
                            adjusted_quantity = min_order_qty

                        logger.info(f"üîÑ Adjusting SL quantity from {sl_order['quantity']} to {adjusted_quantity} (raw: {new_quantity})")
                    else:
                        # Fallback: round to reasonable precision
                        adjusted_quantity = new_quantity.quantize(Decimal("0.1"))
                        logger.info(f"üîÑ Adjusting SL quantity from {sl_order['quantity']} to {adjusted_quantity} (fallback rounding)")
                except Exception as e:
                    logger.error(f"Error getting instrument info for SL adjustment: {e}")
                    # Fallback: round to reasonable precision
                    adjusted_quantity = new_quantity.quantize(Decimal("0.1"))
                    logger.info(f"üîÑ Adjusting SL quantity from {sl_order['quantity']} to {adjusted_quantity} (fallback)")

                # Place new SL with updated quantity
                side = monitor_data["side"]
                sl_side = "Sell" if side == "Buy" else "Buy"

                # Get position index for hedge mode
                position_idx = await get_correct_position_idx(monitor_data["symbol"], side)

                # Track adjustment count for SL order
                adjustment_count = sl_order.get("adjustment_count", 0) + 1
                adjusted_order_link_id = generate_adjusted_order_link_id(
                    sl_order["order_link_id"],
                    adjustment_count
                )

                sl_result = await place_order_with_retry(
                    symbol=monitor_data["symbol"],
                    side=sl_side,
                    order_type="Market",
                    qty=str(adjusted_quantity),
                    trigger_price=str(sl_order["price"]),
                    reduce_only=True,
                    order_link_id=adjusted_order_link_id,
                    position_idx=position_idx,  # Add position index for hedge mode
                    stop_order_type="StopLoss"
                )

                if sl_result and sl_result.get("orderId"):
                    # Update SL order info
                    monitor_data["sl_order"]["order_id"] = sl_result["orderId"]
                    monitor_data["sl_order"]["quantity"] = new_quantity
                    monitor_data["sl_order"]["order_link_id"] = adjusted_order_link_id
                    monitor_data["sl_order"]["adjustment_count"] = adjustment_count
                    logger.info("‚úÖ SL quantity adjusted successfully")

        except Exception as e:
            logger.error(f"Error adjusting SL quantity: {e}")

    async def _adjust_sl_quantity_enhanced(self, monitor_data: Dict, current_position_size: Decimal):
        """Enhanced SL quantity adjustment using full position coverage logic"""
        if not monitor_data.get("sl_order"):
            return

        try:
            # Use the enhanced SL calculation method
            approach = monitor_data.get("approach", "CONSERVATIVE")
            tp1_hit = monitor_data.get("tp1_hit", False)

            # Calculate enhanced SL quantity
            if hasattr(self, '_calculate_full_position_sl_quantity'):
                target_position_size = monitor_data.get("position_size", current_position_size)
                enhanced_sl_qty = self._calculate_full_position_sl_quantity(
                    approach=approach,
                    current_size=current_position_size,
                    target_size=target_position_size,
                    tp1_hit=tp1_hit
                )
            else:
                # Fallback to current position size
                enhanced_sl_qty = current_position_size

            logger.info(f"üõ°Ô∏è Enhanced SL calculation: {enhanced_sl_qty} (approach: {approach}, TP1 hit: {tp1_hit})")

            # Use the standard adjustment method with enhanced quantity
            await self._adjust_sl_quantity(monitor_data, enhanced_sl_qty)

        except Exception as e:
            logger.error(f"Error in enhanced SL quantity adjustment: {e}")
            # Fallback to standard method
            await self._adjust_sl_quantity(monitor_data, current_position_size)

    async def _move_sl_to_breakeven_failsafe(self, monitor_data: Dict, position: Dict) -> Tuple[bool, str, Optional[Dict]]:
        """
        Failsafe wrapper for breakeven operations using the comprehensive failsafe system

        Returns:
            Tuple[success, message, sl_data]
        """
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            monitor_key = f"{symbol}_{side}"

            # Use actual weighted average entry price if available
            if monitor_key in self.actual_entry_prices:
                entry_price = self.actual_entry_prices[monitor_key]
                logger.info(f"üîÑ Using actual weighted entry price for failsafe: {entry_price}")
            else:
                entry_price = monitor_data["entry_price"]
                logger.warning(f"‚ö†Ô∏è Using planned entry price for failsafe (no actual fills tracked): {entry_price}")

            # Get current price
            current_price = await get_current_price(symbol)
            if not current_price:
                return False, "Could not get current price for breakeven calculation", None

            logger.info(f"üõ°Ô∏è Starting failsafe breakeven operation for {symbol} {side}")
            logger.info(f"üìä Entry: {entry_price}, Current: {current_price}")

            # Store original SL price for reference
            if "sl_order" in monitor_data and monitor_data["sl_order"].get("price"):
                monitor_data["original_sl_price"] = monitor_data["sl_order"]["price"]

            # Use the comprehensive failsafe system
            success, message, sl_data = await breakeven_failsafe.move_sl_to_breakeven_atomic(
                monitor_data, entry_price, current_price
            )

            if success:
                logger.info(f"‚úÖ Failsafe breakeven successful: {message}")
                return True, message, sl_data
            else:
                logger.error(f"‚ùå Failsafe breakeven failed: {message}")
                return False, message, None

        except Exception as e:
            logger.error(f"‚ùå Exception in failsafe breakeven wrapper: {e}")
            return False, f"Failsafe wrapper exception: {str(e)}", None

    async def _move_sl_to_breakeven_enhanced(self, monitor_data: Dict, position: Dict):
        """Enhanced breakeven move with dynamic fee calculation and better error handling"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            monitor_key = f"{symbol}_{side}"

            # Use actual weighted average entry price if available
            if monitor_key in self.actual_entry_prices:
                entry_price = self.actual_entry_prices[monitor_key]
                logger.info(f"üîÑ Using actual weighted entry price: {entry_price}")
            else:
                entry_price = monitor_data["entry_price"]
                logger.warning(f"‚ö†Ô∏è Using planned entry price (no actual fills tracked): {entry_price}")

            current_sl_price = monitor_data["sl_order"]["price"]

            # Dynamic fee calculation with configurable safety margin
            if DYNAMIC_FEE_CALCULATION:
                fee_rate = await self._get_trading_fee_rate(symbol)
            else:
                fee_rate = Decimal("0.0006")  # Fallback to fixed 0.06%

            safety_margin = Decimal(str(BREAKEVEN_SAFETY_MARGIN))  # Configurable safety margin
            total_fee_buffer = fee_rate + safety_margin

            logger.info(f"üìä Fee calculation: base_rate={fee_rate:.4f}%, safety_margin={safety_margin:.4f}%, total={total_fee_buffer:.4f}%")

            if side == "Buy":
                breakeven_price = entry_price * (Decimal("1") + total_fee_buffer)
                # Only move if new price is better than current SL
                if breakeven_price <= current_sl_price:
                    logger.info(f"üö´ Breakeven price {breakeven_price} not better than current SL {current_sl_price}")
                    return
            else:  # Sell
                breakeven_price = entry_price * (Decimal("1") - total_fee_buffer)
                # Only move if new price is better than current SL
                if breakeven_price >= current_sl_price:
                    logger.info(f"üö´ Breakeven price {breakeven_price} not better than current SL {current_sl_price}")
                    return

            logger.info(f"üéØ Moving SL to breakeven: {current_sl_price} ‚Üí {breakeven_price}")

            # Cancel existing SL
            if await cancel_order_with_retry(
                monitor_data["symbol"],
                monitor_data["sl_order"]["order_id"]
            ):
                # Place new SL at breakeven
                sl_side = "Sell" if side == "Buy" else "Buy"

                # Get position index for hedge mode
                position_idx = await get_correct_position_idx(monitor_data["symbol"], side)

                sl_result = await place_order_with_retry(
                    symbol=monitor_data["symbol"],
                    side=sl_side,
                    order_type="Market",
                    qty=str(monitor_data["remaining_size"]),
                    trigger_price=str(breakeven_price),
                    reduce_only=True,
                    order_link_id=monitor_data["sl_order"]["order_link_id"] + "_BE",
                    position_idx=position_idx,  # Add position index for hedge mode
                    stop_order_type="StopLoss"
                )

                if sl_result and sl_result.get("orderId"):
                    # Update SL order info
                    monitor_data["sl_order"]["order_id"] = sl_result["orderId"]
                    monitor_data["sl_order"]["price"] = breakeven_price
                    monitor_data["sl_order"]["order_link_id"] += "_BE"
                    monitor_data["sl_moved_to_be"] = True
                    logger.info("‚úÖ SL moved to breakeven successfully")

        except Exception as e:
            logger.error(f"Error moving SL to breakeven: {e}")

    async def _get_trading_fee_rate(self, symbol: str) -> Decimal:
        """Get dynamic trading fee rate for the account"""
        try:
            # Check cache first
            if symbol in self.fee_rates_cache:
                cache_entry = self.fee_rates_cache[symbol]
                if time.time() - cache_entry["timestamp"] < 300:  # 5 minute cache
                    return cache_entry["fee_rate"]

            # Try to get account info for fee rates
            try:
                from clients.bybit_client import bybit_client
                account_info = bybit_client.get_account_info()

                if account_info and account_info.get("result"):
                    # Extract fee rate from account info
                    fee_info = account_info["result"].get("feeRate", {})
                    taker_fee = fee_info.get("takerFeeRate", "0.0006")  # Default 0.06%
                    fee_rate = Decimal(str(taker_fee))

                    # Cache the result
                    self.fee_rates_cache[symbol] = {
                        "fee_rate": fee_rate,
                        "timestamp": time.time()
                    }

                    logger.info(f"üìä Retrieved dynamic fee rate: {fee_rate:.4f}% for {symbol}")
                    return fee_rate
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Could not get dynamic fee rate: {e}")

            # Fallback to conservative default
            default_fee = Decimal("0.0006")  # 0.06% conservative default
            logger.info(f"üìä Using default fee rate: {default_fee:.4f}% for {symbol}")
            return default_fee

        except Exception as e:
            logger.error(f"Error getting trading fee rate: {e}")
            return Decimal("0.0006")  # Safe fallback

    async def _track_actual_entry_price(self, symbol: str, side: str, filled_price: Decimal, filled_qty: Decimal):
        """Track actual entry prices from order fills for accurate breakeven calculation"""
        monitor_key = f"{symbol}_{side}"

        if monitor_key not in self.actual_entry_prices:
            # First fill
            self.actual_entry_prices[monitor_key] = {
                "weighted_price": filled_price,
                "total_qty": filled_qty,
                "fills": []
            }
        else:
            # Additional fill - calculate weighted average
            entry_data = self.actual_entry_prices[monitor_key]
            old_total_qty = entry_data["total_qty"]
            new_total_qty = old_total_qty + filled_qty

            # Weighted average calculation
            old_total_value = entry_data["weighted_price"] * old_total_qty
            new_fill_value = filled_price * filled_qty
            new_weighted_price = (old_total_value + new_fill_value) / new_total_qty

            entry_data["weighted_price"] = new_weighted_price
            entry_data["total_qty"] = new_total_qty

        # Record the fill
        self.actual_entry_prices[monitor_key]["fills"].append({
            "price": filled_price,
            "qty": filled_qty,
            "timestamp": time.time()
        })

        logger.info(f"üìä Updated weighted entry price for {monitor_key}: {self.actual_entry_prices[monitor_key]['weighted_price']:.6f}")

    async def _enhanced_fill_detection(self, symbol: str, side: str, monitor_data: Dict):
        """Enhanced real-time fill detection with order history verification"""
        try:
            monitor_key = f"{symbol}_{side}"

            # Get current open orders for verification
            open_orders = await get_open_orders(symbol)

            # Check TP orders for fills
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            if isinstance(tp_orders, list):
                # Convert list to dict using order_id as key
                tp_orders_dict = {}
                for tp_order in tp_orders:
                    if isinstance(tp_order, dict) and "order_id" in tp_order:
                        tp_orders_dict[tp_order["order_id"]] = tp_order
                tp_orders = tp_orders_dict

            for order_id, tp_order in tp_orders.items():
                # order_id = tp_order["order_id"]  # Now comes from iteration

                # Check if order is no longer in open orders (potentially filled)
                order_found = any(order.get("orderId") == order_id for order in open_orders)

                if not order_found and tp_order.get("status") != "FILLED":
                    # Order not found in open orders but not marked as filled
                    # Verify through order history
                    filled_qty = await self._verify_order_fill_history(symbol, order_id)

                    if filled_qty and filled_qty > 0:
                        logger.info(f"üéØ Detected TP order fill via history: {order_id} - {filled_qty}")

                        # Note: TP orders don't contribute to entry price, they reduce position

                        # Update order status
                        tp_order["status"] = "FILLED"
                        tp_order["filled_qty"] = filled_qty
                        tp_order["fill_time"] = time.time()

                        # Update fill tracker
                        if monitor_key not in self.fill_tracker:
                            self.fill_tracker[monitor_key] = {"total_filled": Decimal("0"), "target_size": monitor_data["position_size"]}
                        self.fill_tracker[monitor_key]["total_filled"] += filled_qty

            # Check for any other order changes
            await self._verify_position_consistency(symbol, side, monitor_data)

        except Exception as e:
            logger.error(f"Error in enhanced fill detection: {e}")

    async def _verify_order_fill_history(self, symbol: str, order_id: str) -> Optional[Decimal]:
        """Verify order fill through order history API"""
        try:
            from clients.bybit_client import bybit_client

            # Get order history for the specific order
            history = bybit_client.get_order_history(
                category="linear",
                symbol=symbol,
                orderId=order_id,
                limit=1
            )

            if history and history.get("result") and history["result"].get("list"):
                order_data = history["result"]["list"][0]
                if order_data.get("orderStatus") in ["Filled", "PartiallyFilled"]:
                    filled_qty = Decimal(str(order_data.get("cumExecQty", "0")))
                    logger.info(f"üìã Order history confirms fill: {order_id} - {filled_qty}")
                    return filled_qty

            return None

        except Exception as e:
            logger.warning(f"Could not verify order fill history: {e}")
            return None

    async def _verify_position_consistency(self, symbol: str, side: str, monitor_data: Dict):
        """Update tracked position size from exchange without warnings"""
        try:
            # Determine account type from monitor data
            account_type = monitor_data.get("account_type", "main")
            monitor_key = f"{symbol}_{side}"
            if account_type == "mirror":
                monitor_key += "_mirror"

            # Get current position from exchange - USE CORRECT ACCOUNT
            if account_type == 'mirror':
                positions = await get_position_info_for_account(symbol, 'mirror')
            else:
                positions = await get_position_info(symbol)

            current_position = None

            if positions:
                for pos in positions:
                    if pos.get("side") == side:
                        current_position = pos
                        break

            if current_position:
                exchange_size = Decimal(str(current_position.get("size", "0")))
                tracked_size = Decimal(str(monitor_data.get("remaining_size", "0")))

                # Simply update tracked size to match exchange without warnings
                monitor_data["remaining_size"] = exchange_size

                # If position is smaller, likely a TP fill we missed
                if exchange_size < tracked_size:
                    size_diff = tracked_size - exchange_size

                    # Update fill tracker
                    if monitor_key not in self.fill_tracker:
                        self.fill_tracker[monitor_key] = {"total_filled": Decimal("0"), "target_size": monitor_data["position_size"]}
                    self.fill_tracker[monitor_key]["total_filled"] += size_diff

        except Exception as e:
            logger.error(f"Error updating position size: {e}")


    async def validate_monitor_creation(self, symbol: str, side: str, chat_id: int,
                                      approach: str, account_type: str = "main") -> bool:
        """
        Validate that both Enhanced TP/SL and dashboard monitors were created successfully
        Added by monitor tracking fix to ensure complete monitor coverage
        """
        try:
            # Check Enhanced TP/SL monitor
            monitor_key = f"{symbol}_{side}"
            if account_type == "mirror":
                monitor_key += "_MIRROR"

            has_enhanced_monitor = monitor_key in self.position_monitors
            if account_type == "mirror" and hasattr(self, 'mirror_monitors'):
                has_enhanced_monitor = monitor_key in getattr(self, 'mirror_monitors', {})

            # Check dashboard monitor
            dashboard_key_pattern = f"{chat_id}_{symbol}_{approach}"
            if account_type == "mirror":
                dashboard_key_pattern += "_mirror"

            # Load current dashboard monitors
            import pickle
            pkl_path = '/Users/lualakol/bybit-telegram-bot/bybit_bot_dashboard_v4.1_enhanced.pkl'

            try:
                with open(pkl_path, 'rb') as f:
                    data = pickle.load(f)
                dashboard_monitors = data.get('bot_data', {}).get('monitor_tasks', {})
                has_dashboard_monitor = any(dashboard_key_pattern in key for key in dashboard_monitors.keys())
            except Exception:
                has_dashboard_monitor = False

            success = has_enhanced_monitor and has_dashboard_monitor

            if not success:
                logger.warning(f"‚ö†Ô∏è Monitor validation failed for {symbol} {side} ({account_type})")
                logger.warning(f"   Enhanced monitor: {has_enhanced_monitor}")
                logger.warning(f"   Dashboard monitor: {has_dashboard_monitor}")
            else:
                logger.info(f"‚úÖ Monitor validation passed for {symbol} {side} ({account_type})")

            return success

        except Exception as e:
            logger.error(f"‚ùå Error validating monitor creation: {e}")
            return False

    async def cleanup_position_orders(self, symbol: str, side: str, account_type: str = None):
        """Clean up all orders when position is closed"""
        monitor_key = f"{symbol}_{side}"
        if monitor_key not in self.position_monitors:
            logger.info(f"Monitor {monitor_key} not found, skipping cleanup")
            return

        monitor_data = self.position_monitors.get(monitor_key)
        if not monitor_data:
            logger.warning(f"Monitor data for {monitor_key} is None")
            return

        try:
            # Cancel all remaining TP orders
            # Ensure tp_orders is dict format
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            for order_id, tp_order in tp_orders.items():
                await cancel_order_with_retry(symbol, tp_order["order_id"])

            # Cancel SL order if exists
            if monitor_data.get("sl_order"):
                await cancel_order_with_retry(symbol, monitor_data["sl_order"]["order_id"])

            # Cancel any remaining active limit orders
            for limit_order in monitor_data.get("limit_orders", []):
                if isinstance(limit_order, dict) and limit_order.get("status") == "ACTIVE":
                    try:
                        await cancel_order_with_retry(symbol, limit_order["order_id"])
                        limit_order["status"] = "CANCELLED"
                        logger.info(f"üßπ Cancelled remaining limit order {limit_order['order_id'][:8]}...")
                    except Exception as e:
                        logger.error(f"Error cancelling limit order {limit_order['order_id'][:8]}...: {e}")

            # CRITICAL FIX: Clean up mirror account orders
            await self._cleanup_mirror_position_orders(symbol, side)

            # Mark cleanup as completed
            monitor_data["cleanup_completed"] = True
            monitor_data["phase"] = "CLOSED"

            # Remove monitor using robust persistence
            try:
                from utils.robust_persistence import remove_trade_monitor
                await remove_trade_monitor(symbol, side, reason="position_closed")
                logger.info(f"‚úÖ Removed monitor via robust persistence for closed position")
            except Exception as e:
                logger.error(f"Error removing monitor via robust persistence: {e}")

            # Remove from monitors
            del self.position_monitors[monitor_key]
            logger.info(f"‚úÖ Cleaned up all orders for closed position {symbol} {side}")

        except Exception as e:
            logger.error(f"Error cleaning up orders: {e}")

    async def _cleanup_mirror_position_orders(self, symbol: str, side: str):
        """Clean up mirror account orders when position is closed"""
        try:
            # Check if mirror trading is enabled
            from execution.mirror_trader import is_mirror_trading_enabled
            if not is_mirror_trading_enabled():
                return

            logger.info(f"üîÑ Cleaning up mirror account orders for {symbol} {side}")

            # Try to get mirror enhanced TP/SL manager
            try:
                from execution.mirror_enhanced_tp_sl import initialize_mirror_manager
                mirror_manager = initialize_mirror_manager(self)
                if mirror_manager:
                    # Mirror manager doesn't have cleanup_mirror_orders method
                    # Fall through to direct cleanup below
                    logger.info(f"Mirror manager available but using direct cleanup")
                    pass
            except (ImportError, AttributeError) as e:
                logger.warning(f"Mirror enhanced manager not available: {e}")

            # Fallback: Direct mirror order cleanup using get_all_open_orders
            try:
                from clients.bybit_helpers import get_all_open_orders
                from execution.mirror_trader import bybit_client_2, cancel_mirror_order

                if bybit_client_2:
                    # Get all mirror account orders for this symbol
                    mirror_orders = await get_all_open_orders(bybit_client_2)
                    symbol_orders = [o for o in mirror_orders if o.get('symbol') == symbol]

                    # Cancel all bot orders for this symbol (TP, SL, and limit)
                    cancelled_count = 0
                    for order in symbol_orders:
                        order_link_id = order.get('orderLinkId', '')
                        if ('BOT_' in order_link_id or 'MIRROR' in order_link_id) and order.get('orderStatus') == 'New':
                            try:
                                success = await cancel_mirror_order(symbol, order.get('orderId'))
                                if success:
                                    cancelled_count += 1
                                    logger.info(f"üßπ Cancelled mirror order: {order_link_id}")
                                else:
                                    logger.warning(f"‚ö†Ô∏è Failed to cancel mirror order: {order_link_id}")
                            except Exception as e:
                                logger.error(f"Error cancelling mirror order {order_link_id}: {e}")

                    logger.info(f"‚úÖ Mirror cleanup completed: {cancelled_count} orders cancelled")
                else:
                    logger.warning("Mirror client not available for order cleanup")

            except Exception as e:
                logger.error(f"Error in fallback mirror cleanup: {e}")

        except Exception as e:
            logger.error(f"Error cleaning up mirror account orders: {e}")

    async def _sync_breakeven_with_mirror(self, monitor_data: Dict):
        """Synchronize breakeven SL movement with mirror account"""
        try:
            # Check if mirror trading is enabled
            from execution.mirror_trader import is_mirror_trading_enabled
            if not is_mirror_trading_enabled():
                return

            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            monitor_key = f"{symbol}_{side}"

            # Use atomic lock to prevent race conditions
            if monitor_key not in self.mirror_sync_locks:
                self.mirror_sync_locks[monitor_key] = asyncio.Lock()

            async with self.mirror_sync_locks[monitor_key]:
                logger.info(f"ü™û Synchronizing breakeven with mirror account: {symbol} {side}")

                # Try to use mirror enhanced TP/SL manager
                try:
                    from execution.mirror_enhanced_tp_sl import initialize_mirror_manager
                    mirror_manager = initialize_mirror_manager(self)
                    if mirror_manager and hasattr(mirror_manager, 'sync_breakeven_movement'):
                        await mirror_manager.sync_breakeven_movement(monitor_data["symbol"], monitor_data["side"], monitor_data["avg_price"])
                        logger.info(f"‚úÖ Mirror breakeven synchronized via enhanced manager")
                        return
                except (ImportError, AttributeError) as e:
                    logger.warning(f"Mirror enhanced manager not available for breakeven sync: {e}")

                # Fallback: Direct mirror breakeven sync
                try:
                    from execution.mirror_trader import bybit_client_2
                    from clients.bybit_helpers import get_position_info, get_open_orders, cancel_order_with_retry, place_order_with_retry
                    from utils.order_identifier import generate_order_link_id, ORDER_TYPE_SL

                    if not bybit_client_2:
                        logger.warning("Mirror client not available for breakeven sync")
                        return

                    # Get mirror position
                    mirror_positions = await get_position_info(symbol, client=bybit_client_2)
                    mirror_position = None
                    if mirror_positions:
                        for pos in mirror_positions:
                            if pos.get("side") == side:
                                mirror_position = pos
                                break

                    if not mirror_position:
                        logger.warning(f"No mirror position found for {symbol} {side}")
                        return

                    # Calculate breakeven price for mirror (same as main)
                    entry_price = Decimal(str(mirror_position.get("avgPrice", "0")))
                    if entry_price <= 0:
                        logger.warning(f"Invalid mirror entry price: {entry_price}")
                        return

                    # Use same breakeven calculation as main account
                    fee_rate = Decimal("0.0006")  # 0.06% maker/taker
                    safety_margin = Decimal(str(BREAKEVEN_SAFETY_MARGIN))  # Additional safety

                    if side == "Buy":
                        breakeven_price = entry_price * (1 + fee_rate + safety_margin)
                    else:  # Sell
                        breakeven_price = entry_price * (1 - fee_rate - safety_margin)

                    # Cancel existing mirror SL orders
                    mirror_orders = await get_open_orders(bybit_client_2)
                    symbol_orders = [o for o in mirror_orders if o.get('symbol') == symbol]

                    for order in symbol_orders:
                        order_link_id = order.get('orderLinkId', '')
                        if 'MIRROR' in order_link_id and 'SL' in order_link_id:
                            await self._cancel_order_mirror(symbol, order.get('orderId'))
                            logger.info(f"üßπ Cancelled old mirror SL: {order_link_id}")

                    # Place new mirror breakeven SL
                    mirror_size = Decimal(str(mirror_position.get("size", "0")))
                    if mirror_size > 0:
                        sl_side = "Sell" if side == "Buy" else "Buy"
                        sl_order_link_id = generate_order_link_id("MIRROR", symbol, side, ORDER_TYPE_SL, 1)

                        sl_result = await place_order_with_retry(
                            symbol=symbol,
                            side=sl_side,
                            order_type="Limit",
                            qty=str(mirror_size),
                            price=str(breakeven_price),
                            reduce_only=True,
                            order_link_id=sl_order_link_id,
                            time_in_force="GTC",
                            position_idx=0,  # Mirror account is in One-Way mode
                            client=bybit_client_2
                        )

                        if sl_result and sl_result.get("orderId"):
                            logger.info(f"‚úÖ Mirror breakeven SL placed: {breakeven_price} for {mirror_size}")
                        else:
                            logger.error(f"‚ùå Failed to place mirror breakeven SL")

                except Exception as e:
                    logger.error(f"Error in fallback mirror breakeven sync: {e}")

        except Exception as e:
            logger.error(f"Error synchronizing breakeven with mirror account: {e}")

    async def get_position_status(self, symbol: str, side: str) -> Optional[Dict]:
        """Get current status of monitored position"""
        monitor_key = f"{symbol}_{side}"
        if monitor_key not in self.position_monitors:
            return None

        monitor_data = self.position_monitors[monitor_key]

        # Calculate filled percentage (ensure consistent types)
        filled_size = monitor_data["position_size"] - monitor_data["remaining_size"]
        position_size_decimal = Decimal(str(monitor_data["position_size"]))
        filled_size_decimal = Decimal(str(filled_size))
        filled_percentage = float((filled_size_decimal / position_size_decimal) * 100)

        return {
            "symbol": symbol,
            "side": side,
            "entry_price": monitor_data["entry_price"],
            "position_size": monitor_data["position_size"],
            "remaining_size": monitor_data["remaining_size"],
            "filled_percentage": filled_percentage,
            "tp_orders_count": len(monitor_data["tp_orders"]),
            "filled_tps": len(monitor_data["filled_tps"]),
            "sl_at_breakeven": monitor_data["sl_moved_to_be"],
            "monitoring_duration": time.time() - monitor_data["created_at"],
            "phase": monitor_data.get("phase", "UNKNOWN"),
            "tp1_hit": monitor_data.get("tp1_hit", False),
            "limit_orders_count": len(monitor_data.get("limit_orders", []))
        }

    def _track_order_lifecycle(self, order_id: str, order_type: str, symbol: str, side: str,
                               price: Decimal, quantity: Decimal, order_link_id: str = None):
        """
        Track comprehensive order lifecycle data for enhanced monitoring

        Args:
            order_id: Unique order identifier
            order_type: TP, SL, or LIMIT
            symbol: Trading symbol
            side: Buy/Sell
            price: Order price
            quantity: Order quantity
            order_link_id: Order link identifier
        """
        current_time = time.time()

        self.order_lifecycle[order_id] = {
            "order_id": order_id,
            "order_type": order_type,
            "symbol": symbol,
            "side": side,
            "price": price,
            "quantity": quantity,
            "original_quantity": quantity,
            "order_link_id": order_link_id,
            "status": "ACTIVE",
            "created_at": current_time,
            "last_updated": current_time,
            "fill_events": [],
            "modification_history": [],
            "execution_metrics": {
                "fill_rate": 0.0,
                "partial_fills": 0,
                "time_to_fill": None,
                "price_improvement": Decimal("0"),
                "slippage": Decimal("0")
            },
            "relationship_data": {
                "parent_position": f"{symbol}_{side}",
                "related_orders": [],
                "dependency_chain": []
            }
        }

        # Add to order relationships
        position_key = f"{symbol}_{side}"
        if position_key not in self.order_relationships:
            self.order_relationships[position_key] = {
                "tp_orders": [],
                "sl_orders": [],
                "limit_orders": [],
                "filled_orders": [],
                "cancelled_orders": []
            }

        # Categorize order
        if order_type == "TP":
            self.order_relationships[position_key]["tp_orders"].append(order_id)
        elif order_type == "SL":
            self.order_relationships[position_key]["sl_orders"].append(order_id)
        elif order_type == "LIMIT":
            self.order_relationships[position_key]["limit_orders"].append(order_id)

        logger.info(f"üìä Tracking order lifecycle: {order_id[:8]}... ({order_type})")

    def _update_order_status(self, order_id: str, new_status: str, fill_data: Dict = None):
        """
        Update order status and track fill events

        Args:
            order_id: Order identifier
            new_status: New order status (FILLED, PARTIAL_FILLED, CANCELLED, etc.)
            fill_data: Optional fill information
        """
        if order_id not in self.order_lifecycle:
            return

        order_data = self.order_lifecycle[order_id]
        old_status = order_data["status"]
        current_time = time.time()

        # Update basic status
        order_data["status"] = new_status
        order_data["last_updated"] = current_time

        # Handle fill events
        if fill_data and new_status in ["FILLED", "PARTIAL_FILLED"]:
            fill_event = {
                "timestamp": current_time,
                "fill_price": fill_data.get("fill_price", order_data["price"]),
                "fill_quantity": fill_data.get("fill_quantity", Decimal("0")),
                "cumulative_filled": fill_data.get("cumulative_filled", Decimal("0")),
                "remaining_quantity": fill_data.get("remaining_quantity", order_data["quantity"])
            }
            order_data["fill_events"].append(fill_event)

            # Update execution metrics
            metrics = order_data["execution_metrics"]
            metrics["partial_fills"] += 1

            # Calculate fill rate
            if order_data["original_quantity"] > 0:
                metrics["fill_rate"] = float(fill_data.get("cumulative_filled", 0) / order_data["original_quantity"])

            # Calculate time to fill for completed orders
            if new_status == "FILLED" and metrics["time_to_fill"] is None:
                metrics["time_to_fill"] = current_time - order_data["created_at"]

            # Calculate price improvement/slippage
            fill_price = fill_data.get("fill_price", order_data["price"])
            if isinstance(fill_price, (int, float, str)):
                fill_price = Decimal(str(fill_price))
            price_diff = fill_price - order_data["price"]

            if order_data["side"] == "Buy":
                metrics["price_improvement"] = -price_diff  # Negative diff is improvement for buys
            else:
                metrics["price_improvement"] = price_diff   # Positive diff is improvement for sells

            metrics["slippage"] = abs(price_diff)

            logger.info(f"üìà Order fill event: {order_id[:8]}... {old_status} ‚Üí {new_status}")

        # Update order relationships
        position_key = order_data["relationship_data"]["parent_position"]
        if position_key in self.order_relationships:
            relationships = self.order_relationships[position_key]

            if new_status == "FILLED":
                if order_id not in relationships["filled_orders"]:
                    relationships["filled_orders"].append(order_id)
            elif new_status == "CANCELLED":
                if order_id not in relationships["cancelled_orders"]:
                    relationships["cancelled_orders"].append(order_id)

    def _get_order_relationships(self, symbol: str, side: str) -> Dict:
        """
        Get comprehensive order relationship data for a position

        Returns:
            Dict containing all related orders and their statuses
        """
        position_key = f"{symbol}_{side}"
        if position_key not in self.order_relationships:
            return {}

        relationships = self.order_relationships[position_key].copy()

        # Add detailed order data
        for order_list in ["tp_orders", "sl_orders", "limit_orders", "filled_orders", "cancelled_orders"]:
            detailed_orders = []
            for order_id in relationships.get(order_list, []):
                if order_id in self.order_lifecycle:
                    detailed_orders.append(self.order_lifecycle[order_id])
            relationships[f"{order_list}_detailed"] = detailed_orders

        return relationships

    def _calculate_position_metrics(self, symbol: str, side: str) -> Dict:
        """
        Calculate comprehensive execution metrics for a position

        Returns:
            Dict containing position-level performance metrics
        """
        position_key = f"{symbol}_{side}"
        relationships = self._get_order_relationships(symbol, side)

        metrics = {
            "total_orders": 0,
            "filled_orders": 0,
            "cancelled_orders": 0,
            "partial_filled_orders": 0,
            "fill_rate": 0.0,
            "average_time_to_fill": 0.0,
            "total_slippage": Decimal("0"),
            "total_price_improvement": Decimal("0"),
            "execution_efficiency": 0.0
        }

        all_orders = []
        for order_type in ["tp_orders", "sl_orders", "limit_orders"]:
            all_orders.extend(relationships.get(f"{order_type}_detailed", []))

        if not all_orders:
            return metrics

        metrics["total_orders"] = len(all_orders)

        filled_times = []
        total_slippage = Decimal("0")
        total_improvement = Decimal("0")

        for order in all_orders:
            order_metrics = order.get("execution_metrics", {})
            status = order.get("status", "UNKNOWN")

            if status == "FILLED":
                metrics["filled_orders"] += 1
                time_to_fill = order_metrics.get("time_to_fill")
                if time_to_fill:
                    filled_times.append(time_to_fill)
            elif status == "CANCELLED":
                metrics["cancelled_orders"] += 1
            elif status == "PARTIAL_FILLED":
                metrics["partial_filled_orders"] += 1

            # Accumulate slippage and price improvement
            total_slippage += order_metrics.get("slippage", Decimal("0"))
            total_improvement += order_metrics.get("price_improvement", Decimal("0"))

        # Calculate averages
        if metrics["total_orders"] > 0:
            metrics["fill_rate"] = metrics["filled_orders"] / metrics["total_orders"]
            metrics["execution_efficiency"] = (metrics["filled_orders"] + metrics["partial_filled_orders"]) / metrics["total_orders"]

        if filled_times:
            metrics["average_time_to_fill"] = sum(filled_times) / len(filled_times)

        metrics["total_slippage"] = total_slippage
        metrics["total_price_improvement"] = total_improvement

        # Store in execution metrics cache
        self.execution_metrics[position_key] = metrics

        return metrics

    async def cleanup_orphaned_monitors(self):
        """
        Clean up monitors that no longer have corresponding positions
        This prevents resource leaks and memory buildup
        """
        try:
            monitors_to_remove = []

            logger.info("üßπ Starting orphaned monitor cleanup")

            for monitor_key, monitor_data in self.position_monitors.items():
                symbol = monitor_data["symbol"]
                side = monitor_data["side"]

                try:
                    # Check if position still exists
                    positions = await get_position_info(symbol)
                    position_exists = False

                    if positions:
                        for pos in positions:
                            if pos.get("side") == side and float(pos.get("size", 0)) > 0:
                                position_exists = True
                                break

                    if not position_exists:
                        # Position closed, schedule monitor for removal
                        monitors_to_remove.append(monitor_key)
                        logger.info(f"üìç Orphaned monitor found: {monitor_key}")

                        # Cancel monitoring task if running
                        if monitor_data.get("monitoring_task"):
                            monitor_data["monitoring_task"].cancel()

                        # Clean up related orders
                        await self._cleanup_monitor_orders(monitor_data)

                        # Clean up order lifecycle data
                        await self._cleanup_order_lifecycle_data(symbol, side)

                except Exception as e:
                    logger.error(f"Error checking position for {monitor_key}: {e}")

            # Remove orphaned monitors
            for monitor_key in monitors_to_remove:
                del self.position_monitors[monitor_key]
                logger.info(f"üóëÔ∏è Removed orphaned monitor: {monitor_key}")

            if monitors_to_remove:
                logger.info(f"‚úÖ Cleaned up {len(monitors_to_remove)} orphaned monitors")
            else:
                logger.debug("‚úÖ No orphaned monitors found")

        except Exception as e:
            logger.error(f"Error in orphaned monitor cleanup: {e}")

    async def _cleanup_monitor_orders(self, monitor_data: Dict):
        """
        Clean up orders associated with a monitor
        Cancels open orders and updates order lifecycle data
        """
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]

            # Cancel all TP orders
            # Ensure tp_orders is dict format
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            for order_id, tp_order in tp_orders.items():
                try:
                    # order_id = tp_order["order_id"]  # Now comes from iteration
                    if await cancel_order_with_retry(symbol, order_id):
                        logger.info(f"‚ùå Cancelled TP order: {order_id[:8]}...")
                        # Update order lifecycle
                        self._update_order_status(order_id, "CANCELLED")
                except Exception as e:
                    logger.error(f"Error cancelling TP order: {e}")

            # Cancel SL order
            if monitor_data.get("sl_order"):
                try:
                    sl_order_id = monitor_data["sl_order"]["order_id"]
                    if await cancel_order_with_retry(symbol, sl_order_id):
                        logger.info(f"üõ°Ô∏è Cancelled SL order: {sl_order_id[:8]}...")
                        # Update order lifecycle
                        self._update_order_status(sl_order_id, "CANCELLED")
                except Exception as e:
                    logger.error(f"Error cancelling SL order: {e}")

            # Cancel limit orders if in cleanup phase
            if monitor_data.get("cleanup_completed", False):
                for limit_order in monitor_data.get("limit_orders", []):
                    if isinstance(limit_order, dict) and limit_order.get("status") == "ACTIVE":
                        try:
                            order_id = limit_order["order_id"]
                            if await cancel_order_with_retry(symbol, order_id):
                                logger.info(f"üìù Cancelled limit order: {order_id[:8]}...")
                                limit_order["status"] = "CANCELLED"
                                # Update order lifecycle
                                self._update_order_status(order_id, "CANCELLED")
                        except Exception as e:
                            logger.error(f"Error cancelling limit order: {e}")

        except Exception as e:
            logger.error(f"Error cleaning up monitor orders: {e}")

    async def _cleanup_order_lifecycle_data(self, symbol: str, side: str):
        """
        Clean up order lifecycle and relationship data for a closed position
        """
        try:
            position_key = f"{symbol}_{side}"

            # Get all orders for this position
            if position_key in self.order_relationships:
                relationships = self.order_relationships[position_key]
                all_orders = []

                for order_type in ["tp_orders", "sl_orders", "limit_orders", "filled_orders", "cancelled_orders"]:
                    all_orders.extend(relationships.get(order_type, []))

                # Archive order data before cleanup (keep for analysis)
                archived_orders = {}
                for order_id in all_orders:
                    if order_id in self.order_lifecycle:
                        archived_orders[order_id] = self.order_lifecycle[order_id].copy()
                        # Mark as archived
                        archived_orders[order_id]["archived_at"] = time.time()
                        archived_orders[order_id]["status"] = "ARCHIVED"

                # Clean up active data structures
                for order_id in all_orders:
                    if order_id in self.order_lifecycle:
                        del self.order_lifecycle[order_id]

                # Store archived data for future analysis
                if not hasattr(self, 'archived_orders'):
                    self.archived_orders = {}
                self.archived_orders[position_key] = archived_orders

                # Clean up relationships
                del self.order_relationships[position_key]

                # Clean up execution metrics
                if position_key in self.execution_metrics:
                    # Archive metrics
                    if not hasattr(self, 'archived_metrics'):
                        self.archived_metrics = {}
                    self.archived_metrics[position_key] = self.execution_metrics[position_key]
                    del self.execution_metrics[position_key]

                logger.info(f"üóÇÔ∏è Archived lifecycle data for {len(all_orders)} orders from {position_key}")

        except Exception as e:
            logger.error(f"Error cleaning up order lifecycle data: {e}")

    async def perform_memory_cleanup(self):
        """
        Perform comprehensive memory cleanup to prevent resource leaks
        """
        try:
            logger.info("üß† Starting memory cleanup")

            # Clean up orphaned monitors
            await self.cleanup_orphaned_monitors()

            # Clean up stale price cache
            current_time = time.time()
            stale_symbols = []

            for symbol, (price, timestamp) in self.price_cache.items():
                if current_time - timestamp > self.price_cache_ttl * 10:  # 10x TTL for cleanup
                    stale_symbols.append(symbol)

            for symbol in stale_symbols:
                del self.price_cache[symbol]

            if stale_symbols:
                logger.info(f"üóëÔ∏è Cleaned up {len(stale_symbols)} stale price cache entries")

            # Archive old order lifecycle data (older than 24 hours)
            old_orders = []
            cutoff_time = current_time - (24 * 3600)  # 24 hours

            for order_id, order_data in self.order_lifecycle.items():
                if order_data.get("created_at", current_time) < cutoff_time and order_data.get("status") in ["FILLED", "CANCELLED"]:
                    old_orders.append(order_id)

            if old_orders:
                # Archive old orders
                if not hasattr(self, 'archived_orders'):
                    self.archived_orders = {}

                for order_id in old_orders:
                    order_data = self.order_lifecycle[order_id]
                    position_key = order_data["relationship_data"]["parent_position"]

                    if position_key not in self.archived_orders:
                        self.archived_orders[position_key] = {}

                    self.archived_orders[position_key][order_id] = order_data.copy()
                    self.archived_orders[position_key][order_id]["archived_at"] = current_time

                    del self.order_lifecycle[order_id]

                logger.info(f"üì¶ Archived {len(old_orders)} old orders")

            # Limit archived data size (keep only last 1000 positions)
            if hasattr(self, 'archived_orders') and len(self.archived_orders) > 1000:
                # Keep only most recent 1000
                sorted_positions = sorted(
                    self.archived_orders.items(),
                    key=lambda x: max([order.get("archived_at", 0) for order in x[1].values()]),
                    reverse=True
                )
                self.archived_orders = dict(sorted_positions[:1000])
                logger.info("üì¶ Trimmed archived orders to 1000 most recent positions")

            logger.info("‚úÖ Memory cleanup completed")

        except Exception as e:
            logger.error(f"Error in memory cleanup: {e}")

    async def get_resource_usage_stats(self) -> Dict:
        """
        Get current resource usage statistics
        """
        try:
            stats = {
                "active_monitors": len(self.position_monitors),
                "tracked_orders": len(self.order_lifecycle),
                "order_relationships": len(self.order_relationships),
                "execution_metrics": len(self.execution_metrics),
                "price_cache_entries": len(self.price_cache),
                "archived_orders": len(getattr(self, 'archived_orders', {})),
                "archived_metrics": len(getattr(self, 'archived_metrics', {})),
                "memory_usage": {
                    "monitors": len(str(self.position_monitors)),
                    "lifecycle": len(str(self.order_lifecycle)),
                    "relationships": len(str(self.order_relationships))
                }
            }

            # Calculate active vs completed orders
            active_orders = 0
            completed_orders = 0

            for order_data in self.order_lifecycle.values():
                if order_data.get("status") in ["ACTIVE", "PARTIAL_FILLED"]:
                    active_orders += 1
                else:
                    completed_orders += 1

            stats["order_status_breakdown"] = {
                "active": active_orders,
                "completed": completed_orders
            }

            return stats

        except Exception as e:
            logger.error(f"Error getting resource usage stats: {e}")
            return {}

    def start_cleanup_scheduler(self):
        """
        Start the periodic cleanup scheduler
        """
        if self.cleanup_task is None:
            self.cleanup_task = asyncio.create_task(self._cleanup_scheduler_loop())
            logger.info("‚úÖ Started Enhanced TP/SL cleanup scheduler")

    def stop_cleanup_scheduler(self):
        """
        Stop the periodic cleanup scheduler
        """
        if self.cleanup_task:
            self.cleanup_task.cancel()
            self.cleanup_task = None
            logger.info("‚èπÔ∏è Stopped Enhanced TP/SL cleanup scheduler")

    async def _cleanup_scheduler_loop(self):
        """
        Periodic cleanup scheduler loop
        """
        try:
            while True:
                await asyncio.sleep(self.cleanup_interval)

                try:
                    current_time = time.time()

                    # Check if it's time for cleanup
                    if current_time - self.last_cleanup >= self.cleanup_interval:
                        logger.info("‚è∞ Scheduled cleanup starting")
                        await self.perform_memory_cleanup()
                        self.last_cleanup = current_time

                        # Also trigger mirror cleanup if available
                        try:
                            from execution.mirror_enhanced_tp_sl import initialize_mirror_manager
                            mirror_manager = initialize_mirror_manager(self)
                            if mirror_manager and hasattr(mirror_manager, 'perform_mirror_memory_cleanup'):
                                await mirror_manager.perform_mirror_memory_cleanup()
                        except:
                            pass

                except Exception as e:
                    logger.error(f"Error in cleanup scheduler: {e}")

        except asyncio.CancelledError:
            logger.info("üìã Cleanup scheduler cancelled")
        except Exception as e:
            logger.error(f"Fatal error in cleanup scheduler: {e}")

    def _get_circuit_breaker_key(self, symbol: str, side: str) -> str:
        """Get circuit breaker key for position"""
        return f"{symbol}_{side}"

    def _check_circuit_breaker(self, symbol: str, side: str) -> bool:
        """
        Check if circuit breaker allows operations for this position
        Returns True if operations are allowed, False if circuit is open
        """
        cb_key = self._get_circuit_breaker_key(symbol, side)

        if cb_key not in self.circuit_breaker_state:
            # Initialize circuit breaker
            self.circuit_breaker_state[cb_key] = {
                "state": "CLOSED",  # CLOSED, OPEN, HALF_OPEN
                "failure_count": 0,
                "last_failure_time": 0,
                "recovery_timeout": 300,  # 5 minutes
                "failure_threshold": 5
            }
            return True

        cb_state = self.circuit_breaker_state[cb_key]
        current_time = time.time()

        if cb_state["state"] == "CLOSED":
            return True
        elif cb_state["state"] == "OPEN":
            # Check if recovery timeout has passed
            if current_time - cb_state["last_failure_time"] > cb_state["recovery_timeout"]:
                cb_state["state"] = "HALF_OPEN"
                logger.info(f"üîÑ Circuit breaker transitioning to HALF_OPEN for {cb_key}")
                return True
            return False
        else:  # HALF_OPEN
            return True

    def _record_circuit_breaker_success(self, symbol: str, side: str):
        """Record successful operation for circuit breaker"""
        cb_key = self._get_circuit_breaker_key(symbol, side)

        if cb_key in self.circuit_breaker_state:
            cb_state = self.circuit_breaker_state[cb_key]
            if cb_state["state"] == "HALF_OPEN":
                cb_state["state"] = "CLOSED"
                cb_state["failure_count"] = 0
                logger.info(f"‚úÖ Circuit breaker closed for {cb_key}")

    def _record_circuit_breaker_failure(self, symbol: str, side: str):
        """Record failed operation for circuit breaker"""
        cb_key = self._get_circuit_breaker_key(symbol, side)

        if cb_key not in self.circuit_breaker_state:
            self._check_circuit_breaker(symbol, side)  # Initialize

        cb_state = self.circuit_breaker_state[cb_key]
        cb_state["failure_count"] += 1
        cb_state["last_failure_time"] = time.time()

        if cb_state["failure_count"] >= cb_state["failure_threshold"]:
            cb_state["state"] = "OPEN"
            logger.warning(f"‚ö†Ô∏è Circuit breaker opened for {cb_key} (failures: {cb_state['failure_count']})")

    async def _execute_with_recovery(self, operation_name: str, operation_func, *args, **kwargs):
        """
        Execute an operation with automatic error recovery and circuit breaker

        Args:
            operation_name: Name of the operation for logging
            operation_func: The async function to execute
            *args, **kwargs: Arguments to pass to the operation function

        Returns:
            Operation result or None if all attempts failed
        """
        if not self.error_recovery_enabled:
            return await operation_func(*args, **kwargs)

        symbol = kwargs.get('symbol', args[0] if args else 'UNKNOWN')
        side = kwargs.get('side', args[1] if len(args) > 1 else 'UNKNOWN')

        # Check circuit breaker
        if not self._check_circuit_breaker(symbol, side):
            logger.warning(f"üö´ Circuit breaker open for {symbol} {side}, skipping {operation_name}")
            return None

        operation_id = f"{operation_name}_{symbol}_{side}_{int(time.time())}"

        for attempt in range(1, self.max_recovery_attempts + 1):
            try:
                logger.debug(f"üîÑ Executing {operation_name} (attempt {attempt}/{self.max_recovery_attempts})")

                result = await operation_func(*args, **kwargs)

                # Success - record for circuit breaker and clean up failure tracking
                self._record_circuit_breaker_success(symbol, side)
                if operation_id in self.failed_operations:
                    del self.failed_operations[operation_id]

                return result

            except Exception as e:
                logger.error(f"‚ùå {operation_name} attempt {attempt} failed: {e}")

                # Record failure
                failure_data = {
                    "operation_name": operation_name,
                    "symbol": symbol,
                    "side": side,
                    "attempt": attempt,
                    "error": str(e),
                    "timestamp": time.time(),
                    "args": str(args),
                    "kwargs": str(kwargs)
                }
                self.failed_operations[operation_id] = failure_data

                # Record circuit breaker failure
                self._record_circuit_breaker_failure(symbol, side)

                # If this is the last attempt, give up
                if attempt >= self.max_recovery_attempts:
                    logger.error(f"üí• {operation_name} failed after {self.max_recovery_attempts} attempts")
                    break

                # Calculate backoff delay
                backoff_delay = attempt * self.recovery_backoff_multiplier
                logger.info(f"‚è≥ Waiting {backoff_delay}s before retry {attempt + 1}")
                await asyncio.sleep(backoff_delay)

        return None

    async def _recover_failed_order_placement(self, symbol: str, side: str, order_type: str):
        """
        Attempt to recover from failed order placement
        Checks if order was actually placed and updates tracking accordingly
        """
        try:
            logger.info(f"üîß Attempting order placement recovery for {symbol} {side} {order_type}")

            # Get current open orders to check if order was placed despite error
            open_orders = await get_open_orders(symbol)
            if not open_orders:
                return False

            monitor_key = f"{symbol}_{side}"
            if monitor_key not in self.position_monitors:
                return False

            monitor_data = self.position_monitors[monitor_key]

            # Check for orders that might have been placed
            recovered_orders = []

            for order in open_orders:
                order_link_id = order.get("orderLinkId", "")
                if not order_link_id or not order_link_id.startswith("BOT_"):
                    continue

                # Check if this order belongs to our position
                if order_type == "TP" and "TP" in order_link_id:
                    # Check if we already have this order tracked
                    order_id = order.get("orderId")
                    already_tracked = any(tp["order_id"] == order_id for tp in monitor_data.get("tp_orders", []))

                    if not already_tracked:
                        # Add to tracking
                        tp_order = {
                            "order_id": order_id,
                            "order_link_id": order_link_id,
                            "price": Decimal(str(order.get("price", 0))),
                            "quantity": Decimal(str(order.get("qty", 0))),
                            "original_quantity": Decimal(str(order.get("qty", 0))),
                            "tp_number": len(monitor_data.get("tp_orders", [])) + 1
                        }

                        if "tp_orders" not in monitor_data:
                            monitor_data["tp_orders"] = {}
                        # Use order_id as key for dict format
                        monitor_data["tp_orders"][order_id] = tp_order

                        # Track in lifecycle
                        self._track_order_lifecycle(
                            order_id=order_id,
                            order_type="TP",
                            symbol=symbol,
                            side=order.get("side", side),
                            price=tp_order["price"],
                            quantity=tp_order["quantity"],
                            order_link_id=order_link_id
                        )

                        recovered_orders.append(f"TP:{order_id[:8]}...")

                elif order_type == "SL" and "SL" in order_link_id:
                    # Check if we already have this SL order tracked
                    order_id = order.get("orderId")
                    current_sl = monitor_data.get("sl_order", {})

                    if current_sl.get("order_id") != order_id:
                        # Update SL tracking
                        monitor_data["sl_order"] = {
                            "order_id": order_id,
                            "order_link_id": order_link_id,
                            "price": Decimal(str(order.get("triggerPrice", order.get("price", 0)))),
                            "quantity": Decimal(str(order.get("qty", 0))),
                            "original_quantity": Decimal(str(order.get("qty", 0)))
                        }

                        # Track in lifecycle
                        self._track_order_lifecycle(
                            order_id=order_id,
                            order_type="SL",
                            symbol=symbol,
                            side=order.get("side", side),
                            price=monitor_data["sl_order"]["price"],
                            quantity=monitor_data["sl_order"]["quantity"],
                            order_link_id=order_link_id
                        )

                        recovered_orders.append(f"SL:{order_id[:8]}...")

            if recovered_orders:
                logger.info(f"‚úÖ Recovered {len(recovered_orders)} orders: {', '.join(recovered_orders)}")
                return True

            return False

        except Exception as e:
            logger.error(f"Error in order placement recovery: {e}")
            return False

    async def _handle_monitor_error(self, symbol: str, side: str, error: Exception):
        """
        Handle errors in position monitoring with recovery attempts
        """
        try:
            monitor_key = f"{symbol}_{side}"

            logger.warning(f"üö® Monitor error for {symbol} {side}: {error}")

            # Check if circuit breaker allows recovery attempts
            if not self._check_circuit_breaker(symbol, side):
                logger.warning(f"üö´ Circuit breaker prevents recovery for {symbol} {side}")
                return

            # Attempt to recover monitoring
            recovery_successful = await self._execute_with_recovery(
                "monitor_recovery",
                self._recover_monitor_state,
                symbol,
                side
            )

            if recovery_successful:
                logger.info(f"‚úÖ Monitor recovery successful for {symbol} {side}")
            else:
                logger.error(f"üí• Monitor recovery failed for {symbol} {side}")

                # Consider stopping monitoring if recovery fails
                if monitor_key in self.position_monitors:
                    monitor_data = self.position_monitors[monitor_key]
                    if monitor_data.get("monitoring_task"):
                        monitor_data["monitoring_task"].cancel()
                        logger.warning(f"‚èπÔ∏è Stopped monitoring for {symbol} {side} due to persistent errors")

        except Exception as e:
            logger.error(f"Error in monitor error handling: {e}")

    async def _recover_monitor_state(self, symbol: str, side: str):
        """
        Attempt to recover monitor state by re-syncing with exchange
        """
        try:
            monitor_key = f"{symbol}_{side}"
            if monitor_key not in self.position_monitors:
                raise Exception(f"Monitor {monitor_key} not found")

            monitor_data = self.position_monitors[monitor_key]

            # Get current position state
            positions = await get_position_info(symbol)
            if not positions:
                raise Exception("Could not fetch position info")

            position = None
            for pos in positions:
                if pos.get("side") == side:
                    position = pos
                    break

            if not position or float(position.get("size", 0)) == 0:
                # Position closed, clean up monitor
                await self.cleanup_position_orders(symbol, side)
                return True

            # Update monitor data with current position state
            current_size = Decimal(str(position["size"]))
            monitor_data["remaining_size"] = current_size

            # Save to persistence after update
            self.save_monitors_to_persistence()
            monitor_data["last_check"] = time.time()

            # Verify and sync orders
            await self._verify_and_sync_orders(symbol, side)

            logger.info(f"üîÑ Monitor state recovered for {symbol} {side}")
            return True

        except Exception as e:
            logger.error(f"Error recovering monitor state: {e}")
            raise

    async def _verify_and_sync_orders(self, symbol: str, side: str):
        """
        Verify that tracked orders still exist and sync with exchange state
        """
        try:
            monitor_key = f"{symbol}_{side}"
            if monitor_key not in self.position_monitors:
                return

            monitor_data = self.position_monitors[monitor_key]

            # Get current open orders
            open_orders = await get_open_orders(symbol)
            if not open_orders:
                return

            open_order_ids = {order.get("orderId") for order in open_orders if order.get("orderId")}

            # Check TP orders
            # Ensure tp_orders is dict format
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            for order_id, tp_order in tp_orders.items():
                # order_id = tp_order["order_id"]  # Now comes from iteration
                if order_id not in open_order_ids:
                    # Order no longer exists, update lifecycle
                    self._update_order_status(order_id, "FILLED")
                    logger.info(f"üéØ TP order {order_id[:8]}... marked as filled during sync")

            # Check SL order
            if monitor_data.get("sl_order"):
                sl_order_id = monitor_data["sl_order"]["order_id"]
                if sl_order_id not in open_order_ids:
                    # SL order no longer exists
                    self._update_order_status(sl_order_id, "FILLED")
                    logger.info(f"üõ°Ô∏è SL order {sl_order_id[:8]}... marked as filled during sync")

            # Check limit orders
            for limit_order in monitor_data.get("limit_orders", []):
                if isinstance(limit_order, dict) and limit_order.get("status") == "ACTIVE":
                    order_id = limit_order["order_id"]
                    if order_id not in open_order_ids:
                        limit_order["status"] = "FILLED"
                        self._update_order_status(order_id, "FILLED")
                        logger.info(f"üìù Limit order {order_id[:8]}... marked as filled during sync")

        except Exception as e:
            logger.error(f"Error verifying and syncing orders: {e}")

    def get_error_recovery_stats(self) -> Dict:
        """
        Get error recovery and resilience statistics
        """
        try:
            current_time = time.time()

            # Count recent failures (last 24 hours)
            recent_failures = 0
            recent_cutoff = current_time - (24 * 3600)

            for failure_data in self.failed_operations.values():
                if failure_data.get("timestamp", 0) > recent_cutoff:
                    recent_failures += 1

            # Circuit breaker states
            circuit_breaker_stats = {}
            for cb_key, cb_state in self.circuit_breaker_state.items():
                circuit_breaker_stats[cb_key] = {
                    "state": cb_state["state"],
                    "failure_count": cb_state["failure_count"],
                    "last_failure": cb_state.get("last_failure_time", 0)
                }

            return {
                "error_recovery_enabled": self.error_recovery_enabled,
                "total_failed_operations": len(self.failed_operations),
                "recent_failures_24h": recent_failures,
                "max_recovery_attempts": self.max_recovery_attempts,
                "circuit_breakers": circuit_breaker_stats,
                "recovery_settings": {
                    "backoff_multiplier": self.recovery_backoff_multiplier,
                    "enabled": self.error_recovery_enabled
                }
            }

        except Exception as e:
            logger.error(f"Error getting recovery stats: {e}")
            return {}

    async def _update_order_statuses(self, symbol: str, side: str):
        """
        Update order statuses by checking current open orders
        This tracks fills, cancellations, and other order state changes
        """
        try:
            position_key = f"{symbol}_{side}"
            if position_key not in self.order_relationships:
                return

            # Get current open orders
            open_orders = await get_open_orders(symbol)
            if not open_orders:
                return

            # Create a set of currently open order IDs for quick lookup
            open_order_ids = set()
            open_orders_data = {}

            for order in open_orders:
                order_id = order.get("orderId")
                if order_id:
                    open_order_ids.add(order_id)
                    open_orders_data[order_id] = order

            # Check all tracked orders for this position
            relationships = self.order_relationships[position_key]
            all_tracked_orders = []

            for order_type in ["tp_orders", "sl_orders", "limit_orders"]:
                all_tracked_orders.extend(relationships.get(order_type, []))

            for order_id in all_tracked_orders:
                if order_id not in self.order_lifecycle:
                    continue

                order_data = self.order_lifecycle[order_id]
                current_status = order_data["status"]

                if order_id in open_order_ids:
                    # Order is still open, check for partial fills
                    open_order = open_orders_data[order_id]

                    # Check if order has been partially filled
                    cum_qty = open_order.get("cumExecQty", "0")
                    order_qty = open_order.get("qty", "0")

                    if cum_qty and cum_qty != "0":
                        cum_filled = Decimal(str(cum_qty))
                        total_qty = Decimal(str(order_qty))
                        remaining_qty = total_qty - cum_filled

                        fill_data = {
                            "fill_price": Decimal(str(open_order.get("avgPrice", order_data["price"]))),
                            "fill_quantity": cum_filled,
                            "cumulative_filled": cum_filled,
                            "remaining_quantity": remaining_qty
                        }

                        if cum_filled == total_qty:
                            # Fully filled
                            if current_status != "FILLED":
                                self._update_order_status(order_id, "FILLED", fill_data)
                        elif cum_filled > 0:
                            # Partially filled
                            if current_status != "PARTIAL_FILLED":
                                self._update_order_status(order_id, "PARTIAL_FILLED", fill_data)
                    else:
                        # Order is open but not filled
                        if current_status != "ACTIVE":
                            self._update_order_status(order_id, "ACTIVE")
                else:
                    # Order is not in open orders - it was either filled or cancelled
                    if current_status in ["ACTIVE", "PARTIAL_FILLED"]:
                        # Check if it was filled or cancelled by checking position history
                        # For now, assume it was filled if it's not cancelled elsewhere

                        # Try to get order history/details
                        try:
                            # We'll mark it as filled for now - a more sophisticated implementation
                            # would check order history to determine if it was filled or cancelled
                            self._update_order_status(order_id, "FILLED")
                        except:
                            # If we can't determine, mark as unknown
                            self._update_order_status(order_id, "UNKNOWN")

            # Calculate and update position metrics
            metrics = self._calculate_position_metrics(symbol, side)
            logger.debug(f"üìä Updated order statuses for {symbol} {side}: {metrics['filled_orders']}/{metrics['total_orders']} filled")

        except Exception as e:
            logger.error(f"Error updating order statuses for {symbol} {side}: {e}")

    async def register_limit_orders(self, symbol: str, side: str, limit_order_ids: List[str]):
        """
        Register limit orders for position building phase
        This allows the Enhanced TP/SL system to track and manage entry limit orders

        Args:
            symbol: Trading symbol
            side: Buy or Sell
            limit_order_ids: List of order IDs for limit orders
        """
        monitor_key = f"{symbol}_{side}"
        if monitor_key not in self.position_monitors:
            logger.warning(f"Cannot register limit orders - no monitor found for {symbol} {side}")
            return

        monitor_data = self.position_monitors[monitor_key]

        # Add limit orders to tracking
        for order_id in limit_order_ids:
            limit_order = {
                "order_id": order_id,
                "registered_at": time.time(),
                "status": "ACTIVE"
            }
            monitor_data["limit_orders"].append(limit_order)

            # Track limit order lifecycle (without price/quantity details since they're entry orders)
            # Note: We track these as LIMIT type but they're entry orders, not TP orders
            self._track_order_lifecycle(
                order_id=order_id,
                order_type="LIMIT",
                symbol=symbol,
                side=side,  # Use position side for limit entry orders
                price=Decimal("0"),  # Will be updated when we get order details
                quantity=Decimal("0"),  # Will be updated when we get order details
                order_link_id=None  # Entry orders may not have our standard link IDs
            )

        logger.info(f"üìù Registered {len(limit_order_ids)} limit orders for {symbol} {side}")
        logger.info(f"   Phase: {monitor_data['phase']}")
        logger.info(f"   Total limit orders tracked: {len(monitor_data['limit_orders'])}")

        # FIX: Start monitoring if not already active (for limit order fill detection)
        if not monitor_data.get("monitoring_task") or monitor_data["monitoring_task"].done():
            logger.info(f"üîÑ Starting monitoring for limit order fill detection: {symbol} {side}")
            monitor_task = asyncio.create_task(self._run_monitor_loop(symbol, side))
            monitor_data["monitoring_task"] = monitor_task

    async def _cancel_unfilled_limit_orders(self, monitor_data: Dict):
        """
        Cancel all unfilled limit orders during phase transition
        This is called when moving from BUILDING to PROFIT_TAKING phase
        Enhanced to support both main and mirror accounts
        """
        symbol = monitor_data["symbol"]
        side = monitor_data["side"]

        # Determine account type from monitor data
        # Check if this is a mirror account position
        is_mirror_account = self._is_mirror_position(monitor_data)
        account_label = "mirror" if is_mirror_account else "main"

        cancelled_count = 0
        failed_count = 0

        # Get appropriate cancel function based on account type
        cancel_function = self._get_cancel_function(is_mirror_account)

        logger.info(f"üßπ Cancelling unfilled limit orders for {symbol} {side} ({account_label} account)")

        # Primary method: Cancel orders tracked in monitor data
        tracked_orders = monitor_data.get("limit_orders", [])
        if tracked_orders:
            for limit_order in tracked_orders:
                # Handle both dict and string formats
                if isinstance(limit_order, str):
                    # Legacy format: limit_order is just an order ID string
                    order_id = limit_order
                    try:
                        # Check if this order was already attempted recently
                        from utils.order_state_cache import order_state_cache
                        if not await order_state_cache.is_order_cancellable(order_id):
                            logger.info(f"‚ÑπÔ∏è Skipping {account_label} limit order {order_id[:8]}... (already processed)")
                            continue

                        success = await cancel_function(symbol, order_id)
                        if success:
                            cancelled_count += 1
                            logger.info(f"‚úÖ Cancelled {account_label} limit order {order_id[:8]}...")
                        else:
                            failed_count += 1
                            logger.warning(f"‚ö†Ô∏è Failed to cancel {account_label} limit order {order_id[:8]}...")
                    except Exception as e:
                        failed_count += 1
                        logger.error(f"‚ùå Error cancelling {account_label} limit order {order_id[:8]}...: {e}")
                elif isinstance(limit_order, dict) and limit_order.get("status") == "ACTIVE":
                    # New format: limit_order is a dict with order details
                    order_id = limit_order.get("order_id")
                    if not order_id:
                        continue

                    try:
                        # Check if this order was already attempted recently
                        from utils.order_state_cache import order_state_cache
                        if not await order_state_cache.is_order_cancellable(order_id):
                            logger.info(f"‚ÑπÔ∏è Skipping {account_label} limit order {order_id[:8]}... (already processed)")
                            limit_order["status"] = "PROCESSED"
                            continue

                        success = await cancel_function(symbol, order_id)
                        if success:
                            limit_order["status"] = "CANCELLED"
                            limit_order["cancelled_at"] = time.time()
                            cancelled_count += 1
                            logger.info(f"‚úÖ Cancelled {account_label} limit order {order_id[:8]}...")
                        else:
                            # Mark as failed but don't retry endlessly
                            limit_order["status"] = "FAILED"
                            failed_count += 1
                            logger.warning(f"‚ö†Ô∏è Failed to cancel {account_label} limit order {order_id[:8]}...")
                    except Exception as e:
                        # Mark as failed to prevent retry loops
                        limit_order["status"] = "FAILED"
                        failed_count += 1
                        logger.error(f"‚ùå Error cancelling {account_label} limit order {order_id[:8]}...: {e}")
        else:
            # Fallback method: Scan live orders and cancel bot limit orders
            logger.info(f"üì° No tracked orders found, scanning live orders for {symbol} {side}")
            try:
                additional_cancelled = await self._cancel_live_limit_orders(symbol, side, is_mirror_account)
                cancelled_count += additional_cancelled
            except Exception as e:
                logger.error(f"‚ùå Error scanning live orders: {e}")
                failed_count += 1

        if cancelled_count > 0:
            logger.info(f"üßπ Limit order cleanup: {cancelled_count} cancelled, {failed_count} failed")

            # Send alert about limit order cleanup
            try:
                chat_id = monitor_data["chat_id"]
                message = (
                    f"üßπ <b>Limit Orders Cleaned Up</b>\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üìä {symbol} {side}\n"
                    f"üéØ TP1 hit - Phase: PROFIT_TAKING\n"
                    f"üßπ Cancelled: {cancelled_count} limit orders\n"
                    f"‚úÖ Focus: Pure profit-taking mode"
                )

                await send_trade_alert(chat_id, message)
                logger.info(f"‚úÖ Sent limit order cleanup alert for {symbol} {side}")
            except Exception as e:
                logger.error(f"Error sending limit order cleanup alert: {e}")

    async def _transition_to_profit_taking(self, monitor_data: Dict):
        """
        Transition position from BUILDING phase to PROFIT_TAKING phase
        This happens when TP1 (85%) is hit
        ENHANCED: Added atomic locks to prevent race conditions
        """
        symbol = monitor_data["symbol"]
        side = monitor_data["side"]
        monitor_key = f"{symbol}_{side}"

        # Use atomic lock to prevent race conditions during phase transition
        if monitor_key not in self.phase_transition_locks:
            self.phase_transition_locks[monitor_key] = asyncio.Lock()

        async with self.phase_transition_locks[monitor_key]:
            # Double-check phase after acquiring lock
            if monitor_data.get("phase") == "BUILDING":
                logger.info(f"üîÑ Transitioning {symbol} {side} from BUILDING to PROFIT_TAKING phase")

                # Cancel unfilled limit orders if enabled
                if CANCEL_LIMITS_ON_TP1:
                    await self._cancel_unfilled_limit_orders(monitor_data)
                else:
                    logger.info(f"‚ÑπÔ∏è Limit order cleanup disabled (CANCEL_LIMITS_ON_TP1=false)")

                # Update phase atomically
                monitor_data["phase"] = "PROFIT_TAKING"
                monitor_data["phase_transition_time"] = time.time()
                monitor_data["tp1_hit"] = True

                logger.info(f"‚úÖ Phase transition complete: {symbol} {side} now in PROFIT_TAKING mode")
            else:
                logger.debug(f"üîÑ Phase transition skipped for {symbol} {side} - already in {monitor_data.get('phase', 'UNKNOWN')} phase")

    async def _send_tp_fill_alert(self, monitor_data: Dict, fill_percentage: float):
        """Send premium quality alert when TP order is filled"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            chat_id = monitor_data["chat_id"]

            # Skip alert if no chat_id (e.g., for mirror positions)
            if not chat_id:
                logger.info(f"‚úÖ Sent premium TP fill alert for {symbol} {side} - TP")
                return

            approach = monitor_data.get("approach", "conservative").lower()
            entry_price = monitor_data["entry_price"]
            bot_instance = monitor_data.get("bot_instance")

            # Get current market price for P&L calculation
            from clients.bybit_helpers import get_current_price
            current_price = await get_current_price(symbol)
            if not current_price:
                current_price = entry_price

            # Calculate P&L and percentage (ensure consistent types)
            filled_size = monitor_data["position_size"] * Decimal(str(fill_percentage)) / Decimal("100")
            current_price_decimal = Decimal(str(current_price))
            entry_price_decimal = Decimal(str(entry_price))

            if side == "Buy":
                pnl = (current_price_decimal - entry_price_decimal) * filled_size
                pnl_percent = float(((current_price_decimal - entry_price_decimal) / entry_price_decimal) * 100)
            else:  # Sell
                pnl = (entry_price_decimal - current_price_decimal) * filled_size
                pnl_percent = float(((entry_price_decimal - current_price_decimal) / entry_price_decimal) * 100)

            # Determine approach emoji and TP number
            approach_emoji = {"fast": "‚ö°", "conservative": "üõ°Ô∏è", "ggshot": "üì∏"}.get(approach, "üéØ")
            side_emoji = "üìà" if side == "Buy" else "üìâ"

            # Determine which TP was filled
            if fill_percentage >= 85:
                tp_number = 1
                tp_text = "TP1"
            elif fill_percentage >= 10:
                tp_number = 2
                tp_text = "TP2"
            elif fill_percentage >= 5:
                tp_number = 3 if fill_percentage < 10 else 4
                tp_text = f"TP{tp_number}"
            else:
                tp_number = 1
                tp_text = "TP"

            # Get remaining TPs for conservative/ggshot approaches
            remaining_tps = []
            if approach in ["conservative", "ggshot"]:
                for i in range(tp_number + 1, 5):  # TP2, TP3, TP4
                    remaining_tps.append(f"TP{i}")

            message = f"""üéØ <b>{tp_text} HIT - PROFIT TAKEN!</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
{approach_emoji} {approach.capitalize()} Approach
üìä {symbol} {side_emoji} {side}

üí∞ <b>Profit: ${pnl:.2f} ({pnl_percent:+.2f}%)</b>
üìç Entry: ${entry_price:.6f}
üéØ Exit: ${current_price:.6f}
üì¶ Size: {filled_size:.6f}
"""

            # Add remaining TPs information for conservative/ggshot
            if remaining_tps:
                message += f"\n‚úÖ <b>Active TPs:</b> {', '.join(remaining_tps)}"

            # Add breakeven information for TP1
            if tp_number == 1 and approach in ["conservative", "ggshot"]:
                message += f"\n\nüîÑ <b>STOP LOSS MOVED TO BREAKEVEN</b>"
                message += f"\nüõ°Ô∏è SL adjusted to entry + fees"
                message += f"\nüìä Includes 0.12% fees + safety margin"
                message += f"\n‚úÖ Position is now risk-free!"

            # Add remaining position info
            message += f"\n\nüìä <b>Position Status:</b>"
            message += f"\nüí∞ Remaining Size: {monitor_data['remaining_size']:.6f}"
            message += f"\nüìâ Position Reduced: {fill_percentage:.1f}%"

            await send_trade_alert(chat_id, message.strip())
            logger.info(f"‚úÖ Sent premium TP fill alert for {symbol} {side} - {tp_text}")

        except Exception as e:
            logger.error(f"Error sending TP fill alert: {e}")

    async def _send_breakeven_alert(self, monitor_data: Dict):
        """Send premium quality alert when SL is moved to breakeven with comprehensive context"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            chat_id = monitor_data["chat_id"]
            approach = monitor_data.get("approach", "unknown").lower()

            # Get detailed position information
            entry_price = monitor_data["entry_price"]
            current_price = await get_current_price(symbol)
            remaining_size = monitor_data.get("remaining_size", monitor_data["position_size"])
            original_sl_price = monitor_data.get("original_sl_price", "N/A")
            new_sl_price = monitor_data["sl_order"]["price"]

            # Calculate current unrealized P&L (ensure consistent types)
            if current_price and entry_price:
                current_price_decimal = Decimal(str(current_price))
                entry_price_decimal = Decimal(str(entry_price))
                remaining_size_decimal = Decimal(str(remaining_size))

                if side == "Buy":
                    current_pnl = (current_price_decimal - entry_price_decimal) * remaining_size_decimal
                    current_pnl_percent = float(((current_price_decimal - entry_price_decimal) / entry_price_decimal) * 100)
                else:  # Sell
                    current_pnl = (entry_price_decimal - current_price_decimal) * remaining_size_decimal
                    current_pnl_percent = float(((entry_price_decimal - current_price_decimal) / entry_price_decimal) * 100)
            else:
                current_pnl = Decimal("0")
                current_pnl_percent = 0

            # Calculate how much profit is now secured
            total_position_size = monitor_data["position_size"]
            total_position_size_decimal = Decimal(str(total_position_size))
            remaining_size_decimal = Decimal(str(remaining_size))
            filled_percentage = float(((total_position_size_decimal - remaining_size_decimal) / total_position_size_decimal) * 100)

            # Get remaining TP orders count
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            active_tps = len([tp for tp in tp_orders.values() if isinstance(tp, dict) and tp.get("status") != "FILLED"])

            # Determine approach emoji and text
            if approach == "conservative":
                approach_emoji = "üõ°Ô∏è"
                approach_text = "Conservative"
            elif approach == "ggshot":
                approach_emoji = "üì∏"
                approach_text = "GGShot"
            # Fast approach removed
            else:
                approach_emoji = "üéØ"
                approach_text = approach.capitalize()

            # Side emoji
            side_emoji = "üìà" if side == "Buy" else "üìâ"

            # P&L emoji
            pnl_emoji = "üí∞" if current_pnl >= 0 else "üìä"

            message = f"""üõ°Ô∏è <b>STOP LOSS MOVED TO BREAKEVEN</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
{approach_emoji} {approach_text} Approach
üìä {symbol} {side_emoji} {side}

‚úÖ <b>POSITION NOW RISK-FREE!</b>

üìç <b>Price Movement:</b>
‚Ä¢ Entry Price: ${entry_price:.6f}
‚Ä¢ Current Price: ${current_price:.6f}
‚Ä¢ Original SL: ${original_sl_price}
‚Ä¢ New SL: ${new_sl_price:.6f}

{pnl_emoji} <b>Current P&L: ${current_pnl:.2f} ({current_pnl_percent:+.2f}%)</b>

üìä <b>Position Status:</b>
‚Ä¢ Remaining Size: {remaining_size:.6f}
‚Ä¢ Position Filled: {filled_percentage:.1f}%
‚Ä¢ Active TPs: {active_tps}
‚Ä¢ Protected Against Loss: 100%

üîí <b>Risk Protection:</b>
‚Ä¢ SL adjusted to entry + fees
‚Ä¢ Includes 0.06% trading fees
‚Ä¢ Includes safety margin
‚Ä¢ Worst case: Break-even exit

üí° <b>What This Means:</b>
‚Ä¢ Zero downside risk remaining
‚Ä¢ All profit from here is pure gain
‚Ä¢ Can hold position confidently
‚Ä¢ TP targets remain active"""

            # Add approach-specific context
            if approach == "conservative":
                message += f"\n\nüõ°Ô∏è <b>Conservative Strategy:</b>\n‚Ä¢ TP1 (85%) has been hit\n‚Ä¢ Remaining TPs will capture additional gains\n‚Ä¢ Position scaled gradually for risk reduction"
            elif approach == "ggshot":
                message += f"\n\nüì∏ <b>GGShot Strategy:</b>\n‚Ä¢ AI analysis proved successful\n‚Ä¢ Screenshot parameters executed correctly\n‚Ä¢ Smart risk management active"
            # Fast approach removed

            await send_trade_alert(chat_id, message)
            logger.info(f"‚úÖ Sent premium breakeven alert for {symbol} {side} - Position now risk-free")

        except Exception as e:
            logger.error(f"Error sending breakeven alert: {e}")

    async def _send_limit_fill_alert(self, monitor_data: Dict, fill_percentage: float):
        """Send premium quality alert when limit order is filled with comprehensive context"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            chat_id = monitor_data["chat_id"]
            approach = monitor_data.get("approach", "unknown").lower()

            # Get current market price for context
            current_price = await get_current_price(symbol)
            if current_price:
                current_price = Decimal(str(current_price))  # Convert to Decimal for type consistency
            entry_price = monitor_data["entry_price"]

            # Calculate filled size and remaining position
            total_position_size = monitor_data["position_size"]
            filled_size = total_position_size * Decimal(str(fill_percentage)) / Decimal("100")
            remaining_size = total_position_size - filled_size

            # Calculate P&L for filled portion (realized gain/loss) - ensure consistent types
            if current_price and entry_price:
                current_price_decimal = Decimal(str(current_price))
                entry_price_decimal = Decimal(str(entry_price))

                if side == "Buy":
                    fill_pnl = (current_price_decimal - entry_price_decimal) * filled_size
                    fill_pnl_percent = float(((current_price_decimal - entry_price_decimal) / entry_price_decimal) * 100)
                else:  # Sell
                    fill_pnl = (entry_price_decimal - current_price_decimal) * filled_size
                    fill_pnl_percent = float(((entry_price_decimal - current_price_decimal) / entry_price_decimal) * 100)
            else:
                fill_pnl = Decimal("0")
                fill_pnl_percent = 0

            # Get filled limit orders count for context
            filled_limits = len([lo for lo in monitor_data.get("limit_orders", []) if isinstance(lo, dict) and lo.get("status") == "FILLED"])
            total_limits = len(monitor_data.get("limit_orders", []))

            # Determine approach emoji and text
            if approach == "conservative":
                approach_emoji = "üõ°Ô∏è"
                approach_text = "Conservative"
            elif approach == "ggshot":
                approach_emoji = "üì∏"
                approach_text = "GGShot"
            # Fast approach removed
            else:
                approach_emoji = "üéØ"
                approach_text = approach.capitalize()

            # Side emoji
            side_emoji = "üìà" if side == "Buy" else "üìâ"

            # P&L emoji and formatting
            pnl_emoji = "üí∞" if fill_pnl >= 0 else "üìâ"

            message = f"""üì¶ <b>LIMIT ORDER FILLED</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
{approach_emoji} {approach_text} Approach
üìä {symbol} {side_emoji} {side}

‚úÖ <b>Fill Details:</b>
üéØ Percentage: {fill_percentage:.2f}% of position
üì¶ Size: {filled_size:.6f}
üíµ Fill Price: ${current_price:.6f}
üìç Entry Price: ${entry_price:.6f}

{pnl_emoji} <b>Partial P&L: ${fill_pnl:.2f} ({fill_pnl_percent:+.2f}%)</b>

üìä <b>Position Status:</b>
‚Ä¢ Filled Limits: {filled_limits}/{total_limits}
‚Ä¢ Remaining Size: {remaining_size:.6f}
‚Ä¢ Position Progress: {(filled_size/total_position_size)*100:.1f}%

üîÑ <b>Automatic Adjustments:</b>
‚Ä¢ TP/SL orders rebalanced
‚Ä¢ Quantities updated for remaining size
‚Ä¢ Risk management maintained"""

            # Add approach-specific context
            if approach == "conservative":
                message += f"\n\nüõ°Ô∏è <b>Conservative Mode:</b>\n‚Ä¢ Position being filled gradually\n‚Ä¢ 85/5/5/5 TP distribution maintained\n‚Ä¢ Progressive risk reduction active"
            elif approach == "ggshot":
                message += f"\n\nüì∏ <b>GGShot Mode:</b>\n‚Ä¢ AI-analyzed entry execution\n‚Ä¢ Screenshot-based parameters\n‚Ä¢ Smart order management active"

            await send_trade_alert(chat_id, message)
            logger.info(f"‚úÖ Sent premium limit fill alert for {symbol} {side} - {fill_percentage:.2f}% filled")

        except Exception as e:
            logger.error(f"Error sending limit fill alert: {e}")

    async def _send_position_closed_alert(self, monitor_data: Dict):
        """Send premium quality alert when position is fully closed with comprehensive summary"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            chat_id = monitor_data["chat_id"]

            # Skip alert if no chat_id
            if not chat_id:
                logger.warning(f"‚ö†Ô∏è No chat_id for {symbol} {side} - skipping position closed alert")
                return

            approach = monitor_data.get("approach", "unknown").lower()
            entry_price = monitor_data["entry_price"]

            # Handle missing position_size key
            position_size = monitor_data.get("position_size")
            if position_size is None:
                # Try alternative keys
                position_size = monitor_data.get("current_size") or monitor_data.get("remaining_size")
                if position_size is None:
                    logger.warning(f"Position size not found in monitor data for {symbol} {side}")
                    logger.warning(f"Available keys in monitor_data: {list(monitor_data.keys())}")
                    return

            # Convert to Decimal for consistent arithmetic operations
            entry_price_decimal = Decimal(str(entry_price))
            position_size_decimal = Decimal(str(position_size))

            # Calculate trade duration
            trade_duration_minutes = (time.time() - monitor_data['created_at']) / 60
            if trade_duration_minutes < 60:
                duration_text = f"{trade_duration_minutes:.1f} minutes"
            else:
                hours = int(trade_duration_minutes // 60)
                mins = int(trade_duration_minutes % 60)
                duration_text = f"{hours}h {mins}m"

            # Get final position info for P&L and exit price
            positions = await get_position_info(symbol)
            position = None
            if positions:
                for pos in positions:
                    if pos.get("side") == side:
                        position = pos
                        break

            if position:
                pnl = Decimal(str(position.get("unrealisedPnl", "0")))
                exit_price = Decimal(str(position.get("markPrice", entry_price)))
                realized_pnl = Decimal(str(position.get("realizedPnl", "0")))
            else:
                # Position fully closed - use last known price
                current_price = await get_current_price(symbol)
                exit_price = Decimal(str(current_price)) if current_price else entry_price_decimal

                # Calculate final P&L (all values are now Decimal)
                if side == "Buy":
                    pnl = (exit_price - entry_price_decimal) * position_size_decimal
                else:  # Sell
                    pnl = (entry_price_decimal - exit_price) * position_size_decimal
                realized_pnl = pnl

            # Calculate P&L percentage (all values are Decimal)
            if entry_price_decimal > 0:
                if side == "Buy":
                    pnl_percent = float(((exit_price - entry_price_decimal) / entry_price_decimal) * 100)
                else:  # Sell
                    pnl_percent = float(((entry_price_decimal - exit_price) / entry_price_decimal) * 100)
            else:
                pnl_percent = 0

            # Determine approach emoji and text
            if approach == "conservative":
                approach_emoji = "üõ°Ô∏è"
                approach_text = "Conservative"
            elif approach == "ggshot":
                approach_emoji = "üì∏"
                approach_text = "GGShot"
            # Fast approach removed
            else:
                approach_emoji = "üéØ"
                approach_text = approach.capitalize()

            # Side emoji
            side_emoji = "üìà" if side == "Buy" else "üìâ"

            # P&L emoji and result text
            if pnl > 0:
                pnl_emoji = "üü¢"
                result_text = "PROFIT"
            elif pnl < 0:
                pnl_emoji = "üî¥"
                result_text = "LOSS"
            else:
                pnl_emoji = "‚ö™"
                result_text = "BREAKEVEN"

            # Get TP fill summary
            tp_orders = self._ensure_tp_orders_dict(monitor_data)
            filled_tps = len([tp for tp in tp_orders.values() if isinstance(tp, dict) and tp.get("status") == "FILLED"])
            total_tps = len(tp_orders)

            message = f"""{pnl_emoji} <b>POSITION CLOSED - {result_text}</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
{approach_emoji} {approach_text} Approach
üìä {symbol} {side_emoji} {side}

üí∞ <b>Final P&L: ${pnl:.2f} ({pnl_percent:+.2f}%)</b>

üìç <b>Trade Summary:</b>
‚Ä¢ Entry Price: ${entry_price:.6f}
‚Ä¢ Exit Price: ${exit_price:.6f}
‚Ä¢ Position Size: {position_size:.6f}
‚Ä¢ Duration: {duration_text}

üìä <b>Execution Summary:</b>
‚Ä¢ TPs Hit: {filled_tps}/{total_tps}
‚Ä¢ Approach: {approach_text}
‚Ä¢ Enhanced TP/SL Management
‚Ä¢ Risk Protection Active

üéØ <b>Performance:</b>"""

            # Add performance context
            if pnl_percent > 5:
                message += f"\n‚Ä¢ Excellent trade! üèÜ"
            elif pnl_percent > 1:
                message += f"\n‚Ä¢ Good profit captured ‚úÖ"
            elif pnl_percent > -1:
                message += f"\n‚Ä¢ Near breakeven trade ‚öñÔ∏è"
            elif pnl_percent > -5:
                message += f"\n‚Ä¢ Small loss contained üõ°Ô∏è"
            else:
                message += f"\n‚Ä¢ Loss managed by SL üîí"

            # Add approach-specific context
            if approach == "conservative":
                message += f"\n\nüõ°Ô∏è <b>Conservative Results:</b>\n‚Ä¢ Risk managed through scaling\n‚Ä¢ Multiple TP levels utilized\n‚Ä¢ Gradual profit realization"
            elif approach == "ggshot":
                message += f"\n\nüì∏ <b>GGShot Results:</b>\n‚Ä¢ AI analysis execution complete\n‚Ä¢ Screenshot parameters validated\n‚Ä¢ Smart order management success"
            # Fast approach removed

            # Send the enhanced alert first
            await send_trade_alert(chat_id, message)

            # Then send the detailed summary using the existing function
            # Use Decimal versions of variables to avoid type mismatch
            await send_position_closed_summary(
                chat_id=chat_id,
                symbol=symbol,
                side=side,
                approach=approach,
                entry_price=float(entry_price_decimal),
                exit_price=float(exit_price),
                position_size=float(position_size_decimal),
                pnl=float(pnl),
                duration_minutes=int(trade_duration_minutes)
            )

            logger.info(f"‚úÖ Sent premium position closed alert for {symbol} {side} - {result_text}: ${pnl:.2f}")

        except Exception as e:
            logger.error(f"Error sending position closed alert: {e}")

    async def _handle_position_closure(self, monitor_data: Dict, position: Dict):
        """Handle when position is completely closed - determine if it was TP or SL"""
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            chat_id = monitor_data["chat_id"]

            # Skip alert if no chat_id
            if not chat_id:
                logger.warning(f"‚ö†Ô∏è No chat_id for {symbol} {side} - skipping position closure handling")
                # Still update remaining size to 0
                monitor_data["remaining_size"] = Decimal("0")
                return

            # Check active orders to see what might have triggered
            active_orders = await get_open_orders(symbol)

            # Check if SL order is missing (likely it triggered)
            sl_still_active = False
            if monitor_data.get("sl_order"):
                sl_order_id = monitor_data["sl_order"]["order_id"]
                sl_still_active = any(o.get("orderId") == sl_order_id for o in active_orders)

            # If SL is missing and position closed, SL was likely hit
            if not sl_still_active and monitor_data.get("sl_order"):
                # SL hit alert
                sl_price = monitor_data["sl_order"]["price"]
                entry_price = monitor_data["entry_price"]

                # Calculate loss
                if side == "Buy":
                    loss_pct = ((sl_price - entry_price) / entry_price) * 100
                else:
                    loss_pct = ((entry_price - sl_price) / entry_price) * 100

                message = (
                    f"üî¥ <b>Stop Loss Hit!</b>\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üìä {symbol} {side}\n"
                    f"üìç Entry: {entry_price}\n"
                    f"üõë Stop: {sl_price}\n"
                    f"üìâ Loss: {abs(loss_pct):.2f}%\n"
                    f"‚è±Ô∏è Duration: {(time.time() - monitor_data['created_at'])/60:.1f} mins"
                )

                await send_trade_alert(chat_id, message, alert_type="sl_hit")
                logger.info(f"üî¥ Sent SL hit alert for {symbol} {side}")

            # Update remaining size to 0
            monitor_data["remaining_size"] = Decimal("0")

            # Remove monitor_tasks entry
            approach = monitor_data.get("approach", "conservative")
            await self._remove_monitor_tasks_entry(symbol, side, chat_id, approach, "main")

        except Exception as e:
            logger.error(f"Error handling position closure: {e}")

    async def _run_monitor_loop(self, symbol: str, side: str, account_type: str = None):
        """Run continuous monitoring loop for a position"""
        # Use account-aware key if account_type is provided
        if account_type:
            monitor_key = f"{symbol}_{side}_{account_type}"
        else:
            # Legacy support
            monitor_key = f"{symbol}_{side}"
        logger.info(f"üîÑ Starting enhanced monitor loop for {monitor_key}")

        try:
            while monitor_key in self.position_monitors:
                # Check if position still exists
                positions = await get_position_info_for_account(symbol, account_type)
                position = None
                if positions:
                    # Find the position for our side
                    for pos in positions:
                        if pos.get("side") == side:
                            position = pos
                            break

                if not position or float(position.get('size', 0)) == 0:
                    logger.info(f"‚úÖ Position {symbol} {side} closed - ending monitor loop")
                    if monitor_key in self.position_monitors:
                        del self.position_monitors[monitor_key]
                    break

                # Run monitoring check with account type
                await self.monitor_and_adjust_orders(symbol, side, account_type)

                # Check if still active
                if monitor_key not in self.position_monitors:
                    break

                # Wait before next check (12 seconds like regular monitors)
                await asyncio.sleep(12)

        except asyncio.CancelledError:
            logger.info(f"‚èπÔ∏è Monitor loop cancelled for {symbol} {side}")
        except Exception as e:
            logger.error(f"‚ùå Error in monitor loop for {symbol} {side}: {e}")
        finally:
            # Cleanup using robust persistence
            if monitor_key in self.position_monitors:
                monitor_data = self.position_monitors[monitor_key]
                chat_id = monitor_data.get("chat_id")
                approach = monitor_data.get("approach", "conservative")

                # Remove monitor using robust persistence
                try:
                    from utils.robust_persistence import remove_trade_monitor
                    await remove_trade_monitor(symbol, side, reason="monitor_stopped")
                    logger.info(f"‚úÖ Removed monitor using Robust Persistence: {monitor_key}")
                except Exception as e:
                    logger.error(f"Error removing monitor via robust persistence: {e}")

                del self.position_monitors[monitor_key]
            logger.info(f"üõë Monitor loop ended for {symbol} {side}")

    async def _create_monitor_tasks_entry(self, symbol: str, side: str, chat_id: int, approach: str, account_type: str = "main"):
        """Create monitor_tasks entry for dashboard compatibility"""
        try:
            # Load bot_data directly from persistence for monitor_tasks compatibility
            import pickle
            pkl_path = '/Users/lualakol/bybit-telegram-bot/bybit_bot_dashboard_v4.1_enhanced.pkl'

            # Load current bot data
            with open(pkl_path, 'rb') as f:
                data = pickle.load(f)

            if 'bot_data' not in data:
                data['bot_data'] = {}

            bot_data = data['bot_data']

            # Initialize monitor_tasks if not exists
            if 'monitor_tasks' not in bot_data:
                bot_data['monitor_tasks'] = {}
                logger.info("Created monitor_tasks in bot_data")

            # Create monitor key based on account type
            if account_type == "mirror":
                monitor_key = f"{chat_id}_{symbol}_{approach}_mirror"
                monitoring_mode = f"ENHANCED_TP_SL_MIRROR"
            else:
                monitor_key = f"{chat_id}_{symbol}_{approach}"
                monitoring_mode = f"ENHANCED_TP_SL"

            # Check if monitor already exists
            if monitor_key in bot_data['monitor_tasks']:
                existing_monitor = bot_data['monitor_tasks'][monitor_key]
                if existing_monitor.get('active', False):
                    logger.info(f"Monitor already exists and active: {monitor_key}")
                    return
                # Reactivate existing monitor
                existing_monitor.update({
                    'monitoring_mode': monitoring_mode,
                    'started_at': time.time(),
                    'active': True,
                    'account_type': account_type,
                    'system_type': 'enhanced_tp_sl'
                })
                logger.info(f"‚úÖ Reactivated monitor: {monitor_key}")
            else:
                # Create new monitor
                bot_data['monitor_tasks'][monitor_key] = {
                    'chat_id': chat_id,
                    'symbol': symbol,
                    'approach': approach.lower(),
                    'monitoring_mode': monitoring_mode,
                    'started_at': time.time(),
                    'active': True,
                    'account_type': account_type,
                    'system_type': 'enhanced_tp_sl',
                    'side': side  # Add side for hedge mode compatibility
                }
                logger.info(f"‚úÖ Created Enhanced TP/SL monitor: {monitor_key}")

            # Save updated data back to persistence
            with open(pkl_path, 'wb') as f:
                pickle.dump(data, f)

        except Exception as e:
            logger.error(f"Error creating monitor_tasks entry: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

    async def create_dashboard_monitor_entry(self, symbol: str, side: str, chat_id: int, approach: str, account_type: str = "main"):
        """Create monitor using Robust Persistence Manager for reliability"""
        try:
            # Use robust persistence manager
            from utils.robust_persistence import add_trade_monitor

            # Get current position info if available
            position_data = {}
            if symbol in self.position_monitors and side in [m.get('side') for m in self.position_monitors.values() if m.get('symbol') == symbol]:
                monitor_key = f"{symbol}_{side}"
                if monitor_key in self.position_monitors:
                    position_data = {
                        'size': self.position_monitors[monitor_key].get('position_size', 0),
                        'avgPrice': self.position_monitors[monitor_key].get('entry_price', 0),
                        'side': side,
                        'symbol': symbol
                    }

            # Create monitor data
            dashboard_key = f"{chat_id}_{symbol}_{approach}" if account_type == "main" else f"{chat_id}_{symbol}_{approach}_mirror"

            monitor_data = {
                'symbol': symbol,
                'side': side,
                'chat_id': chat_id,
                'approach': approach.lower(),
                'account_type': account_type,
                'dashboard_key': dashboard_key,
                'entry_price': position_data.get('avgPrice', 0),
                'position_size': position_data.get('size', self.position_monitors.get(f"{symbol}_{side}", {}).get('position_size', 0)),
                'stop_loss': self.position_monitors.get(f"{symbol}_{side}", {}).get('stop_loss', 0),
                'take_profits': self.position_monitors.get(f"{symbol}_{side}", {}).get('tp_orders', []),
                'created_at': time.time(),
                'system_type': 'enhanced_tp_sl'
            }

            # Add monitor using robust persistence
            await add_trade_monitor(symbol, side, monitor_data, position_data)
            logger.info(f"‚úÖ Created monitor using Robust Persistence: {symbol}_{side}")

        except Exception as e:
            logger.error(f"Error in NEW dashboard monitor creation method: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

    async def _remove_monitor_tasks_entry(self, symbol: str, side: str, chat_id: int, approach: str, account_type: str = "main"):
        """Remove monitor_tasks entry when position is closed"""
        try:
            # Load bot_data directly from persistence for monitor_tasks compatibility
            import pickle
            pkl_path = '/Users/lualakol/bybit-telegram-bot/bybit_bot_dashboard_v4.1_enhanced.pkl'

            # Load current bot data
            with open(pkl_path, 'rb') as f:
                data = pickle.load(f)

            if 'bot_data' not in data:
                return

            bot_data = data['bot_data']

            if 'monitor_tasks' not in bot_data:
                return

            # Create monitor key based on account type
            if account_type == "mirror":
                monitor_key = f"{chat_id}_{symbol}_{approach}_mirror"
            else:
                monitor_key = f"{chat_id}_{symbol}_{approach}"

            # Remove or deactivate monitor
            if monitor_key in bot_data['monitor_tasks']:
                # Mark as inactive first
                bot_data['monitor_tasks'][monitor_key]['active'] = False
                # Then delete completely
                del bot_data['monitor_tasks'][monitor_key]
                logger.info(f"üóëÔ∏è Removed Enhanced TP/SL monitor: {monitor_key}")

                # Save updated data back to persistence
                with open(pkl_path, 'wb') as f:
                    pickle.dump(data, f)

        except Exception as e:
            logger.error(f"Error removing monitor_tasks entry: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

    async def _move_sl_to_breakeven_enhanced_v2(
        self,
        monitor_data: Dict,
        position: Dict,
        is_tp1_trigger: bool = False
    ) -> bool:
        """
        ENHANCED: Move SL to breakeven with full position management

        Args:
            monitor_data: Monitor data for the position
            position: Current position data from exchange
            is_tp1_trigger: Whether this is triggered by TP1 (85%) fill

        Returns:
            bool: Success status
        """
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]

            logger.info(f"üéØ ENHANCED BREAKEVEN V2: Starting for {symbol} {side}")

            # Get current position data
            entry_price = Decimal(str(position.get("avgPrice", "0")))
            current_size = Decimal(str(position.get("size", "0")))

            if entry_price <= 0 or current_size <= 0:
                logger.error(f"Invalid position data: entry_price={entry_price}, current_size={current_size}")
                return False

            # Calculate breakeven price with fees and safety margin
            fee_rate = Decimal("0.0006")  # 0.06% maker/taker
            safety_margin = Decimal("0.0002")  # Additional 0.02% safety

            if side == "Buy":
                breakeven_price = entry_price * (Decimal("1") + fee_rate + safety_margin)
            else:  # Sell
                breakeven_price = entry_price * (Decimal("1") - fee_rate - safety_margin)

            logger.info(f"üìä Breakeven calculation: entry={entry_price}, breakeven={breakeven_price}")

            # Get current SL order
            sl_order = monitor_data.get("sl_order", {})
            if not sl_order or not sl_order.get("order_id"):
                logger.error("No existing SL order found to modify")
                return False

            # Cancel existing SL order
            old_sl_id = sl_order["order_id"]
            logger.info(f"üóëÔ∏è Cancelling old SL order: {old_sl_id[:8]}...")

            cancel_success = await cancel_order_with_retry(symbol, old_sl_id)
            if not cancel_success:
                logger.error(f"Failed to cancel existing SL order: {old_sl_id}")
                return False

            # ENHANCED: Calculate new SL quantity based on TP1 trigger
            sl_quantity = self._calculate_full_position_sl_quantity(
                approach=monitor_data["approach"],
                current_size=current_size,
                target_size=monitor_data["position_size"],
                tp1_hit=is_tp1_trigger
            )

            # Place new breakeven SL order
            sl_side = "Sell" if side == "Buy" else "Buy"
            position_idx = await get_correct_position_idx(symbol, side)

            new_sl_order_link_id = generate_adjusted_order_link_id(
                sl_order.get("order_link_id", ""), "BREAKEVEN"
            )

            logger.info(f"üõ°Ô∏è Placing breakeven SL: {sl_quantity} @ {breakeven_price}")

            sl_result = await place_order_with_retry(
                symbol=symbol,
                side=sl_side,
                order_type="Market",
                qty=str(sl_quantity),
                trigger_price=str(breakeven_price),
                reduce_only=True,
                order_link_id=new_sl_order_link_id,
                position_idx=position_idx,
                stop_order_type="StopLoss"
            )

            if sl_result and sl_result.get("orderId"):
                new_sl_id = sl_result["orderId"]

                # Update monitor data with new SL info
                monitor_data["sl_order"] = {
                    "order_id": new_sl_id,
                    "order_link_id": new_sl_order_link_id,
                    "price": breakeven_price,
                    "quantity": sl_quantity,
                    "original_quantity": sl_quantity,
                    "breakeven": True,
                    "covers_full_position": True,  # Always 100% coverage
                    "target_position_size": monitor_data["position_size"]
                }

                # Track new order in lifecycle
                self._track_order_lifecycle(
                    order_id=new_sl_id,
                    order_type="SL",
                    symbol=symbol,
                    side=sl_side,
                    price=breakeven_price,
                    quantity=sl_quantity,
                    order_link_id=new_sl_order_link_id
                )

                logger.info(f"‚úÖ ENHANCED breakeven SL placed: {new_sl_id[:8]}...")
                return True
            else:
                logger.error("Failed to place new breakeven SL order")
                return False

        except Exception as e:
            logger.error(f"‚ùå Error in enhanced breakeven V2: {e}")
            return False

    async def _handle_progressive_tp_fills(
        self,
        monitor_data: Dict,
        fill_percentage: float,
        current_size: Decimal
    ):
        """
        ENHANCED: Handle progressive TP fills (TP2, TP3, TP4) with automatic SL adjustments

        Args:
            monitor_data: Monitor data for the position
            fill_percentage: Current fill percentage
            current_size: Current remaining position size
        """
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            monitor_key = f"{symbol}_{side}"

            # Determine which TP level was hit based on cumulative percentages
            # Conservative approach: TP1=85%, TP2=90%, TP3=95%, TP4=100%
            if fill_percentage >= 90 and not monitor_data.get("tp2_processed", False):
                tp_level = "TP2"
                monitor_data["tp2_processed"] = True
            elif fill_percentage >= 95 and not monitor_data.get("tp3_processed", False):
                tp_level = "TP3"
                monitor_data["tp3_processed"] = True
            elif fill_percentage >= 99 and not monitor_data.get("tp4_processed", False):
                tp_level = "TP4"
                monitor_data["tp4_processed"] = True
            else:
                # No new TP level hit
                return

            logger.info(f"üéØ PROGRESSIVE TP: {tp_level} hit for {monitor_key} ({fill_percentage:.2f}% filled)")

            # Use atomic lock for progressive adjustments
            if monitor_key not in self.breakeven_locks:
                self.breakeven_locks[monitor_key] = asyncio.Lock()

            async with self.breakeven_locks[monitor_key]:
                # Get current position data
                positions = await get_position_info(symbol)
                position = None
                if positions:
                    for pos in positions:
                        if pos.get("side") == side:
                            position = pos
                            break

                if not position:
                    logger.warning(f"No position found for progressive TP adjustment: {symbol} {side}")
                    return

                # Adjust SL quantity to match remaining position
                success = await self._adjust_sl_quantity_progressive(
                    monitor_data=monitor_data,
                    current_size=current_size,
                    tp_level=tp_level
                )

                if success:
                    logger.info(f"‚úÖ Progressive SL adjustment completed for {tp_level}")

                    # Send progressive TP alert
                    await self._send_progressive_tp_alert(monitor_data, tp_level, fill_percentage)

                    # Sync with mirror account
                    await self._sync_progressive_adjustment_with_mirror(monitor_data, tp_level)
                else:
                    logger.error(f"‚ùå Progressive SL adjustment failed for {tp_level}")

        except Exception as e:
            logger.error(f"‚ùå Error in progressive TP fills handling: {e}")

    async def _adjust_sl_quantity_progressive(
        self,
        monitor_data: Dict,
        current_size: Decimal,
        tp_level: str
    ) -> bool:
        """
        ENHANCED: Adjust SL quantity for progressive TP fills

        Args:
            monitor_data: Monitor data for the position
            current_size: Current remaining position size
            tp_level: TP level that was hit (TP2, TP3, TP4)

        Returns:
            bool: Success status
        """
        try:
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]

            # Get current SL order
            sl_order = monitor_data.get("sl_order", {})
            if not sl_order or not sl_order.get("order_id"):
                logger.error(f"No SL order to adjust for {tp_level}")
                return False

            current_sl_quantity = sl_order.get("quantity", Decimal("0"))

            # Check if adjustment is needed (SL quantity should match remaining position)
            if abs(current_sl_quantity - current_size) < Decimal("0.001"):
                logger.info(f"SL quantity already matches remaining position for {tp_level}")
                return True

            logger.info(f"üîß {tp_level} SL ADJUSTMENT: {current_sl_quantity} ‚Üí {current_size}")

            # Cancel current SL
            old_sl_id = sl_order["order_id"]
            cancel_success = await cancel_order_with_retry(symbol, old_sl_id)

            if not cancel_success:
                logger.error(f"Failed to cancel SL for {tp_level} adjustment")
                return False

            # Place new SL with adjusted quantity
            sl_side = "Sell" if side == "Buy" else "Buy"
            position_idx = await get_correct_position_idx(symbol, side)

            new_sl_order_link_id = generate_adjusted_order_link_id(
                sl_order.get("order_link_id", ""), f"{tp_level}_ADJ"
            )

            sl_result = await place_order_with_retry(
                symbol=symbol,
                side=sl_side,
                order_type="Market",
                qty=str(current_size),
                trigger_price=str(sl_order["price"]),  # Keep same breakeven price
                reduce_only=True,
                order_link_id=new_sl_order_link_id,
                position_idx=position_idx,
                stop_order_type="StopLoss"
            )

            if sl_result and sl_result.get("orderId"):
                new_sl_id = sl_result["orderId"]

                # Update monitor data
                monitor_data["sl_order"]["order_id"] = new_sl_id
                monitor_data["sl_order"]["order_link_id"] = new_sl_order_link_id
                monitor_data["sl_order"]["quantity"] = current_size
                monitor_data["sl_order"][f"{tp_level.lower()}_adjusted"] = True

                logger.info(f"‚úÖ {tp_level} SL quantity adjusted: {new_sl_id[:8]}...")
                return True
            else:
                logger.error(f"Failed to place adjusted SL for {tp_level}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Error adjusting SL quantity for {tp_level}: {e}")
            return False

    async def _send_enhanced_breakeven_alert(self, monitor_data: Dict, tp_level: str):
        """Send enhanced breakeven alert with detailed information"""
        try:
            chat_id = monitor_data["chat_id"]
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            sl_order = monitor_data.get("sl_order", {})

            message = f"""üéØ <b>ENHANCED {tp_level} BREAKEVEN ACHIEVED!</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä {symbol} {"üìà" if side == "Buy" else "üìâ"} {side}

‚úÖ <b>Position Now Risk-Free!</b>
üõ°Ô∏è SL moved to breakeven: ${sl_order.get('price', 'N/A'):.6f}
üìè SL quantity: {sl_order.get('quantity', 'N/A')}
üîß Coverage: {"Full position" if sl_order.get("covers_full_position", False) else "Remaining position"}

üéâ <b>Achievement Unlocked:</b>
‚Ä¢ {tp_level} target reached (85%+ filled)
‚Ä¢ Zero-risk position achieved
‚Ä¢ Profits now secured
‚Ä¢ Advanced SL management active

üîÑ <b>Next Steps:</b>
‚Ä¢ Monitoring continues for remaining TPs
‚Ä¢ Progressive SL adjustments enabled
‚Ä¢ Mirror account synchronized

‚ú® Your position is fully protected with enhanced coverage!"""

            await send_trade_alert(chat_id, message, f"enhanced_breakeven_{tp_level.lower()}")

        except Exception as e:
            logger.error(f"Error sending enhanced breakeven alert: {e}")

    async def _send_progressive_tp_alert(self, monitor_data: Dict, tp_level: str, fill_percentage: float):
        """Send progressive TP fill alert"""
        try:
            chat_id = monitor_data["chat_id"]
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]

            message = f"""üéØ <b>{tp_level} TARGET HIT!</b>
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìä {symbol} {"üìà" if side == "Buy" else "üìâ"} {side}

‚úÖ <b>{tp_level} Filled:</b> {fill_percentage:.2f}%
üõ°Ô∏è SL automatically adjusted to remaining position
üîß Progressive management active

üéâ <b>Progress:</b>
‚Ä¢ TP1 ‚úÖ (Breakeven achieved)
‚Ä¢ {tp_level} ‚úÖ (Current fill)
{"‚Ä¢ Remaining TPs pending" if tp_level != "TP4" else "‚Ä¢ All targets completed! üèÜ"}

üîÑ <b>System Status:</b>
‚Ä¢ Enhanced SL management: Active
‚Ä¢ Position protection: Maintained
‚Ä¢ Mirror sync: Completed

{"üèÜ Congratulations on completing all targets!" if tp_level == "TP4" else "üöÄ Continuing to monitor remaining targets!"}"""

            await send_trade_alert(chat_id, message, f"progressive_tp_{tp_level.lower()}")

        except Exception as e:
            logger.error(f"Error sending progressive TP alert: {e}")

    async def _sync_progressive_adjustment_with_mirror(self, monitor_data: Dict, tp_level: str):
        """Sync progressive SL adjustments with mirror account"""
        try:
            # Implementation would sync the progressive SL adjustment with mirror account
            # For now, log the action
            symbol = monitor_data["symbol"]
            side = monitor_data["side"]
            logger.info(f"ü™û MIRROR SYNC: {tp_level} adjustment for {symbol} {side}")

            # TODO: Implement actual mirror synchronization

        except Exception as e:
            logger.error(f"Error syncing progressive adjustment with mirror: {e}")

    async def _trigger_mirror_sync_for_position_increase(self, symbol: str, side: str, new_size: Decimal, size_increase: Decimal):
        """
        Trigger mirror account synchronization when main position increases due to limit order fills
        This ensures mirror TPs are rebalanced immediately when limit orders fill
        """
        try:
            from execution.mirror_enhanced_tp_sl import initialize_mirror_manager
            mirror_manager = initialize_mirror_manager(self)
            if not mirror_manager:
                return

            logger.info(f"üîÑ Triggering mirror sync for position increase: {symbol} {side} +{size_increase}")

            # Get the main monitor data to pass to mirror
            monitor_key = f"{symbol}_{side}"
            if monitor_key not in self.position_monitors:
                logger.warning(f"No main monitor data found for {symbol} {side}")
                return

            main_monitor_data = self.position_monitors[monitor_key]

            # Mirror sync removed - mirror accounts operate independently
            # Each account's monitors handle their own positions without syncing
            logger.info(f"‚úÖ Mirror accounts operate independently - no sync needed")

        except Exception as e:
            logger.error(f"Error triggering mirror sync for position increase: {e}")

    async def _save_to_persistence(self):
        """Save current monitors to persistence file"""
        try:
            import pickle
            from utils.robust_persistence import RobustPersistenceManager

            persistence_manager = RobustPersistenceManager()

            # Read current data
            data = await persistence_manager.read_data()

            # Update enhanced_tp_sl_monitors
            if 'bot_data' not in data:
                data['bot_data'] = {}
            data['bot_data']['enhanced_tp_sl_monitors'] = self.position_monitors

            # Write updated data back
            await persistence_manager.write_data(data)

            logger.debug("üíæ Monitors saved to persistence")

        except Exception as e:
            logger.error(f"‚ùå Error saving to persistence: {e}")

    async def _create_dashboard_monitor_entry(self, monitor_data: Dict):
        """Create dashboard monitor entry for UI visibility"""
        try:
            # Extract required fields
            symbol = monitor_data.get("symbol")
            side = monitor_data.get("side")
            approach = monitor_data.get("approach", "unknown")
            chat_id = monitor_data.get("chat_id")
            account_type = monitor_data.get("account_type", "main")

            # Create monitor tasks entry for dashboard only if we have a chat_id
            if chat_id:
                await self._create_monitor_tasks_entry(
                    chat_id=chat_id,
                    symbol=symbol,
                    side=side,
                    approach=approach,
                    account_type=account_type
                )
            else:
                logger.warning(f"‚ö†Ô∏è Skipping dashboard monitor entry for {symbol} {side} - no chat_id")

            logger.debug(f"‚úÖ Created dashboard monitor entry for {symbol} {side}")

        except Exception as e:
            logger.error(f"‚ùå Error creating dashboard monitor entry: {e}")

    async def sync_existing_positions(self):
        """
        Sync existing positions and create monitors for positions without them
        This ensures all positions are monitored even after bot restarts
        """
        try:
            logger.info("üîÑ Starting position sync for Enhanced TP/SL monitoring")

            # Get all open positions
            from clients.bybit_helpers import get_all_positions
            all_positions = await get_all_positions()

            if not all_positions:
                logger.info("üìä No open positions found to sync")
                return

            logger.info(f"üìä Found {len(all_positions)} positions to check")

            monitors_created = 0
            monitors_skipped = 0

            for position in all_positions:
                try:
                    symbol = position.get('symbol')
                    side = position.get('side')
                    size = float(position.get('size', 0))

                    if size <= 0:
                        continue

                    # Always use account-aware key format
                    account_type = "main"  # Position sync is for main account
                    monitor_key = f"{symbol}_{side}_{account_type}"

                    # Check if monitor already exists
                    if monitor_key in self.position_monitors:
                        logger.debug(f"‚úÖ Monitor already exists for {monitor_key}")
                        monitors_skipped += 1
                        continue

                    # Try to find chat_id from user data
                    chat_id = None
                    try:
                        import pickle
                        pkl_path = 'bybit_bot_dashboard_v4.1_enhanced.pkl'
                        with open(pkl_path, 'rb') as f:
                            data = pickle.load(f)

                        # Find chat_id from user_data
                        user_data = data.get('user_data', {})
                        for uid, udata in user_data.items():
                            if 'positions' in udata:
                                # Check if this user has this position
                                for pos in udata.get('positions', []):
                                    if pos.get('symbol') == symbol and pos.get('side') == side:
                                        chat_id = uid
                                        logger.info(f"‚úÖ Found chat_id {chat_id} from user data for {symbol} {side}")
                                        break
                                if chat_id:
                                    break
                    except Exception as e:
                        logger.warning(f"Could not retrieve chat_id from user data: {e}")

                    # If no chat_id found, try to get from any existing monitor_tasks
                    if not chat_id:
                        try:
                            bot_data = data.get('bot_data', {})
                            monitor_tasks = bot_data.get('monitor_tasks', {})
                            for mk, mv in monitor_tasks.items():
                                if mv.get('symbol') == symbol:
                                    chat_id = mv.get('chat_id')
                                    if chat_id:
                                        logger.info(f"‚úÖ Found chat_id {chat_id} from monitor_tasks for {symbol}")
                                        break
                        except:
                            pass

                    if not chat_id:
                        logger.warning(f"‚ö†Ô∏è Could not find chat_id for {symbol} {side} - creating monitor without alerts")

                    # Create monitor for this position
                    logger.info(f"üÜï Creating monitor for orphaned position: {symbol} {side}")

                    # Get position details
                    avg_price = Decimal(str(position.get('avgPrice', 0)))

                    # Get orders for this position
                    orders = await get_open_orders(symbol)
                    tp_orders = {}
                    sl_order = None

                    for order in orders:
                        if order['orderType'] == 'TakeProfit':
                            tp_orders[order['orderId']] = {
                                'orderId': order['orderId'],
                                'price': Decimal(str(order['price'])),
                                'qty': Decimal(str(order['qty'])),
                                'orderLinkId': order.get('orderLinkId', ''),
                                'status': order['orderStatus']
                            }
                        elif order['orderType'] == 'StopLoss':
                            sl_order = {
                                'orderId': order['orderId'],
                                'price': Decimal(str(order['triggerPrice'])),
                                'qty': Decimal(str(order['qty'])),
                                'orderLinkId': order.get('orderLinkId', ''),
                                'status': order['orderStatus']
                            }

                    # Create monitor data
                    monitor_data = {
                        "symbol": symbol,
                        "side": side,
                        "position_size": Decimal(str(size)),
                        "remaining_size": Decimal(str(size)),
                        "entry_price": avg_price,
                        "avg_price": avg_price,
                        "approach": "unknown",  # Will be determined by order structure
                        "tp_orders": tp_orders,
                        "sl_order": sl_order,
                        "filled_tps": [],
                        "cancelled_limits": False,
                        "tp1_hit": False,
                        "tp1_info": None,
                        "sl_moved_to_be": False,
                        "sl_move_attempts": 0,
                        "created_at": time.time(),
                        "last_check": time.time(),
                        "limit_orders": [],
                        "limit_orders_cancelled": False,
                        "phase": "MONITORING",
                        "chat_id": chat_id,  # Retrieved from user data or None
                        "account_type": account_type  # Use the account_type variable
                    }

                    # Determine approach based on order structure
                    if len(tp_orders) > 1:
                        monitor_data["approach"] = "conservative"
                    else:
                        monitor_data["approach"] = "fast"

                    # Add to monitors with account-aware key
                    self.position_monitors[monitor_key] = monitor_data

                    # Save to persistence
                    await self._save_to_persistence()

                    # Create dashboard monitor entry
                    await self._create_dashboard_monitor_entry(monitor_data)

                    monitors_created += 1
                    logger.info(f"‚úÖ Created monitor for {symbol} {side} with {len(tp_orders)} TP orders")

                except Exception as e:
                    logger.error(f"‚ùå Error creating monitor for position {position}: {e}")
                    continue

            logger.info(f"üîÑ Position sync complete: {monitors_created} created, {monitors_skipped} skipped")

            # Mirror sync removed - mirror accounts operate independently
            # Each account's monitors handle their own positions without syncing

        except Exception as e:
            logger.error(f"‚ùå Error during position sync: {e}")
            import traceback
            traceback.print_exc()

# Global instance
enhanced_tp_sl_manager = EnhancedTPSLManager()

# Initialize mirror manager
try:
    from execution.mirror_enhanced_tp_sl import initialize_mirror_manager
    mirror_manager = initialize_mirror_manager(enhanced_tp_sl_manager)
    logger.info("‚úÖ Mirror enhanced TP/SL manager initialized")
except Exception as e:
    logger.warning(f"Could not initialize mirror enhanced TP/SL manager: {e}")