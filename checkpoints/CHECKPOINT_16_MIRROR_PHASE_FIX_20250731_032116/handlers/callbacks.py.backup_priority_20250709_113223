#!/usr/bin/env python3
"""
Enhanced callback query handlers - MANUAL OPTIMIZED, VOICE REMOVED.
ENHANCED: Better UX, mobile optimization, streamlined workflows
"""
import logging
import asyncio
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from config.constants import *
from utils.helpers import initialize_chat_data
from dashboard.generator_analytics_compact import build_mobile_dashboard_text as build_dashboard_text_async
# Removed old imports that don't exist anymore
from dashboard.keyboards_analytics import (
    build_enhanced_dashboard_keyboard, build_settings_keyboard,
    build_stats_keyboard, build_position_management_keyboard,
    build_help_keyboard
)
from shared import msg_manager
from handlers.commands import start_auto_refresh, stop_auto_refresh

logger = logging.getLogger(__name__)

async def handle_dashboard_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced dashboard callback handling with better UX"""
    query = update.callback_query
    if not query:
        return

    try:
        await query.answer()

        if query.data == "refresh_dashboard":
            # Enhanced dashboard refresh
            if context.chat_data is None:
                context.chat_data = {}
            initialize_chat_data(context.chat_data)

            # Clear any cached data to ensure fresh UI
            from utils.cache import invalidate_all_caches
            invalidate_all_caches()

            # Force reload persistence to get latest stats
            try:
                await context.application.persistence.flush()
                logger.info("Flushed persistence before refresh")
            except Exception as e:
                logger.warning(f"Could not flush persistence: {e}")

            # Delete the current message (which is the old dashboard)
            try:
                await query.message.delete()
                logger.debug("Deleted old dashboard message via refresh")
            except Exception as e:
                logger.debug(f"Could not delete message: {e}")

            # Clear stored message ID since we deleted it
            context.chat_data[LAST_UI_MESSAGE_ID] = None

            # Load fresh data
            dashboard_text = await build_dashboard_text_async(context.chat_data, context.application.bot_data)

            # Get position count for keyboard
            from clients.bybit_client import get_all_positions
            positions = await get_all_positions()
            active_positions = len([p for p in positions if float(p.get('size', 0)) > 0])
            has_monitors = context.chat_data.get('ACTIVE_MONITOR_TASK', {}) != {}

            keyboard = build_enhanced_dashboard_keyboard(query.message.chat.id, context, active_positions, has_monitors)

            # Send new message with enhanced UI
            try:
                sent = await context.bot.send_message(
                    chat_id=query.message.chat.id,
                    text=dashboard_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )
                # Store message ID for future updates
                context.chat_data[LAST_UI_MESSAGE_ID] = sent.message_id

                logger.info(f"Dashboard refreshed for chat {query.message.chat.id}")

                # Restart auto-refresh after manual refresh
                await start_auto_refresh(query.message.chat.id, context)
            except Exception as e:
                logger.error(f"Error refreshing dashboard: {e}")
                # Fallback: send a simple status message
                await query.edit_message_text(
                    "âš ï¸ Dashboard temporarily unavailable. Please try again.",
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )

        elif query.data == "view_positions":
            # Professional position viewing
            await query.edit_message_text(
                "ğŸ“Š <b>Loading Portfolio Positions...</b>\n\nAnalyzing current positions...",
                parse_mode=ParseMode.HTML
            )

            positions_text = await fetch_all_trades_status()
            keyboard = build_position_management_keyboard()

            await query.edit_message_text(
                positions_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "trade_settings":
            # Beautiful settings display
            from dashboard.generator_analytics_compact import create_beautiful_header, create_info_line, create_elegant_divider

            settings_text = f"""â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      âš™ï¸ <b>TRADING CONFIGURATION</b>      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{create_beautiful_header("CORE PARAMETERS", "âš™ï¸")}{create_info_line("Leverage Settings", "Configure default leverage levels")}
{create_info_line("Margin Configuration", "Set preferred margin amounts")}
{create_info_line("Risk Management", "Define safety parameters")}

{create_beautiful_header("STRATEGY SETTINGS", "ğŸ¯")}{create_info_line("Default Approach", "Fast Market or Conservative Limits")}
{create_info_line("Order Preferences", "Customized execution parameters")}
{create_info_line("Alert Configuration", "Notification preferences")}

{create_beautiful_header("INTERFACE OPTIONS", "ğŸ“±")}{create_info_line("Display Preferences", "Professional interface customization")}
{create_info_line("AI Configuration", "Market intelligence settings")}

{create_elegant_divider()}
<i>âœ¨ Professional Trading Configuration Panel âœ¨</i>
"""

            keyboard = build_settings_keyboard()

            await query.edit_message_text(
                settings_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "view_stats":
            # Beautiful statistics display
            from dashboard.generator_analytics_compact import create_beautiful_header, create_status_line, create_info_line, create_elegant_divider

            # Get current stats
            total_trades = context.application.bot_data.get(STATS_TOTAL_TRADES, 0)
            total_wins = context.application.bot_data.get(STATS_TOTAL_WINS, 0)
            total_losses = context.application.bot_data.get(STATS_TOTAL_LOSSES, 0)
            total_pnl = context.application.bot_data.get(STATS_TOTAL_PNL, 0)

            win_rate = (total_wins / (total_wins + total_losses) * 100) if (total_wins + total_losses) > 0 else 0
            pnl_status = "positive" if total_pnl >= 0 else "negative"
            win_rate_status = "excellent" if win_rate >= 70 else "success" if win_rate >= 60 else "warning" if win_rate >= 40 else "negative"

            stats_text = f"""â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      ğŸ“Š <b>PERFORMANCE ANALYTICS</b>      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{create_beautiful_header("TRADING METRICS", "ğŸ“Š")}{create_info_line("Total Executions", f"{total_trades}")}
{create_status_line("Successful Trades", f"{total_wins}", "success")}
{create_info_line("Unsuccessful Trades", f"{total_losses}")}
{create_status_line("Success Rate", f"{win_rate:.1f}%", win_rate_status)}

{create_beautiful_header("FINANCIAL PERFORMANCE", "ğŸ’°")}{create_status_line("Net P&L", f"{total_pnl} USDT", pnl_status)}

{create_beautiful_header("SYSTEM STATUS", "ğŸ”§")}{create_status_line("Analytics Engine", "Active", "success")}
{create_status_line("Performance Tracking", "Real-time", "success")}

{create_elegant_divider()}
<i>âœ¨ Professional Analytics Dashboard âœ¨</i>
"""

            keyboard = build_stats_keyboard()

            await query.edit_message_text(
                stats_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "back_to_dashboard":
            # Enhanced back to dashboard - DELETE old message and send new
            if context.chat_data is None:
                context.chat_data = {}
            initialize_chat_data(context.chat_data)

            # Delete the current message
            try:
                await query.message.delete()
                logger.debug("Deleted old message when returning to dashboard")
            except Exception as e:
                logger.debug(f"Could not delete message: {e}")

            # Clear stored message ID
            context.chat_data[LAST_UI_MESSAGE_ID] = None

            # Build fresh dashboard
            dashboard_text = await build_dashboard_text_async(context.chat_data, context.application.bot_data)
            keyboard = build_enhanced_dashboard_keyboard()

            # Send new dashboard message
            try:
                sent = await context.bot.send_message(
                    chat_id=query.message.chat.id,
                    text=dashboard_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )
                # Store new message ID
                context.chat_data[LAST_UI_MESSAGE_ID] = sent.message_id
                logger.debug(f"Sent new dashboard message {sent.message_id} when returning")
            except Exception as e:
                logger.error(f"Error returning to dashboard: {e}")
                # Fallback - send simple message
                await context.bot.send_message(
                    chat_id=query.message.chat.id,
                    text="ğŸ  <b>Dashboard</b>\n\nError loading dashboard. Please try /start",
                    parse_mode=ParseMode.HTML
                )

        elif query.data == "show_comprehensive_help":
            # Show comprehensive help documentation
            try:
                help_text = await generate_comprehensive_help()
                keyboard = build_help_keyboard()

                # Check message length and split if needed
                from utils.formatters import split_long_message_mobile

                if len(help_text) > 4000:
                    # Send as multiple messages if too long
                    message_parts = split_long_message_mobile(help_text)

                    # Edit first message with first part
                    await query.edit_message_text(
                        message_parts[0],
                        parse_mode=ParseMode.HTML,
                        reply_markup=keyboard if len(message_parts) == 1 else None
                    )

                    # Send additional parts if any
                    for i, part in enumerate(message_parts[1:], 1):
                        reply_markup = keyboard if i == len(message_parts) - 1 else None
                        await context.bot.send_message(
                            chat_id=query.message.chat.id,
                            text=part,
                            parse_mode=ParseMode.HTML,
                            reply_markup=reply_markup
                        )
                else:
                    await query.edit_message_text(
                        help_text,
                        parse_mode=ParseMode.HTML,
                        reply_markup=keyboard
                    )

                logger.info(f"Comprehensive help displayed for chat {query.message.chat.id}")
            except Exception as e:
                logger.error(f"Error showing comprehensive help: {e}")
                await query.edit_message_text(
                    "ğŸ“– <b>HELP SYSTEM</b>\n\nLoading documentation...\nPlease try again in a moment.",
                    parse_mode=ParseMode.HTML,
                    reply_markup=build_enhanced_dashboard_keyboard()
                )

    except Exception as e:
        logger.error(f"Error in dashboard callbacks: {e}")
        try:
            await query.answer("âŒ Error processing request. Please try again.")
        except:
            pass

async def handle_trading_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced trading callbacks with better UX"""
    query = update.callback_query
    if not query:
        return

    try:
        if query.data == "start_conversation":
            # Enhanced conversation start - redirect to conversation handler
            await query.answer("ğŸš€ Starting enhanced trade setup...")
            from .conversation import start_conversation
            await start_conversation(update, context)
            return

        await query.answer()

        if query.data == "execute_trade":
            # Enhanced trade execution
            await execute_current_trade_with_monitoring(update, context)

        elif query.data == "cancel_trade":
            # Enhanced trade cancellation
            if context.chat_data:
                context.chat_data.clear()
                initialize_chat_data(context.chat_data)

            cancel_text = """
âŒ <b>Trade Cancelled</b>

âœ… Trade setup cleared
ğŸ  Returning to dashboard...
"""

            await query.edit_message_text(
                cancel_text,
                parse_mode=ParseMode.HTML,
                reply_markup=build_enhanced_dashboard_keyboard()
            )

        elif query.data == "modify_trade":
            # Enhanced trade modification
            modify_text = """
ğŸ”§ <b>MODIFY TRADE</b>
{'â•' * 25}

ğŸ“ <b>Available Options:</b>

â€¢ Start new manual setup
â€¢ Return to dashboard to review
â€¢ Quick settings adjustment

ğŸ’¡ <b>Choose your preferred method:</b>
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“ New Manual Setup", callback_data="start_conversation")],
                [InlineKeyboardButton("ğŸ“Š Review Current", callback_data="refresh_dashboard")],
                [InlineKeyboardButton("âš™ï¸ Quick Settings", callback_data="trade_settings")]
            ])

            await query.edit_message_text(
                modify_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data.startswith("select_symbol_"):
            # Enhanced symbol selection
            symbol = query.data.replace("select_symbol_", "")
            if context.chat_data:
                context.chat_data[SYMBOL] = symbol

            selection_text = f"""
âœ… <b>Symbol Selected: {symbol}</b>

ğŸ¯ <b>Next Step: Trading Direction</b>

Choose your position direction:
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“ˆ LONG (Buy)", callback_data="select_side_Buy")],
                [InlineKeyboardButton("ğŸ“‰ SHORT (Sell)", callback_data="select_side_Sell")],
                [InlineKeyboardButton("ğŸ“ Manual Setup", callback_data="start_conversation")]
            ])

            await query.edit_message_text(
                selection_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data.startswith("select_side_"):
            # Enhanced side selection
            side = query.data.replace("select_side_", "")
            if context.chat_data:
                context.chat_data[SIDE] = side

            direction = "LONG" if side == "Buy" else "SHORT"
            direction_emoji = "ğŸ“ˆ" if side == "Buy" else "ğŸ“‰"

            selection_text = f"""
âœ… <b>Direction: {direction_emoji} {direction}</b>

ğŸ¯ <b>Next: Complete Trade Setup</b>

Choose how to continue:
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“ Complete Manual Setup", callback_data="start_conversation")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")],
                [InlineKeyboardButton("âš™ï¸ Settings", callback_data="trade_settings")]
            ])

            await query.edit_message_text(
                selection_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

    except Exception as e:
        logger.error(f"Error in trading callbacks: {e}")
        try:
            await query.answer("âŒ Error processing trade request. Please try again.")
        except:
            pass

async def handle_settings_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced settings callbacks"""
    query = update.callback_query
    if not query:
        return

    try:
        await query.answer()

        if query.data.startswith("set_"):
            setting_type = query.data.replace("set_", "")

            if setting_type == "leverage":
                settings_text = """
âš¡ <b>LEVERAGE SETTINGS</b>
{'â•' * 30}

ğŸ¯ <b>Set Your Default Leverage:</b>

ğŸŸ¢ <b>Conservative:</b> 5x-10x (Safer)
ğŸŸ¡ <b>Moderate:</b> 10x-20x (Balanced)
ğŸŸ  <b>Aggressive:</b> 20x-50x (Higher Risk)

ğŸ’¡ <b>Current Default:</b> 10x
"""

                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸŸ¢ 5x Safe", callback_data="save_leverage_5"),
                     InlineKeyboardButton("ğŸŸ¢ 10x Safe", callback_data="save_leverage_10")],
                    [InlineKeyboardButton("ğŸŸ¡ 20x Moderate", callback_data="save_leverage_20"),
                     InlineKeyboardButton("ğŸŸ  50x Aggressive", callback_data="save_leverage_50")],
                    [InlineKeyboardButton("âš™ï¸ Back to Settings", callback_data="trade_settings")]
                ])

                await query.edit_message_text(
                    settings_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )

            elif setting_type == "margin":
                settings_text = """
ğŸ’° <b>MARGIN SETTINGS</b>
{'â•' * 30}

ğŸ¯ <b>Set Your Default Margin:</b>

ğŸ’š <b>Small:</b> $25-50 (Learning)
ğŸ’™ <b>Medium:</b> $50-100 (Regular)
ğŸ’œ <b>Large:</b> $100-500 (Advanced)

ğŸ’¡ <b>Current Default:</b> 50 USDT
"""

                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ’š $25", callback_data="save_margin_25"),
                     InlineKeyboardButton("ğŸ’š $50", callback_data="save_margin_50")],
                    [InlineKeyboardButton("ğŸ’™ $100", callback_data="save_margin_100"),
                     InlineKeyboardButton("ğŸ’œ $200", callback_data="save_margin_200")],
                    [InlineKeyboardButton("âš™ï¸ Back to Settings", callback_data="trade_settings")]
                ])

                await query.edit_message_text(
                    settings_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )

        elif query.data.startswith("save_"):
            # Enhanced save handling
            setting_data = query.data.replace("save_", "")

            if setting_data.startswith("leverage_"):
                leverage = setting_data.replace("leverage_", "")
                success_text = f"""
âœ… <b>Leverage Updated!</b>

âš¡ <b>New Default:</b> {leverage}x

ğŸ¯ This will be used for new trades
ğŸ“ You can still adjust per trade

ğŸ’¡ <b>Saved successfully!</b>
"""

                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ“ Start Trading", callback_data="start_conversation")],
                    [InlineKeyboardButton("âš™ï¸ More Settings", callback_data="trade_settings")],
                    [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
                ])

                await query.edit_message_text(
                    success_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )

            elif setting_data.startswith("margin_"):
                margin = setting_data.replace("margin_", "")
                success_text = f"""
âœ… <b>Margin Updated!</b>

ğŸ’° <b>New Default:</b> ${margin} USDT

ğŸ¯ This will be used for new trades
ğŸ“ You can still adjust per trade

ğŸ’¡ <b>Saved successfully!</b>
"""

                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ“ Start Trading", callback_data="start_conversation")],
                    [InlineKeyboardButton("âš™ï¸ More Settings", callback_data="trade_settings")],
                    [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
                ])

                await query.edit_message_text(
                    success_text,
                    parse_mode=ParseMode.HTML,
                    reply_markup=keyboard
                )

    except Exception as e:
        logger.error(f"Error in settings callbacks: {e}")
        try:
            await query.answer("âŒ Error updating settings. Please try again.")
        except:
            pass

async def handle_stats_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced statistics callbacks"""
    query = update.callback_query
    if not query:
        return

    try:
        await query.answer()

        if query.data == "detailed_stats":
            await show_detailed_stats(update, context)
        elif query.data == "performance_chart":
            await show_performance_chart(update, context)
        elif query.data == "fast_approach_stats":
            await show_fast_approach_stats(update, context)
        elif query.data == "conservative_approach_stats":
            await show_conservative_approach_stats(update, context)
        elif query.data == "export_stats":
            await export_stats(update, context)
        elif query.data == "reset_stats":
            confirm_text = """
âš ï¸ <b>RESET STATISTICS</b>
{'â•' * 30}

ğŸ”” <b>Are you sure?</b>

This will permanently delete:
â€¢ All trade history
â€¢ Win/loss records
â€¢ P&L data
â€¢ Performance metrics

âŒ <b>This cannot be undone!</b>
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("âœ… Yes, Reset All", callback_data="confirm_reset_stats")],
                [InlineKeyboardButton("âŒ Cancel", callback_data="view_stats")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await query.edit_message_text(
                confirm_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "confirm_reset_stats":
            # Backup stats before reset
            try:
                from utils.stats_backup import backup_stats
                await backup_stats(context.application.bot_data)
                logger.info("ğŸ“Š Stats backed up before reset")
            except Exception as e:
                logger.warning(f"Could not backup stats before reset: {e}")

            # Reset all statistics
            from decimal import Decimal
            stats_keys = [
                STATS_TOTAL_TRADES, STATS_TOTAL_WINS, STATS_TOTAL_LOSSES,
                STATS_TP1_HITS, STATS_SL_HITS, STATS_OTHER_CLOSURES,
                STATS_TOTAL_PNL, STATS_WIN_STREAK, STATS_LOSS_STREAK,
                STATS_BEST_TRADE, STATS_WORST_TRADE,
                STATS_CONSERVATIVE_TRADES, STATS_FAST_TRADES,
                STATS_CONSERVATIVE_TP1_CANCELLATIONS,
                'stats_total_wins_pnl', 'stats_total_losses_pnl',
                'stats_max_drawdown', 'stats_peak_equity',
                'stats_current_drawdown', 'recent_trade_pnls'
            ]

            for key in stats_keys:
                if key in [STATS_TOTAL_PNL, STATS_BEST_TRADE, STATS_WORST_TRADE,
                          'stats_total_wins_pnl', 'stats_total_losses_pnl',
                          'stats_max_drawdown', 'stats_peak_equity', 'stats_current_drawdown']:
                    context.application.bot_data[key] = Decimal("0")
                elif key == 'recent_trade_pnls':
                    context.application.bot_data[key] = []
                else:
                    context.application.bot_data[key] = 0

            import time
            context.application.bot_data[STATS_LAST_RESET] = time.time()

            success_text = """
âœ… <b>Statistics Reset Complete</b>

ğŸ—‘ï¸ All trading data cleared
ğŸ“Š Fresh start ready
â° Timestamp updated

ğŸ’¡ <b>Ready for new trades!</b>
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“ Start Trading", callback_data="start_conversation")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await query.edit_message_text(
                success_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

    except Exception as e:
        logger.error(f"Error in stats callbacks: {e}")
        try:
            await query.answer("âŒ Error processing stats request. Please try again.")
        except:
            pass

async def handle_device_size_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle device size selection callbacks"""
    query = update.callback_query
    if not query:
        return

    try:
        await query.answer()

        if query.data.startswith("set_device:"):
            device_size = query.data.split(":")[1]

            # Save device size preference
            if device_size == "auto":
                # Remove custom setting to use auto-detection
                context.chat_data.pop("device_size", None)
                device_display = "Auto-Detect"
            else:
                context.chat_data["device_size"] = device_size
                device_display = device_size.upper()

            # Confirmation message
            success_text = f"""
âœ… <b>Device Size Updated</b>
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Your dashboard will now use the <b>{device_display}</b> layout.

The dashboard has been optimized for your device with:
â€¢ Adjusted box widths
â€¢ Optimized padding
â€¢ Tailored information density
â€¢ {'Compact' if device_size in ['small', 'medium'] else 'Full'} feature display

ğŸ’¡ Your preference has been saved.
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”„ View Dashboard", callback_data="refresh_dashboard")],
                [InlineKeyboardButton("ğŸ“± Change Device", callback_data="show_device_settings")]
            ])

            await query.edit_message_text(
                success_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "show_device_settings":
            # Show device settings again
            context.args = []
            from .commands import device_size_command
            # Create a fake update with message
            class FakeMessage:
                def __init__(self, chat_id):
                    self.chat = type('obj', (object,), {'id': chat_id})
                async def reply_text(self, *args, **kwargs):
                    await context.bot.send_message(self.chat.id, *args, **kwargs)

            fake_update = type('obj', (object,), {
                'message': FakeMessage(query.message.chat.id),
                'effective_chat': query.message.chat
            })()

            await device_size_command(fake_update, context)

    except Exception as e:
        logger.error(f"Error in device size callbacks: {e}")
        try:
            await query.answer("âŒ Error updating device size. Please try again.")
        except:
            pass

async def handle_position_callbacks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced position management callbacks"""
    query = update.callback_query
    if not query:
        return

    try:
        await query.answer()

        if query.data == "close_position":
            positions_text = """
âš ï¸ <b>CLOSE POSITIONS</b>
{'â•' * 30}

ğŸ¯ <b>Position Management</b>

Choose your action:
â€¢ View all positions first
â€¢ Close specific position
â€¢ Emergency close all

ğŸ’¡ <b>Safety First!</b>
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“Š View All Positions", callback_data="view_positions")],
                [InlineKeyboardButton("âš ï¸ Close All (Emergency)", callback_data="emergency_close_all")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await query.edit_message_text(
                positions_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        elif query.data == "modify_position":
            modify_text = """
ğŸ”§ <b>MODIFY POSITIONS</b>
{'â•' * 30}

ğŸ¯ <b>Available Modifications:</b>

â€¢ Adjust stop loss levels
â€¢ Update take profit targets
â€¢ Change position size
â€¢ Add to existing position

ğŸ’¡ <b>Select your preferred action:</b>
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“Š View Positions First", callback_data="view_positions")],
                [InlineKeyboardButton("ğŸ”§ Advanced Settings", callback_data="trade_settings")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await query.edit_message_text(
                modify_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

    except Exception as e:
        logger.error(f"Error in position callbacks: {e}")
        try:
            await query.answer("âŒ Error processing position request. Please try again.")
        except:
            pass

async def execute_current_trade_with_monitoring(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Enhanced trade execution with monitoring"""
    query = update.callback_query
    if not query:
        return

    chat_id = query.message.chat.id

    try:
        # Enhanced execution message
        execution_msg = """
ğŸš€ <b>EXECUTING TRADE...</b>
{'â•' * 30}

âš¡ Placing orders on Bybit
ğŸ“ˆ Performance tracking enabled
ğŸ¯ Mobile notifications active

â³ <b>Please wait...</b>
This may take a few seconds...
"""

        try:
            await query.edit_message_text(execution_msg, parse_mode=ParseMode.HTML)
        except:
            pass

        # Validate trade data
        symbol = context.chat_data.get(SYMBOL, "N/A") if context.chat_data else "N/A"
        side = context.chat_data.get(SIDE, "N/A") if context.chat_data else "N/A"

        if not context.chat_data or symbol == "N/A" or side == "N/A":
            error_text = """
âŒ <b>Execution Failed</b>

ğŸ” <b>Issue:</b> No trade setup found

ğŸ’¡ <b>Solution:</b>
â€¢ Use /start to access dashboard
â€¢ Set up a new trade manually
â€¢ Check all required fields
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“ Start New Trade", callback_data="start_conversation")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await context.bot.send_message(
                chat_id,
                error_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )
            return

        # Store execution info
        context.chat_data["_temp_chat_id"] = chat_id
        context.chat_data["_execution_source"] = "enhanced_callback"

        # Execute trade
        try:
            from execution.trader import execute_trade_logic

            loop = asyncio.get_running_loop()
            cfg = context.chat_data.copy() if context.chat_data else {}
            cfg["_temp_chat_id"] = chat_id

            # Execute with monitoring
            result = await asyncio.to_thread(execute_trade_logic, cfg, context.application, loop)

            # Enhanced success message
            success_text = f"""
âœ… <b>TRADE EXECUTED!</b>

{result}

ğŸ¯ <b>What's Next:</b>
â€¢ Monitor your position
â€¢ Check performance stats
â€¢ Set up another trade
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ“Š View Position", callback_data="view_positions")],
                [InlineKeyboardButton("ğŸ“ New Trade", callback_data="start_conversation")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await context.bot.send_message(
                chat_id,
                success_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        except Exception as e:
            logger.error(f"Trade execution error: {e}")
            error_text = f"""
âŒ <b>Execution Failed</b>

ğŸ” <b>Error:</b> {str(e)}

ğŸ’¡ <b>What to try:</b>
â€¢ Check your connection
â€¢ Verify account balance
â€¢ Try again in a moment
â€¢ Contact support if needed
"""

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”„ Try Again", callback_data="execute_trade")],
                [InlineKeyboardButton("ğŸ“Š Dashboard", callback_data="refresh_dashboard")]
            ])

            await context.bot.send_message(
                chat_id,
                error_text,
                parse_mode=ParseMode.HTML,
                reply_markup=keyboard
            )

        # Return to dashboard
        try:
            from handlers.commands import _send_or_edit_dashboard_message
            await _send_or_edit_dashboard_message(chat_id, context, new_msg=True)
        except:
            pass

    except Exception as e:
        logger.error(f"Error in enhanced trade execution: {e}")
        try:
            await context.bot.send_message(
                chat_id,
                "âŒ Error executing trade. Please try again.",
                parse_mode=ParseMode.HTML
            )
        except:
            pass

async def show_detailed_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show detailed statistics breakdown"""
    query = update.callback_query
    if not query:
        return

    try:
        # Get all statistics
        total_trades = context.application.bot_data.get(STATS_TOTAL_TRADES, 0)
        total_wins = context.application.bot_data.get(STATS_TOTAL_WINS, 0)
        total_losses = context.application.bot_data.get(STATS_TOTAL_LOSSES, 0)
        total_pnl = context.application.bot_data.get(STATS_TOTAL_PNL, 0)
        tp1_hits = context.application.bot_data.get(STATS_TP1_HITS, 0)
        sl_hits = context.application.bot_data.get(STATS_SL_HITS, 0)
        other_closures = context.application.bot_data.get(STATS_OTHER_CLOSURES, 0)
        win_streak = context.application.bot_data.get(STATS_WIN_STREAK, 0)
        loss_streak = context.application.bot_data.get(STATS_LOSS_STREAK, 0)
        best_trade = context.application.bot_data.get(STATS_BEST_TRADE, 0)
        worst_trade = context.application.bot_data.get(STATS_WORST_TRADE, 0)

        win_rate = (total_wins / (total_wins + total_losses) * 100) if (total_wins + total_losses) > 0 else 0
        avg_win = (total_pnl / total_wins) if total_wins > 0 else 0

        stats_text = f"""
ğŸ“Š <b>DETAILED TRADING STATISTICS</b>
{'â•' * 35}

ğŸ“ˆ <b>Trade Summary:</b>
â€¢ Total Trades: {total_trades}
â€¢ Win Rate: {win_rate:.1f}%
â€¢ Total P&L: {total_pnl:.2f} USDT

âœ… <b>Wins Analysis:</b>
â€¢ Total Wins: {total_wins}
â€¢ Average Win: {avg_win:.2f} USDT
â€¢ Best Trade: {best_trade:.2f} USDT
â€¢ Win Streak: {win_streak}

âŒ <b>Losses Analysis:</b>
â€¢ Total Losses: {total_losses}
â€¢ Worst Trade: {worst_trade:.2f} USDT
â€¢ Loss Streak: {loss_streak}

ğŸ¯ <b>Exit Analysis:</b>
â€¢ TP1 Hits: {tp1_hits}
â€¢ SL Hits: {sl_hits}
â€¢ Manual Closes: {other_closures}

ğŸ“± <b>Performance Tracking Active</b>
"""

        keyboard = build_stats_keyboard()

        await query.edit_message_text(
            stats_text,
            parse_mode=ParseMode.HTML,
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error showing detailed stats: {e}")
        await query.answer("âŒ Error loading detailed statistics")

async def show_performance_chart(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show performance chart visualization"""
    query = update.callback_query
    if not query:
        return

    try:
        # Get performance data
        total_trades = context.application.bot_data.get(STATS_TOTAL_TRADES, 0)
        total_wins = context.application.bot_data.get(STATS_TOTAL_WINS, 0)
        total_losses = context.application.bot_data.get(STATS_TOTAL_LOSSES, 0)
        total_pnl = context.application.bot_data.get(STATS_TOTAL_PNL, 0)

        win_rate = (total_wins / (total_wins + total_losses) * 100) if (total_wins + total_losses) > 0 else 0

        # Create simple text-based chart
        win_bars = int(win_rate / 10)
        loss_bars = 10 - win_bars

        chart_text = f"""
ğŸ“ˆ <b>PERFORMANCE CHART</b>
{'â•' * 35}

<b>Win Rate Visualization:</b>
{'ğŸŸ¢' * win_bars}{'ğŸ”´' * loss_bars} {win_rate:.1f}%

<b>Trade Distribution:</b>
Wins:  {'â–ˆ' * min(20, int(total_wins/max(1, total_trades)*20))} {total_wins}
Losses: {'â–ˆ' * min(20, int(total_losses/max(1, total_trades)*20))} {total_losses}

<b>P&L Trend:</b>
{'+' if total_pnl >= 0 else ''}{total_pnl:.2f} USDT

ğŸ“Š <b>Visual performance tracking</b>
"""

        keyboard = build_stats_keyboard()

        await query.edit_message_text(
            chart_text,
            parse_mode=ParseMode.HTML,
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error showing performance chart: {e}")
        await query.answer("âŒ Error loading performance chart")

async def show_fast_approach_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show statistics for fast approach trades"""
    query = update.callback_query
    if not query:
        return

    try:
        # Get fast approach specific stats
        stats_text = f"""
âš¡ <b>FAST APPROACH STATISTICS</b>
{'â•' * 35}

<b>Fast Market Trading Style:</b>
â€¢ Single market entry
â€¢ Single take profit
â€¢ Quick execution focus

ğŸ“Š <b>Performance Metrics:</b>
â€¢ Coming soon...

ğŸ’¡ <b>Characteristics:</b>
â€¢ Rapid entry/exit
â€¢ Market order execution
â€¢ Simplified risk management
â€¢ Mobile optimized

ğŸ“± <b>Fast approach tracking enabled</b>
"""

        keyboard = build_stats_keyboard()

        await query.edit_message_text(
            stats_text,
            parse_mode=ParseMode.HTML,
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error showing fast approach stats: {e}")
        await query.answer("âŒ Error loading fast approach statistics")

async def show_conservative_approach_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show statistics for conservative approach trades"""
    query = update.callback_query
    if not query:
        return

    try:
        # Get conservative approach specific stats
        stats_text = f"""
ğŸ›¡ï¸ <b>CONSERVATIVE APPROACH STATISTICS</b>
{'â•' * 35}

<b>Conservative Trading Style:</b>
â€¢ 3 limit entry orders
â€¢ 4 take profit levels
â€¢ Isolated order management

ğŸ“Š <b>Performance Metrics:</b>
â€¢ Coming soon...

ğŸ’¡ <b>Characteristics:</b>
â€¢ Gradual position building
â€¢ Multiple TP targets
â€¢ Enhanced risk distribution
â€¢ TP1 hit cancellation logic

ğŸ“± <b>Conservative approach tracking enabled</b>
"""

        keyboard = build_stats_keyboard()

        await query.edit_message_text(
            stats_text,
            parse_mode=ParseMode.HTML,
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error showing conservative approach stats: {e}")
        await query.answer("âŒ Error loading conservative approach statistics")

async def export_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Export statistics data"""
    query = update.callback_query
    if not query:
        return

    try:
        import json

        # Prepare export data
        export_data = {
            "total_trades": context.application.bot_data.get(STATS_TOTAL_TRADES, 0),
            "total_wins": context.application.bot_data.get(STATS_TOTAL_WINS, 0),
            "total_losses": context.application.bot_data.get(STATS_TOTAL_LOSSES, 0),
            "total_pnl": float(context.application.bot_data.get(STATS_TOTAL_PNL, 0)),
            "tp1_hits": context.application.bot_data.get(STATS_TP1_HITS, 0),
            "sl_hits": context.application.bot_data.get(STATS_SL_HITS, 0),
            "other_closures": context.application.bot_data.get(STATS_OTHER_CLOSURES, 0),
            "win_streak": context.application.bot_data.get(STATS_WIN_STREAK, 0),
            "loss_streak": context.application.bot_data.get(STATS_LOSS_STREAK, 0),
            "best_trade": float(context.application.bot_data.get(STATS_BEST_TRADE, 0)),
            "worst_trade": float(context.application.bot_data.get(STATS_WORST_TRADE, 0)),
            "last_reset": context.application.bot_data.get(STATS_LAST_RESET, 0)
        }

        export_text = f"""
ğŸ“¤ <b>EXPORT STATISTICS</b>
{'â•' * 35}

<b>Export Summary:</b>
â€¢ Total Trades: {export_data['total_trades']}
â€¢ Total P&L: {export_data['total_pnl']:.2f} USDT
â€¢ Win Rate: {(export_data['total_wins'] / max(1, export_data['total_wins'] + export_data['total_losses']) * 100):.1f}%

<b>Export Options:</b>
â€¢ Copy the data below
â€¢ Save for analysis
â€¢ Share with advisors

<code>{json.dumps(export_data, indent=2)}</code>

ğŸ“± <b>Data exported successfully</b>
"""

        keyboard = build_stats_keyboard()

        await query.edit_message_text(
            export_text,
            parse_mode=ParseMode.HTML,
            reply_markup=keyboard
        )

    except Exception as e:
        logger.error(f"Error exporting stats: {e}")
        await query.answer("âŒ Error exporting statistics")